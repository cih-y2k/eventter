// Code generated by ./generator/main.go. DO NOT EDIT.
package v1

//go:generate go run ./generator ./amqp1-0-0.go  ./types.bare.xml ./transport.bare.xml ./messaging.bare.xml ./security.bare.xml

import (
	"bytes"
	"encoding/hex"
	"math"
	"time"

	"github.com/gogo/protobuf/types"
	"github.com/pkg/errors"
)

const (
	DescriptorEncoding = 0x00
)

const (
	RemoteChannelNull = math.MaxUint16
	ChannelMax        = math.MaxUint16 - 1
)

var (
	errNull = errors.New("composite is null")
)

type UUID [16]byte

func (u UUID) String() string {
	var x [36]byte
	hex.Encode(x[:8], u[:4])
	x[8] = '-'
	hex.Encode(x[9:13], u[4:6])
	x[13] = '-'
	hex.Encode(x[14:18], u[6:8])
	x[18] = '-'
	hex.Encode(x[19:23], u[8:10])
	x[23] = '-'
	hex.Encode(x[24:], u[10:])
	return string(x[:])
}

type DescribedType interface {
	Descriptor() uint64
}

type BufferMarshaler interface {
	MarshalBuffer(buf *bytes.Buffer) error
}

type BufferUnmarshaler interface {
	UnmarshalBuffer(buf *bytes.Buffer) error
}

type Frame interface {
	GetFrameMeta() *FrameMeta
	DescribedType
	BufferMarshaler
	BufferUnmarshaler
}

type FrameMeta struct {
	Size       uint32
	DataOffset uint8
	Type       uint8
	Channel    uint16
	Payload    []byte
}

type AMQPFrame interface {
	isAMQPFrame()
}

type ErrorCondition interface {
	isErrorCondition()
}

type Section interface {
	isSection()
}

type MessageID interface {
	isMessageID()
}

type Address interface {
	isAddress()
}

type DeliveryState interface {
	isDeliveryState()
}

type Outcome interface {
	isOutcome()
}

type DistributionMode interface {
	isDistributionMode()
}

type LifetimePolicy interface {
	isLifetimePolicy()
}

type SASLFrame interface {
	isSASLFrame()
}

const (
	NullEncoding = 0x40
)

const (
	BooleanEncoding      = 0x56
	BooleanTrueEncoding  = 0x41
	BooleanFalseEncoding = 0x42
)

const (
	UbyteEncoding = 0x50
)

const (
	UshortEncoding = 0x60
)

const (
	UintEncoding          = 0x70
	UintSmalluintEncoding = 0x52
	Uint0Encoding         = 0x43
)

const (
	UlongEncoding           = 0x80
	UlongSmallulongEncoding = 0x53
	Ulong0Encoding          = 0x44
)

const (
	ByteEncoding = 0x51
)

const (
	ShortEncoding = 0x61
)

const (
	IntEncoding         = 0x71
	IntSmallintEncoding = 0x54
)

const (
	LongEncoding          = 0x81
	LongSmalllongEncoding = 0x55
)

const (
	FloatIeee754Encoding = 0x72
)

const (
	DoubleIeee754Encoding = 0x82
)

const (
	Decimal32Ieee754Encoding = 0x74
)

const (
	Decimal64Ieee754Encoding = 0x84
)

const (
	Decimal128Ieee754Encoding = 0x94
)

const (
	CharUtf32Encoding = 0x73
)

const (
	TimestampMs64Encoding = 0x83
)

const (
	UUIDEncoding = 0x98
)

const (
	BinaryVbin8Encoding  = 0xa0
	BinaryVbin32Encoding = 0xb0
)

const (
	StringStr8Utf8Encoding  = 0xa1
	StringStr32Utf8Encoding = 0xb1
)

const (
	SymbolSym8Encoding  = 0xa3
	SymbolSym32Encoding = 0xb3
)

const (
	List0Encoding  = 0x45
	List8Encoding  = 0xc0
	List32Encoding = 0xd0
)

const (
	Map8Encoding  = 0xc1
	Map32Encoding = 0xd1
)

const (
	Array8Encoding  = 0xe0
	Array32Encoding = 0xf0
)

const (
	OpenName       = "amqp:open:list"
	OpenDescriptor = 0x0000000000000010
)

type Open struct {
	FrameMeta
	ContainerID         string
	Hostname            string
	MaxFrameSize        uint32
	ChannelMax          uint16
	IdleTimeOut         Milliseconds
	OutgoingLocales     []IETFLanguageTag
	IncomingLocales     []IETFLanguageTag
	OfferedCapabilities []string
	DesiredCapabilities []string
	Properties          *Fields
}

func (*Open) isAMQPFrame() {}

func (t *Open) GetFrameMeta() *FrameMeta {
	return &t.FrameMeta
}

func (t *Open) Descriptor() uint64 {
	return OpenDescriptor
}

func (t *Open) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Open) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(OpenDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	count = 1 // container-id is mandatory
	if t.Hostname != "" {
		count = 2
	}
	if t.MaxFrameSize != 0 {
		count = 3
	}
	if t.ChannelMax != 0 {
		count = 4
	}
	if t.IdleTimeOut != 0 {
		count = 5
	}
	if len(t.OutgoingLocales) > 0 {
		count = 6
	}
	if len(t.IncomingLocales) > 0 {
		count = 7
	}
	if len(t.OfferedCapabilities) > 0 {
		count = 8
	}
	if len(t.DesiredCapabilities) > 0 {
		count = 9
	}
	if t.Properties != nil {
		count = 10
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			err = marshalString(t.ContainerID, &itemBuf)
			if err != nil {
				return errors.Wrap(err, "marshal field container-id failed")
			}

			if count > 1 {
				if t.Hostname != "" {
					err = marshalString(t.Hostname, &itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field hostname failed")
					}
				} else {
					err = marshalNull(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field hostname failed")
					}
				}
				if count > 2 {
					if t.MaxFrameSize != 0 {
						err = marshalUint(t.MaxFrameSize, &itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field max-frame-size failed")
						}
					} else {
						err = marshalNull(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field max-frame-size failed")
						}
					}
					if count > 3 {
						if t.ChannelMax != 0 {
							err = marshalUshort(t.ChannelMax, &itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field channel-max failed")
							}
						} else {
							err = marshalNull(&itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field channel-max failed")
							}
						}
						if count > 4 {
							if t.IdleTimeOut != 0 {
								err = t.IdleTimeOut.MarshalBuffer(&itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field idle-time-out failed")
								}
							} else {
								err = marshalNull(&itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field idle-time-out failed")
								}
							}
							if count > 5 {
								if len(t.OutgoingLocales) > 0 {
									err = marshalIETFLanguageTagArray(t.OutgoingLocales, &itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field outgoing-locales failed")
									}

								} else {
									err = marshalNull(&itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field outgoing-locales failed")
									}
								}
								if count > 6 {
									if len(t.IncomingLocales) > 0 {
										err = marshalIETFLanguageTagArray(t.IncomingLocales, &itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field incoming-locales failed")
										}

									} else {
										err = marshalNull(&itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field incoming-locales failed")
										}
									}
									if count > 7 {
										if len(t.OfferedCapabilities) > 0 {
											err = marshalSymbolArray(t.OfferedCapabilities, &itemBuf)
											if err != nil {
												return errors.Wrap(err, "marshal field offered-capabilities failed")
											}

										} else {
											err = marshalNull(&itemBuf)
											if err != nil {
												return errors.Wrap(err, "marshal field offered-capabilities failed")
											}
										}
										if count > 8 {
											if len(t.DesiredCapabilities) > 0 {
												err = marshalSymbolArray(t.DesiredCapabilities, &itemBuf)
												if err != nil {
													return errors.Wrap(err, "marshal field desired-capabilities failed")
												}

											} else {
												err = marshalNull(&itemBuf)
												if err != nil {
													return errors.Wrap(err, "marshal field desired-capabilities failed")
												}
											}
											if count > 9 {
												if t.Properties != nil {
													err = t.Properties.MarshalBuffer(&itemBuf)
													if err != nil {
														return errors.Wrap(err, "marshal field properties failed")
													}
												} else {
													err = marshalNull(&itemBuf)
													if err != nil {
														return errors.Wrap(err, "marshal field properties failed")
													}
												}

											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Open) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Open) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != OpenDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal open failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		constructor, err = itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "unmarshal field container-id failed")
		}
		err = unmarshalString(&t.ContainerID, constructor, itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field container-id failed")
		}
		done = 1
		if count > 1 {
			constructor, err = itemBuf.ReadByte()
			if err != nil {
				return errors.Wrap(err, "unmarshal field hostname failed")
			}
			err = unmarshalString(&t.Hostname, constructor, itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field hostname failed")
			}
			done = 2
			if count > 2 {
				constructor, err = itemBuf.ReadByte()
				if err != nil {
					return errors.Wrap(err, "unmarshal field max-frame-size failed")
				}
				err = unmarshalUint(&t.MaxFrameSize, constructor, itemBuf)
				if err != nil {
					return errors.Wrap(err, "unmarshal field max-frame-size failed")
				}
				done = 3
				if count > 3 {
					constructor, err = itemBuf.ReadByte()
					if err != nil {
						return errors.Wrap(err, "unmarshal field channel-max failed")
					}
					err = unmarshalUshort(&t.ChannelMax, constructor, itemBuf)
					if err != nil {
						return errors.Wrap(err, "unmarshal field channel-max failed")
					}
					done = 4
					if count > 4 {
						err = t.IdleTimeOut.UnmarshalBuffer(itemBuf)
						if err != nil {
							return errors.Wrap(err, "unmarshal field idle-time-out failed")
						}
						done = 5
						if count > 5 {
							constructor, err = itemBuf.ReadByte()
							if err != nil {
								return errors.Wrap(err, "unmarshal field outgoing-locales failed")
							}
							err = unmarshalIETFLanguageTagArray(&t.OutgoingLocales, constructor, itemBuf)
							if err != nil {
								return errors.Wrap(err, "unmarshal field outgoing-locales failed")
							}

							done = 6
							if count > 6 {
								constructor, err = itemBuf.ReadByte()
								if err != nil {
									return errors.Wrap(err, "unmarshal field incoming-locales failed")
								}
								err = unmarshalIETFLanguageTagArray(&t.IncomingLocales, constructor, itemBuf)
								if err != nil {
									return errors.Wrap(err, "unmarshal field incoming-locales failed")
								}

								done = 7
								if count > 7 {
									constructor, err = itemBuf.ReadByte()
									if err != nil {
										return errors.Wrap(err, "unmarshal field offered-capabilities failed")
									}
									err = unmarshalSymbolArray(&t.OfferedCapabilities, constructor, itemBuf)
									if err != nil {
										return errors.Wrap(err, "unmarshal field offered-capabilities failed")
									}

									done = 8
									if count > 8 {
										constructor, err = itemBuf.ReadByte()
										if err != nil {
											return errors.Wrap(err, "unmarshal field desired-capabilities failed")
										}
										err = unmarshalSymbolArray(&t.DesiredCapabilities, constructor, itemBuf)
										if err != nil {
											return errors.Wrap(err, "unmarshal field desired-capabilities failed")
										}

										done = 9
										if count > 9 {
											constructor, err = itemBuf.ReadByte()
											if err != nil {
												return errors.Wrap(err, "unmarshal field properties failed")
											}
											var map9 *types.Struct
											err = unmarshalMap(&map9, constructor, itemBuf)
											if err != nil {
												return errors.Wrap(err, "unmarshal field properties failed")
											}
											t.Properties = (*Fields)(map9)
											done = 10

										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	BeginName       = "amqp:begin:list"
	BeginDescriptor = 0x0000000000000011
)

type Begin struct {
	FrameMeta
	RemoteChannel       uint16
	NextOutgoingID      TransferNumber
	IncomingWindow      uint32
	OutgoingWindow      uint32
	HandleMax           Handle
	OfferedCapabilities []string
	DesiredCapabilities []string
	Properties          *Fields
}

func (*Begin) isAMQPFrame() {}

func (t *Begin) GetFrameMeta() *FrameMeta {
	return &t.FrameMeta
}

func (t *Begin) Descriptor() uint64 {
	return BeginDescriptor
}

func (t *Begin) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Begin) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(BeginDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	count = 1 // remote-channel precedes mandatory field(s), must be always present
	count = 2 // next-outgoing-id is mandatory
	count = 3 // incoming-window is mandatory
	count = 4 // outgoing-window is mandatory
	if t.HandleMax != 0 {
		count = 5
	}
	if len(t.OfferedCapabilities) > 0 {
		count = 6
	}
	if len(t.DesiredCapabilities) > 0 {
		count = 7
	}
	if t.Properties != nil {
		count = 8
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			if t.RemoteChannel != RemoteChannelNull {
				err = marshalUshort(t.RemoteChannel, &itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field remote-channel failed")
				}
			} else {
				err = marshalNull(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field remote-channel failed")
				}
			}
			if count > 1 {
				err = t.NextOutgoingID.MarshalBuffer(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field next-outgoing-id failed")
				}

				if count > 2 {
					err = marshalUint(t.IncomingWindow, &itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field incoming-window failed")
					}

					if count > 3 {
						err = marshalUint(t.OutgoingWindow, &itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field outgoing-window failed")
						}

						if count > 4 {
							if t.HandleMax != 0 {
								err = t.HandleMax.MarshalBuffer(&itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field handle-max failed")
								}
							} else {
								err = marshalNull(&itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field handle-max failed")
								}
							}
							if count > 5 {
								if len(t.OfferedCapabilities) > 0 {
									err = marshalSymbolArray(t.OfferedCapabilities, &itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field offered-capabilities failed")
									}

								} else {
									err = marshalNull(&itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field offered-capabilities failed")
									}
								}
								if count > 6 {
									if len(t.DesiredCapabilities) > 0 {
										err = marshalSymbolArray(t.DesiredCapabilities, &itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field desired-capabilities failed")
										}

									} else {
										err = marshalNull(&itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field desired-capabilities failed")
										}
									}
									if count > 7 {
										if t.Properties != nil {
											err = t.Properties.MarshalBuffer(&itemBuf)
											if err != nil {
												return errors.Wrap(err, "marshal field properties failed")
											}
										} else {
											err = marshalNull(&itemBuf)
											if err != nil {
												return errors.Wrap(err, "marshal field properties failed")
											}
										}

									}
								}
							}
						}
					}
				}
			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Begin) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Begin) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != BeginDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal begin failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		constructor, err = itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "unmarshal field remote-channel failed")
		}
		err = unmarshalUshort(&t.RemoteChannel, constructor, itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field remote-channel failed")
		}
		done = 1
		if count > 1 {
			err = t.NextOutgoingID.UnmarshalBuffer(itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field next-outgoing-id failed")
			}
			done = 2
			if count > 2 {
				constructor, err = itemBuf.ReadByte()
				if err != nil {
					return errors.Wrap(err, "unmarshal field incoming-window failed")
				}
				err = unmarshalUint(&t.IncomingWindow, constructor, itemBuf)
				if err != nil {
					return errors.Wrap(err, "unmarshal field incoming-window failed")
				}
				done = 3
				if count > 3 {
					constructor, err = itemBuf.ReadByte()
					if err != nil {
						return errors.Wrap(err, "unmarshal field outgoing-window failed")
					}
					err = unmarshalUint(&t.OutgoingWindow, constructor, itemBuf)
					if err != nil {
						return errors.Wrap(err, "unmarshal field outgoing-window failed")
					}
					done = 4
					if count > 4 {
						err = t.HandleMax.UnmarshalBuffer(itemBuf)
						if err != nil {
							return errors.Wrap(err, "unmarshal field handle-max failed")
						}
						done = 5
						if count > 5 {
							constructor, err = itemBuf.ReadByte()
							if err != nil {
								return errors.Wrap(err, "unmarshal field offered-capabilities failed")
							}
							err = unmarshalSymbolArray(&t.OfferedCapabilities, constructor, itemBuf)
							if err != nil {
								return errors.Wrap(err, "unmarshal field offered-capabilities failed")
							}

							done = 6
							if count > 6 {
								constructor, err = itemBuf.ReadByte()
								if err != nil {
									return errors.Wrap(err, "unmarshal field desired-capabilities failed")
								}
								err = unmarshalSymbolArray(&t.DesiredCapabilities, constructor, itemBuf)
								if err != nil {
									return errors.Wrap(err, "unmarshal field desired-capabilities failed")
								}

								done = 7
								if count > 7 {
									constructor, err = itemBuf.ReadByte()
									if err != nil {
										return errors.Wrap(err, "unmarshal field properties failed")
									}
									var map7 *types.Struct
									err = unmarshalMap(&map7, constructor, itemBuf)
									if err != nil {
										return errors.Wrap(err, "unmarshal field properties failed")
									}
									t.Properties = (*Fields)(map7)
									done = 8

								}
							}
						}
					}
				}
			}
		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	AttachName       = "amqp:attach:list"
	AttachDescriptor = 0x0000000000000012
)

type Attach struct {
	FrameMeta
	Name                 string
	Handle               Handle
	Role                 Role
	SndSettleMode        SenderSettleMode
	RcvSettleMode        ReceiverSettleMode
	Source               *Source
	Target               *Target
	Unsettled            *types.Struct
	IncompleteUnsettled  bool
	InitialDeliveryCount SequenceNo
	MaxMessageSize       uint64
	OfferedCapabilities  []string
	DesiredCapabilities  []string
	Properties           *Fields
}

func (*Attach) isAMQPFrame() {}

func (t *Attach) GetFrameMeta() *FrameMeta {
	return &t.FrameMeta
}

func (t *Attach) Descriptor() uint64 {
	return AttachDescriptor
}

func (t *Attach) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Attach) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(AttachDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	count = 1 // name is mandatory
	count = 2 // handle is mandatory
	count = 3 // role is mandatory
	if t.SndSettleMode != 0 {
		count = 4
	}
	if t.RcvSettleMode != 0 {
		count = 5
	}
	if t.Source != nil {
		count = 6
	}
	if t.Target != nil {
		count = 7
	}
	if t.Unsettled != nil {
		count = 8
	}
	if t.IncompleteUnsettled != false {
		count = 9
	}
	if t.InitialDeliveryCount != 0 {
		count = 10
	}
	if t.MaxMessageSize != 0 {
		count = 11
	}
	if len(t.OfferedCapabilities) > 0 {
		count = 12
	}
	if len(t.DesiredCapabilities) > 0 {
		count = 13
	}
	if t.Properties != nil {
		count = 14
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			err = marshalString(t.Name, &itemBuf)
			if err != nil {
				return errors.Wrap(err, "marshal field name failed")
			}

			if count > 1 {
				err = t.Handle.MarshalBuffer(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field handle failed")
				}

				if count > 2 {
					err = t.Role.MarshalBuffer(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field role failed")
					}

					if count > 3 {
						if t.SndSettleMode != 0 {
							err = t.SndSettleMode.MarshalBuffer(&itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field snd-settle-mode failed")
							}
						} else {
							err = marshalNull(&itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field snd-settle-mode failed")
							}
						}
						if count > 4 {
							if t.RcvSettleMode != 0 {
								err = t.RcvSettleMode.MarshalBuffer(&itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field rcv-settle-mode failed")
								}
							} else {
								err = marshalNull(&itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field rcv-settle-mode failed")
								}
							}
							if count > 5 {
								if t.Source != nil {
									err = t.Source.MarshalBuffer(&itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field source failed")
									}
								} else {
									err = marshalNull(&itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field source failed")
									}
								}
								if count > 6 {
									if t.Target != nil {
										err = t.Target.MarshalBuffer(&itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field target failed")
										}
									} else {
										err = marshalNull(&itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field target failed")
										}
									}
									if count > 7 {
										if t.Unsettled != nil {
											err = marshalMap(t.Unsettled, &itemBuf)
											if err != nil {
												return errors.Wrap(err, "marshal field unsettled failed")
											}
										} else {
											err = marshalNull(&itemBuf)
											if err != nil {
												return errors.Wrap(err, "marshal field unsettled failed")
											}
										}
										if count > 8 {
											if t.IncompleteUnsettled != false {
												err = marshalBoolean(t.IncompleteUnsettled, &itemBuf)
												if err != nil {
													return errors.Wrap(err, "marshal field incomplete-unsettled failed")
												}
											} else {
												err = marshalNull(&itemBuf)
												if err != nil {
													return errors.Wrap(err, "marshal field incomplete-unsettled failed")
												}
											}
											if count > 9 {
												if t.InitialDeliveryCount != 0 {
													err = t.InitialDeliveryCount.MarshalBuffer(&itemBuf)
													if err != nil {
														return errors.Wrap(err, "marshal field initial-delivery-count failed")
													}
												} else {
													err = marshalNull(&itemBuf)
													if err != nil {
														return errors.Wrap(err, "marshal field initial-delivery-count failed")
													}
												}
												if count > 10 {
													if t.MaxMessageSize != 0 {
														err = marshalUlong(t.MaxMessageSize, &itemBuf)
														if err != nil {
															return errors.Wrap(err, "marshal field max-message-size failed")
														}
													} else {
														err = marshalNull(&itemBuf)
														if err != nil {
															return errors.Wrap(err, "marshal field max-message-size failed")
														}
													}
													if count > 11 {
														if len(t.OfferedCapabilities) > 0 {
															err = marshalSymbolArray(t.OfferedCapabilities, &itemBuf)
															if err != nil {
																return errors.Wrap(err, "marshal field offered-capabilities failed")
															}

														} else {
															err = marshalNull(&itemBuf)
															if err != nil {
																return errors.Wrap(err, "marshal field offered-capabilities failed")
															}
														}
														if count > 12 {
															if len(t.DesiredCapabilities) > 0 {
																err = marshalSymbolArray(t.DesiredCapabilities, &itemBuf)
																if err != nil {
																	return errors.Wrap(err, "marshal field desired-capabilities failed")
																}

															} else {
																err = marshalNull(&itemBuf)
																if err != nil {
																	return errors.Wrap(err, "marshal field desired-capabilities failed")
																}
															}
															if count > 13 {
																if t.Properties != nil {
																	err = t.Properties.MarshalBuffer(&itemBuf)
																	if err != nil {
																		return errors.Wrap(err, "marshal field properties failed")
																	}
																} else {
																	err = marshalNull(&itemBuf)
																	if err != nil {
																		return errors.Wrap(err, "marshal field properties failed")
																	}
																}

															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Attach) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Attach) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != AttachDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal attach failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		constructor, err = itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "unmarshal field name failed")
		}
		err = unmarshalString(&t.Name, constructor, itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field name failed")
		}
		done = 1
		if count > 1 {
			err = t.Handle.UnmarshalBuffer(itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field handle failed")
			}
			done = 2
			if count > 2 {
				err = t.Role.UnmarshalBuffer(itemBuf)
				if err != nil {
					return errors.Wrap(err, "unmarshal field role failed")
				}
				done = 3
				if count > 3 {
					err = t.SndSettleMode.UnmarshalBuffer(itemBuf)
					if err != nil {
						return errors.Wrap(err, "unmarshal field snd-settle-mode failed")
					}
					done = 4
					if count > 4 {
						err = t.RcvSettleMode.UnmarshalBuffer(itemBuf)
						if err != nil {
							return errors.Wrap(err, "unmarshal field rcv-settle-mode failed")
						}
						done = 5
						if count > 5 {
							t.Source = &Source{}
							err = t.Source.UnmarshalBuffer(itemBuf)
							if err == errNull {
								t.Source = nil
							} else if err != nil {
								return errors.Wrap(err, "unmarshal field source failed")
							}
							done = 6
							if count > 6 {
								t.Target = &Target{}
								err = t.Target.UnmarshalBuffer(itemBuf)
								if err == errNull {
									t.Target = nil
								} else if err != nil {
									return errors.Wrap(err, "unmarshal field target failed")
								}
								done = 7
								if count > 7 {
									constructor, err = itemBuf.ReadByte()
									if err != nil {
										return errors.Wrap(err, "unmarshal field unsettled failed")
									}
									var map7 *types.Struct
									err = unmarshalMap(&map7, constructor, itemBuf)
									if err != nil {
										return errors.Wrap(err, "unmarshal field unsettled failed")
									}
									t.Unsettled = (*types.Struct)(map7)
									done = 8
									if count > 8 {
										constructor, err = itemBuf.ReadByte()
										if err != nil {
											return errors.Wrap(err, "unmarshal field incomplete-unsettled failed")
										}
										err = unmarshalBoolean(&t.IncompleteUnsettled, constructor, itemBuf)
										if err != nil {
											return errors.Wrap(err, "unmarshal field incomplete-unsettled failed")
										}
										done = 9
										if count > 9 {
											err = t.InitialDeliveryCount.UnmarshalBuffer(itemBuf)
											if err != nil {
												return errors.Wrap(err, "unmarshal field initial-delivery-count failed")
											}
											done = 10
											if count > 10 {
												constructor, err = itemBuf.ReadByte()
												if err != nil {
													return errors.Wrap(err, "unmarshal field max-message-size failed")
												}
												err = unmarshalUlong(&t.MaxMessageSize, constructor, itemBuf)
												if err != nil {
													return errors.Wrap(err, "unmarshal field max-message-size failed")
												}
												done = 11
												if count > 11 {
													constructor, err = itemBuf.ReadByte()
													if err != nil {
														return errors.Wrap(err, "unmarshal field offered-capabilities failed")
													}
													err = unmarshalSymbolArray(&t.OfferedCapabilities, constructor, itemBuf)
													if err != nil {
														return errors.Wrap(err, "unmarshal field offered-capabilities failed")
													}

													done = 12
													if count > 12 {
														constructor, err = itemBuf.ReadByte()
														if err != nil {
															return errors.Wrap(err, "unmarshal field desired-capabilities failed")
														}
														err = unmarshalSymbolArray(&t.DesiredCapabilities, constructor, itemBuf)
														if err != nil {
															return errors.Wrap(err, "unmarshal field desired-capabilities failed")
														}

														done = 13
														if count > 13 {
															constructor, err = itemBuf.ReadByte()
															if err != nil {
																return errors.Wrap(err, "unmarshal field properties failed")
															}
															var map13 *types.Struct
															err = unmarshalMap(&map13, constructor, itemBuf)
															if err != nil {
																return errors.Wrap(err, "unmarshal field properties failed")
															}
															t.Properties = (*Fields)(map13)
															done = 14

														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	FlowName       = "amqp:flow:list"
	FlowDescriptor = 0x0000000000000013
)

type Flow struct {
	FrameMeta
	NextIncomingID TransferNumber
	IncomingWindow uint32
	NextOutgoingID TransferNumber
	OutgoingWindow uint32
	Handle         Handle
	DeliveryCount  SequenceNo
	LinkCredit     uint32
	Available      uint32
	Drain          bool
	Echo           bool
	Properties     *Fields
}

func (*Flow) isAMQPFrame() {}

func (t *Flow) GetFrameMeta() *FrameMeta {
	return &t.FrameMeta
}

func (t *Flow) Descriptor() uint64 {
	return FlowDescriptor
}

func (t *Flow) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Flow) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(FlowDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	count = 1 // next-incoming-id precedes mandatory field(s), must be always present
	count = 2 // incoming-window is mandatory
	count = 3 // next-outgoing-id is mandatory
	count = 4 // outgoing-window is mandatory
	if t.Handle != 0 {
		count = 5
	}
	if t.DeliveryCount != 0 {
		count = 6
	}
	if t.LinkCredit != 0 {
		count = 7
	}
	if t.Available != 0 {
		count = 8
	}
	if t.Drain != false {
		count = 9
	}
	if t.Echo != false {
		count = 10
	}
	if t.Properties != nil {
		count = 11
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			if t.NextIncomingID != 0 {
				err = t.NextIncomingID.MarshalBuffer(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field next-incoming-id failed")
				}
			} else {
				err = marshalNull(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field next-incoming-id failed")
				}
			}
			if count > 1 {
				err = marshalUint(t.IncomingWindow, &itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field incoming-window failed")
				}

				if count > 2 {
					err = t.NextOutgoingID.MarshalBuffer(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field next-outgoing-id failed")
					}

					if count > 3 {
						err = marshalUint(t.OutgoingWindow, &itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field outgoing-window failed")
						}

						if count > 4 {
							if t.Handle != 0 {
								err = t.Handle.MarshalBuffer(&itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field handle failed")
								}
							} else {
								err = marshalNull(&itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field handle failed")
								}
							}
							if count > 5 {
								if t.DeliveryCount != 0 {
									err = t.DeliveryCount.MarshalBuffer(&itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field delivery-count failed")
									}
								} else {
									err = marshalNull(&itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field delivery-count failed")
									}
								}
								if count > 6 {
									if t.LinkCredit != 0 {
										err = marshalUint(t.LinkCredit, &itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field link-credit failed")
										}
									} else {
										err = marshalNull(&itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field link-credit failed")
										}
									}
									if count > 7 {
										if t.Available != 0 {
											err = marshalUint(t.Available, &itemBuf)
											if err != nil {
												return errors.Wrap(err, "marshal field available failed")
											}
										} else {
											err = marshalNull(&itemBuf)
											if err != nil {
												return errors.Wrap(err, "marshal field available failed")
											}
										}
										if count > 8 {
											if t.Drain != false {
												err = marshalBoolean(t.Drain, &itemBuf)
												if err != nil {
													return errors.Wrap(err, "marshal field drain failed")
												}
											} else {
												err = marshalNull(&itemBuf)
												if err != nil {
													return errors.Wrap(err, "marshal field drain failed")
												}
											}
											if count > 9 {
												if t.Echo != false {
													err = marshalBoolean(t.Echo, &itemBuf)
													if err != nil {
														return errors.Wrap(err, "marshal field echo failed")
													}
												} else {
													err = marshalNull(&itemBuf)
													if err != nil {
														return errors.Wrap(err, "marshal field echo failed")
													}
												}
												if count > 10 {
													if t.Properties != nil {
														err = t.Properties.MarshalBuffer(&itemBuf)
														if err != nil {
															return errors.Wrap(err, "marshal field properties failed")
														}
													} else {
														err = marshalNull(&itemBuf)
														if err != nil {
															return errors.Wrap(err, "marshal field properties failed")
														}
													}

												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Flow) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Flow) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != FlowDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal flow failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		err = t.NextIncomingID.UnmarshalBuffer(itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field next-incoming-id failed")
		}
		done = 1
		if count > 1 {
			constructor, err = itemBuf.ReadByte()
			if err != nil {
				return errors.Wrap(err, "unmarshal field incoming-window failed")
			}
			err = unmarshalUint(&t.IncomingWindow, constructor, itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field incoming-window failed")
			}
			done = 2
			if count > 2 {
				err = t.NextOutgoingID.UnmarshalBuffer(itemBuf)
				if err != nil {
					return errors.Wrap(err, "unmarshal field next-outgoing-id failed")
				}
				done = 3
				if count > 3 {
					constructor, err = itemBuf.ReadByte()
					if err != nil {
						return errors.Wrap(err, "unmarshal field outgoing-window failed")
					}
					err = unmarshalUint(&t.OutgoingWindow, constructor, itemBuf)
					if err != nil {
						return errors.Wrap(err, "unmarshal field outgoing-window failed")
					}
					done = 4
					if count > 4 {
						err = t.Handle.UnmarshalBuffer(itemBuf)
						if err != nil {
							return errors.Wrap(err, "unmarshal field handle failed")
						}
						done = 5
						if count > 5 {
							err = t.DeliveryCount.UnmarshalBuffer(itemBuf)
							if err != nil {
								return errors.Wrap(err, "unmarshal field delivery-count failed")
							}
							done = 6
							if count > 6 {
								constructor, err = itemBuf.ReadByte()
								if err != nil {
									return errors.Wrap(err, "unmarshal field link-credit failed")
								}
								err = unmarshalUint(&t.LinkCredit, constructor, itemBuf)
								if err != nil {
									return errors.Wrap(err, "unmarshal field link-credit failed")
								}
								done = 7
								if count > 7 {
									constructor, err = itemBuf.ReadByte()
									if err != nil {
										return errors.Wrap(err, "unmarshal field available failed")
									}
									err = unmarshalUint(&t.Available, constructor, itemBuf)
									if err != nil {
										return errors.Wrap(err, "unmarshal field available failed")
									}
									done = 8
									if count > 8 {
										constructor, err = itemBuf.ReadByte()
										if err != nil {
											return errors.Wrap(err, "unmarshal field drain failed")
										}
										err = unmarshalBoolean(&t.Drain, constructor, itemBuf)
										if err != nil {
											return errors.Wrap(err, "unmarshal field drain failed")
										}
										done = 9
										if count > 9 {
											constructor, err = itemBuf.ReadByte()
											if err != nil {
												return errors.Wrap(err, "unmarshal field echo failed")
											}
											err = unmarshalBoolean(&t.Echo, constructor, itemBuf)
											if err != nil {
												return errors.Wrap(err, "unmarshal field echo failed")
											}
											done = 10
											if count > 10 {
												constructor, err = itemBuf.ReadByte()
												if err != nil {
													return errors.Wrap(err, "unmarshal field properties failed")
												}
												var map10 *types.Struct
												err = unmarshalMap(&map10, constructor, itemBuf)
												if err != nil {
													return errors.Wrap(err, "unmarshal field properties failed")
												}
												t.Properties = (*Fields)(map10)
												done = 11

											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	TransferName       = "amqp:transfer:list"
	TransferDescriptor = 0x0000000000000014
)

type Transfer struct {
	FrameMeta
	Handle        Handle
	DeliveryID    DeliveryNumber
	DeliveryTag   DeliveryTag
	MessageFormat MessageFormat
	Settled       bool
	More          bool
	RcvSettleMode ReceiverSettleMode
	State         DeliveryState
	Resume        bool
	Aborted       bool
	Batchable     bool
}

func (*Transfer) isAMQPFrame() {}

func (t *Transfer) GetFrameMeta() *FrameMeta {
	return &t.FrameMeta
}

func (t *Transfer) Descriptor() uint64 {
	return TransferDescriptor
}

func (t *Transfer) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Transfer) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(TransferDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	count = 1 // handle is mandatory
	if t.DeliveryID != 0 {
		count = 2
	}
	if t.DeliveryTag != nil {
		count = 3
	}
	if t.MessageFormat != 0 {
		count = 4
	}
	if t.Settled != false {
		count = 5
	}
	if t.More != false {
		count = 6
	}
	if t.RcvSettleMode != 0 {
		count = 7
	}
	if t.State != nil {
		count = 8
	}
	if t.Resume != false {
		count = 9
	}
	if t.Aborted != false {
		count = 10
	}
	if t.Batchable != false {
		count = 11
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			err = t.Handle.MarshalBuffer(&itemBuf)
			if err != nil {
				return errors.Wrap(err, "marshal field handle failed")
			}

			if count > 1 {
				if t.DeliveryID != 0 {
					err = t.DeliveryID.MarshalBuffer(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field delivery-id failed")
					}
				} else {
					err = marshalNull(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field delivery-id failed")
					}
				}
				if count > 2 {
					if t.DeliveryTag != nil {
						err = t.DeliveryTag.MarshalBuffer(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field delivery-tag failed")
						}
					} else {
						err = marshalNull(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field delivery-tag failed")
						}
					}
					if count > 3 {
						if t.MessageFormat != 0 {
							err = t.MessageFormat.MarshalBuffer(&itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field message-format failed")
							}
						} else {
							err = marshalNull(&itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field message-format failed")
							}
						}
						if count > 4 {
							if t.Settled != false {
								err = marshalBoolean(t.Settled, &itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field settled failed")
								}
							} else {
								err = marshalNull(&itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field settled failed")
								}
							}
							if count > 5 {
								if t.More != false {
									err = marshalBoolean(t.More, &itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field more failed")
									}
								} else {
									err = marshalNull(&itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field more failed")
									}
								}
								if count > 6 {
									if t.RcvSettleMode != 0 {
										err = t.RcvSettleMode.MarshalBuffer(&itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field rcv-settle-mode failed")
										}
									} else {
										err = marshalNull(&itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field rcv-settle-mode failed")
										}
									}
									if count > 7 {
										if t.State != nil {
											err = marshalDeliveryStateUnion(t.State, &itemBuf)
											if err != nil {
												return errors.Wrap(err, "marshal field state failed")
											}
										} else {
											err = marshalNull(&itemBuf)
											if err != nil {
												return errors.Wrap(err, "marshal field state failed")
											}
										}
										if count > 8 {
											if t.Resume != false {
												err = marshalBoolean(t.Resume, &itemBuf)
												if err != nil {
													return errors.Wrap(err, "marshal field resume failed")
												}
											} else {
												err = marshalNull(&itemBuf)
												if err != nil {
													return errors.Wrap(err, "marshal field resume failed")
												}
											}
											if count > 9 {
												if t.Aborted != false {
													err = marshalBoolean(t.Aborted, &itemBuf)
													if err != nil {
														return errors.Wrap(err, "marshal field aborted failed")
													}
												} else {
													err = marshalNull(&itemBuf)
													if err != nil {
														return errors.Wrap(err, "marshal field aborted failed")
													}
												}
												if count > 10 {
													if t.Batchable != false {
														err = marshalBoolean(t.Batchable, &itemBuf)
														if err != nil {
															return errors.Wrap(err, "marshal field batchable failed")
														}
													} else {
														err = marshalNull(&itemBuf)
														if err != nil {
															return errors.Wrap(err, "marshal field batchable failed")
														}
													}

												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Transfer) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Transfer) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != TransferDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal transfer failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		err = t.Handle.UnmarshalBuffer(itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field handle failed")
		}
		done = 1
		if count > 1 {
			err = t.DeliveryID.UnmarshalBuffer(itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field delivery-id failed")
			}
			done = 2
			if count > 2 {
				err = t.DeliveryTag.UnmarshalBuffer(itemBuf)
				if err != nil {
					return errors.Wrap(err, "unmarshal field delivery-tag failed")
				}
				done = 3
				if count > 3 {
					err = t.MessageFormat.UnmarshalBuffer(itemBuf)
					if err != nil {
						return errors.Wrap(err, "unmarshal field message-format failed")
					}
					done = 4
					if count > 4 {
						constructor, err = itemBuf.ReadByte()
						if err != nil {
							return errors.Wrap(err, "unmarshal field settled failed")
						}
						err = unmarshalBoolean(&t.Settled, constructor, itemBuf)
						if err != nil {
							return errors.Wrap(err, "unmarshal field settled failed")
						}
						done = 5
						if count > 5 {
							constructor, err = itemBuf.ReadByte()
							if err != nil {
								return errors.Wrap(err, "unmarshal field more failed")
							}
							err = unmarshalBoolean(&t.More, constructor, itemBuf)
							if err != nil {
								return errors.Wrap(err, "unmarshal field more failed")
							}
							done = 6
							if count > 6 {
								err = t.RcvSettleMode.UnmarshalBuffer(itemBuf)
								if err != nil {
									return errors.Wrap(err, "unmarshal field rcv-settle-mode failed")
								}
								done = 7
								if count > 7 {
									err = unmarshalDeliveryStateUnion(&t.State, itemBuf)
									if err != nil {
										return errors.Wrap(err, "unmarshal field state failed")
									}
									done = 8
									if count > 8 {
										constructor, err = itemBuf.ReadByte()
										if err != nil {
											return errors.Wrap(err, "unmarshal field resume failed")
										}
										err = unmarshalBoolean(&t.Resume, constructor, itemBuf)
										if err != nil {
											return errors.Wrap(err, "unmarshal field resume failed")
										}
										done = 9
										if count > 9 {
											constructor, err = itemBuf.ReadByte()
											if err != nil {
												return errors.Wrap(err, "unmarshal field aborted failed")
											}
											err = unmarshalBoolean(&t.Aborted, constructor, itemBuf)
											if err != nil {
												return errors.Wrap(err, "unmarshal field aborted failed")
											}
											done = 10
											if count > 10 {
												constructor, err = itemBuf.ReadByte()
												if err != nil {
													return errors.Wrap(err, "unmarshal field batchable failed")
												}
												err = unmarshalBoolean(&t.Batchable, constructor, itemBuf)
												if err != nil {
													return errors.Wrap(err, "unmarshal field batchable failed")
												}
												done = 11

											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	DispositionName       = "amqp:disposition:list"
	DispositionDescriptor = 0x0000000000000015
)

type Disposition struct {
	FrameMeta
	Role      Role
	First     DeliveryNumber
	Last      DeliveryNumber
	Settled   bool
	State     DeliveryState
	Batchable bool
}

func (*Disposition) isAMQPFrame() {}

func (t *Disposition) GetFrameMeta() *FrameMeta {
	return &t.FrameMeta
}

func (t *Disposition) Descriptor() uint64 {
	return DispositionDescriptor
}

func (t *Disposition) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Disposition) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(DispositionDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	count = 1 // role is mandatory
	count = 2 // first is mandatory
	if t.Last != 0 {
		count = 3
	}
	if t.Settled != false {
		count = 4
	}
	if t.State != nil {
		count = 5
	}
	if t.Batchable != false {
		count = 6
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			err = t.Role.MarshalBuffer(&itemBuf)
			if err != nil {
				return errors.Wrap(err, "marshal field role failed")
			}

			if count > 1 {
				err = t.First.MarshalBuffer(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field first failed")
				}

				if count > 2 {
					if t.Last != 0 {
						err = t.Last.MarshalBuffer(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field last failed")
						}
					} else {
						err = marshalNull(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field last failed")
						}
					}
					if count > 3 {
						if t.Settled != false {
							err = marshalBoolean(t.Settled, &itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field settled failed")
							}
						} else {
							err = marshalNull(&itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field settled failed")
							}
						}
						if count > 4 {
							if t.State != nil {
								err = marshalDeliveryStateUnion(t.State, &itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field state failed")
								}
							} else {
								err = marshalNull(&itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field state failed")
								}
							}
							if count > 5 {
								if t.Batchable != false {
									err = marshalBoolean(t.Batchable, &itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field batchable failed")
									}
								} else {
									err = marshalNull(&itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field batchable failed")
									}
								}

							}
						}
					}
				}
			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Disposition) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Disposition) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != DispositionDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal disposition failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		err = t.Role.UnmarshalBuffer(itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field role failed")
		}
		done = 1
		if count > 1 {
			err = t.First.UnmarshalBuffer(itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field first failed")
			}
			done = 2
			if count > 2 {
				err = t.Last.UnmarshalBuffer(itemBuf)
				if err != nil {
					return errors.Wrap(err, "unmarshal field last failed")
				}
				done = 3
				if count > 3 {
					constructor, err = itemBuf.ReadByte()
					if err != nil {
						return errors.Wrap(err, "unmarshal field settled failed")
					}
					err = unmarshalBoolean(&t.Settled, constructor, itemBuf)
					if err != nil {
						return errors.Wrap(err, "unmarshal field settled failed")
					}
					done = 4
					if count > 4 {
						err = unmarshalDeliveryStateUnion(&t.State, itemBuf)
						if err != nil {
							return errors.Wrap(err, "unmarshal field state failed")
						}
						done = 5
						if count > 5 {
							constructor, err = itemBuf.ReadByte()
							if err != nil {
								return errors.Wrap(err, "unmarshal field batchable failed")
							}
							err = unmarshalBoolean(&t.Batchable, constructor, itemBuf)
							if err != nil {
								return errors.Wrap(err, "unmarshal field batchable failed")
							}
							done = 6

						}
					}
				}
			}
		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	DetachName       = "amqp:detach:list"
	DetachDescriptor = 0x0000000000000016
)

type Detach struct {
	FrameMeta
	Handle Handle
	Closed bool
	Error  *Error
}

func (*Detach) isAMQPFrame() {}

func (t *Detach) GetFrameMeta() *FrameMeta {
	return &t.FrameMeta
}

func (t *Detach) Descriptor() uint64 {
	return DetachDescriptor
}

func (t *Detach) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Detach) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(DetachDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	count = 1 // handle is mandatory
	if t.Closed != false {
		count = 2
	}
	if t.Error != nil {
		count = 3
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			err = t.Handle.MarshalBuffer(&itemBuf)
			if err != nil {
				return errors.Wrap(err, "marshal field handle failed")
			}

			if count > 1 {
				if t.Closed != false {
					err = marshalBoolean(t.Closed, &itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field closed failed")
					}
				} else {
					err = marshalNull(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field closed failed")
					}
				}
				if count > 2 {
					if t.Error != nil {
						err = t.Error.MarshalBuffer(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field error failed")
						}
					} else {
						err = marshalNull(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field error failed")
						}
					}

				}
			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Detach) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Detach) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != DetachDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal detach failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		err = t.Handle.UnmarshalBuffer(itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field handle failed")
		}
		done = 1
		if count > 1 {
			constructor, err = itemBuf.ReadByte()
			if err != nil {
				return errors.Wrap(err, "unmarshal field closed failed")
			}
			err = unmarshalBoolean(&t.Closed, constructor, itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field closed failed")
			}
			done = 2
			if count > 2 {
				t.Error = &Error{}
				err = t.Error.UnmarshalBuffer(itemBuf)
				if err == errNull {
					t.Error = nil
				} else if err != nil {
					return errors.Wrap(err, "unmarshal field error failed")
				}
				done = 3

			}
		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	EndName       = "amqp:end:list"
	EndDescriptor = 0x0000000000000017
)

type End struct {
	FrameMeta
	Error *Error
}

func (*End) isAMQPFrame() {}

func (t *End) GetFrameMeta() *FrameMeta {
	return &t.FrameMeta
}

func (t *End) Descriptor() uint64 {
	return EndDescriptor
}

func (t *End) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *End) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(EndDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	if t.Error != nil {
		count = 1
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			if t.Error != nil {
				err = t.Error.MarshalBuffer(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field error failed")
				}
			} else {
				err = marshalNull(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field error failed")
				}
			}

		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *End) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *End) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != EndDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal end failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		t.Error = &Error{}
		err = t.Error.UnmarshalBuffer(itemBuf)
		if err == errNull {
			t.Error = nil
		} else if err != nil {
			return errors.Wrap(err, "unmarshal field error failed")
		}
		done = 1

	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	CloseName       = "amqp:close:list"
	CloseDescriptor = 0x0000000000000018
)

type Close struct {
	FrameMeta
	Error *Error
}

func (*Close) isAMQPFrame() {}

func (t *Close) GetFrameMeta() *FrameMeta {
	return &t.FrameMeta
}

func (t *Close) Descriptor() uint64 {
	return CloseDescriptor
}

func (t *Close) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Close) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(CloseDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	if t.Error != nil {
		count = 1
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			if t.Error != nil {
				err = t.Error.MarshalBuffer(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field error failed")
				}
			} else {
				err = marshalNull(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field error failed")
				}
			}

		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Close) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Close) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != CloseDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal close failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		t.Error = &Error{}
		err = t.Error.UnmarshalBuffer(itemBuf)
		if err == errNull {
			t.Error = nil
		} else if err != nil {
			return errors.Wrap(err, "unmarshal field error failed")
		}
		done = 1

	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	Port            = 5672
	SecurePort      = 5671
	Major           = 1
	Minor           = 0
	Revision        = 0
	MinMaxFrameSize = 512
)

type Role bool

const (
	SenderRole   Role = false
	ReceiverRole Role = true
)

func (t Role) String() string {
	switch t {
	case SenderRole:
		return "sender"
	case ReceiverRole:
		return "receiver"
	default:
		return "<invalid>"
	}
}

func (t Role) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t Role) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalBoolean(bool(t), buf)
}

func (t *Role) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Role) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalBoolean((*bool)(t), constructor, buf)
}

type SenderSettleMode uint8

const (
	UnsettledSenderSettleMode SenderSettleMode = 0
	SettledSenderSettleMode   SenderSettleMode = 1
	MixedSenderSettleMode     SenderSettleMode = 2
)

func (t SenderSettleMode) String() string {
	switch t {
	case UnsettledSenderSettleMode:
		return "unsettled"
	case SettledSenderSettleMode:
		return "settled"
	case MixedSenderSettleMode:
		return "mixed"
	default:
		return "<invalid>"
	}
}

func (t SenderSettleMode) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t SenderSettleMode) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalUbyte(uint8(t), buf)
}

func (t *SenderSettleMode) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *SenderSettleMode) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalUbyte((*uint8)(t), constructor, buf)
}

type ReceiverSettleMode uint8

const (
	FirstReceiverSettleMode  ReceiverSettleMode = 0
	SecondReceiverSettleMode ReceiverSettleMode = 1
)

func (t ReceiverSettleMode) String() string {
	switch t {
	case FirstReceiverSettleMode:
		return "first"
	case SecondReceiverSettleMode:
		return "second"
	default:
		return "<invalid>"
	}
}

func (t ReceiverSettleMode) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t ReceiverSettleMode) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalUbyte(uint8(t), buf)
}

func (t *ReceiverSettleMode) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *ReceiverSettleMode) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalUbyte((*uint8)(t), constructor, buf)
}

type Handle uint32

func (t Handle) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t Handle) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalUint(uint32(t), buf)
}

func (t *Handle) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Handle) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalUint((*uint32)(t), constructor, buf)
}

type Seconds uint32

func (t Seconds) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t Seconds) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalUint(uint32(t), buf)
}

func (t *Seconds) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Seconds) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalUint((*uint32)(t), constructor, buf)
}

type Milliseconds uint32

func (t Milliseconds) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t Milliseconds) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalUint(uint32(t), buf)
}

func (t *Milliseconds) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Milliseconds) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalUint((*uint32)(t), constructor, buf)
}

type DeliveryTag []byte

func (t DeliveryTag) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t DeliveryTag) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalBinary([]byte(t), buf)
}

func (t *DeliveryTag) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *DeliveryTag) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalBinary((*[]byte)(t), constructor, buf)
}

type DeliveryNumber uint32

func (t DeliveryNumber) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t DeliveryNumber) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalUint(uint32(t), buf)
}

func (t *DeliveryNumber) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *DeliveryNumber) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalUint((*uint32)(t), constructor, buf)
}

type TransferNumber uint32

func (t TransferNumber) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t TransferNumber) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalUint(uint32(t), buf)
}

func (t *TransferNumber) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *TransferNumber) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalUint((*uint32)(t), constructor, buf)
}

type SequenceNo uint32

func (t SequenceNo) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t SequenceNo) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalUint(uint32(t), buf)
}

func (t *SequenceNo) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *SequenceNo) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalUint((*uint32)(t), constructor, buf)
}

type MessageFormat uint32

func (t MessageFormat) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t MessageFormat) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalUint(uint32(t), buf)
}

func (t *MessageFormat) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *MessageFormat) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalUint((*uint32)(t), constructor, buf)
}

type IETFLanguageTag string

func (t IETFLanguageTag) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t IETFLanguageTag) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalSymbol(string(t), buf)
}

func (t *IETFLanguageTag) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *IETFLanguageTag) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalSymbol((*string)(t), constructor, buf)
}

type Fields types.Struct

func (t *Fields) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Fields) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalMap((*types.Struct)(t), buf)
}

func (t *Fields) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Fields) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}

	var m *types.Struct
	err = unmarshalMap(&m, constructor, buf)
	if err != nil {
		return err
	}

	*t = (Fields)(*m)
	return nil
}

const (
	ErrorName       = "amqp:error:list"
	ErrorDescriptor = 0x000000000000001d
)

type Error struct {
	Condition   string
	Description string
	Info        *Fields
}

func (t *Error) Descriptor() uint64 {
	return ErrorDescriptor
}

func (t *Error) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Error) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(ErrorDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	count = 1 // condition is mandatory
	if t.Description != "" {
		count = 2
	}
	if t.Info != nil {
		count = 3
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			err = marshalSymbol(t.Condition, &itemBuf)
			if err != nil {
				return errors.Wrap(err, "marshal field condition failed")
			}

			if count > 1 {
				if t.Description != "" {
					err = marshalString(t.Description, &itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field description failed")
					}
				} else {
					err = marshalNull(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field description failed")
					}
				}
				if count > 2 {
					if t.Info != nil {
						err = t.Info.MarshalBuffer(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field info failed")
						}
					} else {
						err = marshalNull(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field info failed")
						}
					}

				}
			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Error) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Error) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != ErrorDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal error failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		constructor, err = itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "unmarshal field condition failed")
		}
		err = unmarshalSymbol(&t.Condition, constructor, itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field condition failed")
		}
		done = 1
		if count > 1 {
			constructor, err = itemBuf.ReadByte()
			if err != nil {
				return errors.Wrap(err, "unmarshal field description failed")
			}
			err = unmarshalString(&t.Description, constructor, itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field description failed")
			}
			done = 2
			if count > 2 {
				constructor, err = itemBuf.ReadByte()
				if err != nil {
					return errors.Wrap(err, "unmarshal field info failed")
				}
				var map2 *types.Struct
				err = unmarshalMap(&map2, constructor, itemBuf)
				if err != nil {
					return errors.Wrap(err, "unmarshal field info failed")
				}
				t.Info = (*Fields)(map2)
				done = 3

			}
		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

type AMQPError string

const (
	InternalErrorAMQPError         AMQPError = "amqp:internal-error"
	NotFoundAMQPError              AMQPError = "amqp:not-found"
	UnauthorizedAccessAMQPError    AMQPError = "amqp:unauthorized-access"
	DecodeErrorAMQPError           AMQPError = "amqp:decode-error"
	ResourceLimitExceededAMQPError AMQPError = "amqp:resource-limit-exceeded"
	NotAllowedAMQPError            AMQPError = "amqp:not-allowed"
	InvalidFieldAMQPError          AMQPError = "amqp:invalid-field"
	NotImplementedAMQPError        AMQPError = "amqp:not-implemented"
	ResourceLockedAMQPError        AMQPError = "amqp:resource-locked"
	PreconditionFailedAMQPError    AMQPError = "amqp:precondition-failed"
	ResourceDeletedAMQPError       AMQPError = "amqp:resource-deleted"
	IllegalStateAMQPError          AMQPError = "amqp:illegal-state"
	FrameSizeTooSmallAMQPError     AMQPError = "amqp:frame-size-too-small"
)

func (t AMQPError) String() string {
	return string(t)
}

func (AMQPError) isErrorCondition() {}

func (t AMQPError) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t AMQPError) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalSymbol(string(t), buf)
}

func (t *AMQPError) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *AMQPError) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalSymbol((*string)(t), constructor, buf)
}

type ConnectionError string

const (
	ConnectionForcedConnectionError ConnectionError = "amqp:connection:forced"
	FramingErrorConnectionError     ConnectionError = "amqp:connection:framing-error"
	RedirectConnectionError         ConnectionError = "amqp:connection:redirect"
)

func (t ConnectionError) String() string {
	return string(t)
}

func (ConnectionError) isErrorCondition() {}

func (t ConnectionError) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t ConnectionError) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalSymbol(string(t), buf)
}

func (t *ConnectionError) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *ConnectionError) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalSymbol((*string)(t), constructor, buf)
}

type SessionError string

const (
	WindowViolationSessionError  SessionError = "amqp:session:window-violation"
	ErrantLinkSessionError       SessionError = "amqp:session:errant-link"
	HandleInUseSessionError      SessionError = "amqp:session:handle-in-use"
	UnattachedHandleSessionError SessionError = "amqp:session:unattached-handle"
)

func (t SessionError) String() string {
	return string(t)
}

func (SessionError) isErrorCondition() {}

func (t SessionError) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t SessionError) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalSymbol(string(t), buf)
}

func (t *SessionError) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *SessionError) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalSymbol((*string)(t), constructor, buf)
}

type LinkError string

const (
	DetachForcedLinkError          LinkError = "amqp:link:detach-forced"
	TransferLimitExceededLinkError LinkError = "amqp:link:transfer-limit-exceeded"
	MessageSizeExceededLinkError   LinkError = "amqp:link:message-size-exceeded"
	RedirectLinkError              LinkError = "amqp:link:redirect"
	StolenLinkError                LinkError = "amqp:link:stolen"
)

func (t LinkError) String() string {
	return string(t)
}

func (LinkError) isErrorCondition() {}

func (t LinkError) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t LinkError) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalSymbol(string(t), buf)
}

func (t *LinkError) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *LinkError) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalSymbol((*string)(t), constructor, buf)
}

const ()

const (
	HeaderName       = "amqp:header:list"
	HeaderDescriptor = 0x0000000000000070
)

type Header struct {
	Durable       bool
	Priority      uint8
	Ttl           Milliseconds
	FirstAcquirer bool
	DeliveryCount uint32
}

func (*Header) isSection() {}

func (t *Header) Descriptor() uint64 {
	return HeaderDescriptor
}

func (t *Header) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Header) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(HeaderDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	if t.Durable != false {
		count = 1
	}
	if t.Priority != 0 {
		count = 2
	}
	if t.Ttl != 0 {
		count = 3
	}
	if t.FirstAcquirer != false {
		count = 4
	}
	if t.DeliveryCount != 0 {
		count = 5
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			if t.Durable != false {
				err = marshalBoolean(t.Durable, &itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field durable failed")
				}
			} else {
				err = marshalNull(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field durable failed")
				}
			}
			if count > 1 {
				if t.Priority != 0 {
					err = marshalUbyte(t.Priority, &itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field priority failed")
					}
				} else {
					err = marshalNull(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field priority failed")
					}
				}
				if count > 2 {
					if t.Ttl != 0 {
						err = t.Ttl.MarshalBuffer(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field ttl failed")
						}
					} else {
						err = marshalNull(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field ttl failed")
						}
					}
					if count > 3 {
						if t.FirstAcquirer != false {
							err = marshalBoolean(t.FirstAcquirer, &itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field first-acquirer failed")
							}
						} else {
							err = marshalNull(&itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field first-acquirer failed")
							}
						}
						if count > 4 {
							if t.DeliveryCount != 0 {
								err = marshalUint(t.DeliveryCount, &itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field delivery-count failed")
								}
							} else {
								err = marshalNull(&itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field delivery-count failed")
								}
							}

						}
					}
				}
			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Header) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Header) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != HeaderDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal header failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		constructor, err = itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "unmarshal field durable failed")
		}
		err = unmarshalBoolean(&t.Durable, constructor, itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field durable failed")
		}
		done = 1
		if count > 1 {
			constructor, err = itemBuf.ReadByte()
			if err != nil {
				return errors.Wrap(err, "unmarshal field priority failed")
			}
			err = unmarshalUbyte(&t.Priority, constructor, itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field priority failed")
			}
			done = 2
			if count > 2 {
				err = t.Ttl.UnmarshalBuffer(itemBuf)
				if err != nil {
					return errors.Wrap(err, "unmarshal field ttl failed")
				}
				done = 3
				if count > 3 {
					constructor, err = itemBuf.ReadByte()
					if err != nil {
						return errors.Wrap(err, "unmarshal field first-acquirer failed")
					}
					err = unmarshalBoolean(&t.FirstAcquirer, constructor, itemBuf)
					if err != nil {
						return errors.Wrap(err, "unmarshal field first-acquirer failed")
					}
					done = 4
					if count > 4 {
						constructor, err = itemBuf.ReadByte()
						if err != nil {
							return errors.Wrap(err, "unmarshal field delivery-count failed")
						}
						err = unmarshalUint(&t.DeliveryCount, constructor, itemBuf)
						if err != nil {
							return errors.Wrap(err, "unmarshal field delivery-count failed")
						}
						done = 5

					}
				}
			}
		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	DeliveryAnnotationsName       = "amqp:delivery-annotations:map"
	DeliveryAnnotationsDescriptor = 0x0000000000000071
)

type DeliveryAnnotations types.Struct

func (DeliveryAnnotations) isSection() {}

func (t *DeliveryAnnotations) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *DeliveryAnnotations) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalMap((*types.Struct)(t), buf)
}

func (t *DeliveryAnnotations) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *DeliveryAnnotations) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}

	var m *types.Struct
	err = unmarshalMap(&m, constructor, buf)
	if err != nil {
		return err
	}

	*t = (DeliveryAnnotations)(*m)
	return nil
}

const (
	MessageAnnotationsName       = "amqp:message-annotations:map"
	MessageAnnotationsDescriptor = 0x0000000000000072
)

type MessageAnnotations types.Struct

func (MessageAnnotations) isSection() {}

func (t *MessageAnnotations) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *MessageAnnotations) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalMap((*types.Struct)(t), buf)
}

func (t *MessageAnnotations) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *MessageAnnotations) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}

	var m *types.Struct
	err = unmarshalMap(&m, constructor, buf)
	if err != nil {
		return err
	}

	*t = (MessageAnnotations)(*m)
	return nil
}

const (
	PropertiesName       = "amqp:properties:list"
	PropertiesDescriptor = 0x0000000000000073
)

type Properties struct {
	MessageID          MessageID
	UserID             []byte
	To                 Address
	Subject            string
	ReplyTo            Address
	CorrelationID      MessageID
	ContentType        string
	ContentEncoding    string
	AbsoluteExpiryTime time.Time
	CreationTime       time.Time
	GroupID            string
	GroupSequence      SequenceNo
	ReplyToGroupID     string
}

func (*Properties) isSection() {}

func (t *Properties) Descriptor() uint64 {
	return PropertiesDescriptor
}

func (t *Properties) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Properties) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(PropertiesDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	if t.MessageID != nil {
		count = 1
	}
	if t.UserID != nil {
		count = 2
	}
	if t.To != nil {
		count = 3
	}
	if t.Subject != "" {
		count = 4
	}
	if t.ReplyTo != nil {
		count = 5
	}
	if t.CorrelationID != nil {
		count = 6
	}
	if t.ContentType != "" {
		count = 7
	}
	if t.ContentEncoding != "" {
		count = 8
	}
	if !t.AbsoluteExpiryTime.IsZero() {
		count = 9
	}
	if !t.CreationTime.IsZero() {
		count = 10
	}
	if t.GroupID != "" {
		count = 11
	}
	if t.GroupSequence != 0 {
		count = 12
	}
	if t.ReplyToGroupID != "" {
		count = 13
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			if t.MessageID != nil {
				err = marshalMessageIDUnion(t.MessageID, &itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field message-id failed")
				}
			} else {
				err = marshalNull(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field message-id failed")
				}
			}
			if count > 1 {
				if t.UserID != nil {
					err = marshalBinary(t.UserID, &itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field user-id failed")
					}
				} else {
					err = marshalNull(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field user-id failed")
					}
				}
				if count > 2 {
					if t.To != nil {
						err = marshalAddressUnion(t.To, &itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field to failed")
						}
					} else {
						err = marshalNull(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field to failed")
						}
					}
					if count > 3 {
						if t.Subject != "" {
							err = marshalString(t.Subject, &itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field subject failed")
							}
						} else {
							err = marshalNull(&itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field subject failed")
							}
						}
						if count > 4 {
							if t.ReplyTo != nil {
								err = marshalAddressUnion(t.ReplyTo, &itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field reply-to failed")
								}
							} else {
								err = marshalNull(&itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field reply-to failed")
								}
							}
							if count > 5 {
								if t.CorrelationID != nil {
									err = marshalMessageIDUnion(t.CorrelationID, &itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field correlation-id failed")
									}
								} else {
									err = marshalNull(&itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field correlation-id failed")
									}
								}
								if count > 6 {
									if t.ContentType != "" {
										err = marshalSymbol(t.ContentType, &itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field content-type failed")
										}
									} else {
										err = marshalNull(&itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field content-type failed")
										}
									}
									if count > 7 {
										if t.ContentEncoding != "" {
											err = marshalSymbol(t.ContentEncoding, &itemBuf)
											if err != nil {
												return errors.Wrap(err, "marshal field content-encoding failed")
											}
										} else {
											err = marshalNull(&itemBuf)
											if err != nil {
												return errors.Wrap(err, "marshal field content-encoding failed")
											}
										}
										if count > 8 {
											if !t.AbsoluteExpiryTime.IsZero() {
												err = marshalTimestamp(t.AbsoluteExpiryTime, &itemBuf)
												if err != nil {
													return errors.Wrap(err, "marshal field absolute-expiry-time failed")
												}
											} else {
												err = marshalNull(&itemBuf)
												if err != nil {
													return errors.Wrap(err, "marshal field absolute-expiry-time failed")
												}
											}
											if count > 9 {
												if !t.CreationTime.IsZero() {
													err = marshalTimestamp(t.CreationTime, &itemBuf)
													if err != nil {
														return errors.Wrap(err, "marshal field creation-time failed")
													}
												} else {
													err = marshalNull(&itemBuf)
													if err != nil {
														return errors.Wrap(err, "marshal field creation-time failed")
													}
												}
												if count > 10 {
													if t.GroupID != "" {
														err = marshalString(t.GroupID, &itemBuf)
														if err != nil {
															return errors.Wrap(err, "marshal field group-id failed")
														}
													} else {
														err = marshalNull(&itemBuf)
														if err != nil {
															return errors.Wrap(err, "marshal field group-id failed")
														}
													}
													if count > 11 {
														if t.GroupSequence != 0 {
															err = t.GroupSequence.MarshalBuffer(&itemBuf)
															if err != nil {
																return errors.Wrap(err, "marshal field group-sequence failed")
															}
														} else {
															err = marshalNull(&itemBuf)
															if err != nil {
																return errors.Wrap(err, "marshal field group-sequence failed")
															}
														}
														if count > 12 {
															if t.ReplyToGroupID != "" {
																err = marshalString(t.ReplyToGroupID, &itemBuf)
																if err != nil {
																	return errors.Wrap(err, "marshal field reply-to-group-id failed")
																}
															} else {
																err = marshalNull(&itemBuf)
																if err != nil {
																	return errors.Wrap(err, "marshal field reply-to-group-id failed")
																}
															}

														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Properties) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Properties) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != PropertiesDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal properties failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		err = unmarshalMessageIDUnion(&t.MessageID, itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field message-id failed")
		}
		done = 1
		if count > 1 {
			constructor, err = itemBuf.ReadByte()
			if err != nil {
				return errors.Wrap(err, "unmarshal field user-id failed")
			}
			err = unmarshalBinary(&t.UserID, constructor, itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field user-id failed")
			}
			done = 2
			if count > 2 {
				err = unmarshalAddressUnion(&t.To, itemBuf)
				if err != nil {
					return errors.Wrap(err, "unmarshal field to failed")
				}
				done = 3
				if count > 3 {
					constructor, err = itemBuf.ReadByte()
					if err != nil {
						return errors.Wrap(err, "unmarshal field subject failed")
					}
					err = unmarshalString(&t.Subject, constructor, itemBuf)
					if err != nil {
						return errors.Wrap(err, "unmarshal field subject failed")
					}
					done = 4
					if count > 4 {
						err = unmarshalAddressUnion(&t.ReplyTo, itemBuf)
						if err != nil {
							return errors.Wrap(err, "unmarshal field reply-to failed")
						}
						done = 5
						if count > 5 {
							err = unmarshalMessageIDUnion(&t.CorrelationID, itemBuf)
							if err != nil {
								return errors.Wrap(err, "unmarshal field correlation-id failed")
							}
							done = 6
							if count > 6 {
								constructor, err = itemBuf.ReadByte()
								if err != nil {
									return errors.Wrap(err, "unmarshal field content-type failed")
								}
								err = unmarshalSymbol(&t.ContentType, constructor, itemBuf)
								if err != nil {
									return errors.Wrap(err, "unmarshal field content-type failed")
								}
								done = 7
								if count > 7 {
									constructor, err = itemBuf.ReadByte()
									if err != nil {
										return errors.Wrap(err, "unmarshal field content-encoding failed")
									}
									err = unmarshalSymbol(&t.ContentEncoding, constructor, itemBuf)
									if err != nil {
										return errors.Wrap(err, "unmarshal field content-encoding failed")
									}
									done = 8
									if count > 8 {
										constructor, err = itemBuf.ReadByte()
										if err != nil {
											return errors.Wrap(err, "unmarshal field absolute-expiry-time failed")
										}
										err = unmarshalTimestamp(&t.AbsoluteExpiryTime, constructor, itemBuf)
										if err != nil {
											return errors.Wrap(err, "unmarshal field absolute-expiry-time failed")
										}
										done = 9
										if count > 9 {
											constructor, err = itemBuf.ReadByte()
											if err != nil {
												return errors.Wrap(err, "unmarshal field creation-time failed")
											}
											err = unmarshalTimestamp(&t.CreationTime, constructor, itemBuf)
											if err != nil {
												return errors.Wrap(err, "unmarshal field creation-time failed")
											}
											done = 10
											if count > 10 {
												constructor, err = itemBuf.ReadByte()
												if err != nil {
													return errors.Wrap(err, "unmarshal field group-id failed")
												}
												err = unmarshalString(&t.GroupID, constructor, itemBuf)
												if err != nil {
													return errors.Wrap(err, "unmarshal field group-id failed")
												}
												done = 11
												if count > 11 {
													err = t.GroupSequence.UnmarshalBuffer(itemBuf)
													if err != nil {
														return errors.Wrap(err, "unmarshal field group-sequence failed")
													}
													done = 12
													if count > 12 {
														constructor, err = itemBuf.ReadByte()
														if err != nil {
															return errors.Wrap(err, "unmarshal field reply-to-group-id failed")
														}
														err = unmarshalString(&t.ReplyToGroupID, constructor, itemBuf)
														if err != nil {
															return errors.Wrap(err, "unmarshal field reply-to-group-id failed")
														}
														done = 13

													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	ApplicationPropertiesName       = "amqp:application-properties:map"
	ApplicationPropertiesDescriptor = 0x0000000000000074
)

type ApplicationProperties types.Struct

func (ApplicationProperties) isSection() {}

func (t *ApplicationProperties) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *ApplicationProperties) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalMap((*types.Struct)(t), buf)
}

func (t *ApplicationProperties) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *ApplicationProperties) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}

	var m *types.Struct
	err = unmarshalMap(&m, constructor, buf)
	if err != nil {
		return err
	}

	*t = (ApplicationProperties)(*m)
	return nil
}

const (
	DataName       = "amqp:data:binary"
	DataDescriptor = 0x0000000000000075
)

type Data []byte

func (Data) isSection() {}

func (t Data) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t Data) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalBinary([]byte(t), buf)
}

func (t *Data) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Data) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalBinary((*[]byte)(t), constructor, buf)
}

const (
	FooterName       = "amqp:footer:map"
	FooterDescriptor = 0x0000000000000078
)

type Footer types.Struct

func (Footer) isSection() {}

func (t *Footer) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Footer) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalMap((*types.Struct)(t), buf)
}

func (t *Footer) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Footer) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}

	var m *types.Struct
	err = unmarshalMap(&m, constructor, buf)
	if err != nil {
		return err
	}

	*t = (Footer)(*m)
	return nil
}

type Annotations types.Struct

func (t *Annotations) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Annotations) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalMap((*types.Struct)(t), buf)
}

func (t *Annotations) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Annotations) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}

	var m *types.Struct
	err = unmarshalMap(&m, constructor, buf)
	if err != nil {
		return err
	}

	*t = (Annotations)(*m)
	return nil
}

type MessageIDUlong uint64

func (MessageIDUlong) isMessageID() {}

func (t MessageIDUlong) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t MessageIDUlong) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalUlong(uint64(t), buf)
}

func (t *MessageIDUlong) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *MessageIDUlong) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalUlong((*uint64)(t), constructor, buf)
}

type MessageIDUUID UUID

func (MessageIDUUID) isMessageID() {}

func (t MessageIDUUID) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t MessageIDUUID) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalUUID(UUID(t), buf)
}

func (t *MessageIDUUID) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *MessageIDUUID) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalUUID((*UUID)(t), constructor, buf)
}

type MessageIDBinary []byte

func (MessageIDBinary) isMessageID() {}

func (t MessageIDBinary) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t MessageIDBinary) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalBinary([]byte(t), buf)
}

func (t *MessageIDBinary) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *MessageIDBinary) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalBinary((*[]byte)(t), constructor, buf)
}

type MessageIDString string

func (MessageIDString) isMessageID() {}

func (t MessageIDString) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t MessageIDString) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalString(string(t), buf)
}

func (t *MessageIDString) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *MessageIDString) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalString((*string)(t), constructor, buf)
}

type AddressString string

func (AddressString) isAddress() {}

func (t AddressString) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t AddressString) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalString(string(t), buf)
}

func (t *AddressString) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *AddressString) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalString((*string)(t), constructor, buf)
}

const (
	ReceivedName       = "amqp:received:list"
	ReceivedDescriptor = 0x0000000000000023
)

type Received struct {
	SectionNumber uint32
	SectionOffset uint64
}

func (*Received) isDeliveryState() {}

func (t *Received) Descriptor() uint64 {
	return ReceivedDescriptor
}

func (t *Received) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Received) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(ReceivedDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	count = 1 // section-number is mandatory
	count = 2 // section-offset is mandatory

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			err = marshalUint(t.SectionNumber, &itemBuf)
			if err != nil {
				return errors.Wrap(err, "marshal field section-number failed")
			}

			if count > 1 {
				err = marshalUlong(t.SectionOffset, &itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field section-offset failed")
				}

			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Received) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Received) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != ReceivedDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal received failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		constructor, err = itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "unmarshal field section-number failed")
		}
		err = unmarshalUint(&t.SectionNumber, constructor, itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field section-number failed")
		}
		done = 1
		if count > 1 {
			constructor, err = itemBuf.ReadByte()
			if err != nil {
				return errors.Wrap(err, "unmarshal field section-offset failed")
			}
			err = unmarshalUlong(&t.SectionOffset, constructor, itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field section-offset failed")
			}
			done = 2

		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	AcceptedName       = "amqp:accepted:list"
	AcceptedDescriptor = 0x0000000000000024
)

type Accepted struct {
}

func (*Accepted) isDeliveryState() {}

func (*Accepted) isOutcome() {}

func (t *Accepted) Descriptor() uint64 {
	return AcceptedDescriptor
}

func (t *Accepted) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Accepted) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(AcceptedDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Accepted) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Accepted) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != AcceptedDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal accepted failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	RejectedName       = "amqp:rejected:list"
	RejectedDescriptor = 0x0000000000000025
)

type Rejected struct {
	Error *Error
}

func (*Rejected) isDeliveryState() {}

func (*Rejected) isOutcome() {}

func (t *Rejected) Descriptor() uint64 {
	return RejectedDescriptor
}

func (t *Rejected) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Rejected) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(RejectedDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	if t.Error != nil {
		count = 1
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			if t.Error != nil {
				err = t.Error.MarshalBuffer(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field error failed")
				}
			} else {
				err = marshalNull(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field error failed")
				}
			}

		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Rejected) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Rejected) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != RejectedDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal rejected failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		t.Error = &Error{}
		err = t.Error.UnmarshalBuffer(itemBuf)
		if err == errNull {
			t.Error = nil
		} else if err != nil {
			return errors.Wrap(err, "unmarshal field error failed")
		}
		done = 1

	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	ReleasedName       = "amqp:released:list"
	ReleasedDescriptor = 0x0000000000000026
)

type Released struct {
}

func (*Released) isDeliveryState() {}

func (*Released) isOutcome() {}

func (t *Released) Descriptor() uint64 {
	return ReleasedDescriptor
}

func (t *Released) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Released) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(ReleasedDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Released) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Released) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != ReleasedDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal released failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	ModifiedName       = "amqp:modified:list"
	ModifiedDescriptor = 0x0000000000000027
)

type Modified struct {
	DeliveryFailed     bool
	UndeliverableHere  bool
	MessageAnnotations *Fields
}

func (*Modified) isDeliveryState() {}

func (*Modified) isOutcome() {}

func (t *Modified) Descriptor() uint64 {
	return ModifiedDescriptor
}

func (t *Modified) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Modified) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(ModifiedDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	if t.DeliveryFailed != false {
		count = 1
	}
	if t.UndeliverableHere != false {
		count = 2
	}
	if t.MessageAnnotations != nil {
		count = 3
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			if t.DeliveryFailed != false {
				err = marshalBoolean(t.DeliveryFailed, &itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field delivery-failed failed")
				}
			} else {
				err = marshalNull(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field delivery-failed failed")
				}
			}
			if count > 1 {
				if t.UndeliverableHere != false {
					err = marshalBoolean(t.UndeliverableHere, &itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field undeliverable-here failed")
					}
				} else {
					err = marshalNull(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field undeliverable-here failed")
					}
				}
				if count > 2 {
					if t.MessageAnnotations != nil {
						err = t.MessageAnnotations.MarshalBuffer(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field message-annotations failed")
						}
					} else {
						err = marshalNull(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field message-annotations failed")
						}
					}

				}
			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Modified) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Modified) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != ModifiedDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal modified failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		constructor, err = itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "unmarshal field delivery-failed failed")
		}
		err = unmarshalBoolean(&t.DeliveryFailed, constructor, itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field delivery-failed failed")
		}
		done = 1
		if count > 1 {
			constructor, err = itemBuf.ReadByte()
			if err != nil {
				return errors.Wrap(err, "unmarshal field undeliverable-here failed")
			}
			err = unmarshalBoolean(&t.UndeliverableHere, constructor, itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field undeliverable-here failed")
			}
			done = 2
			if count > 2 {
				constructor, err = itemBuf.ReadByte()
				if err != nil {
					return errors.Wrap(err, "unmarshal field message-annotations failed")
				}
				var map2 *types.Struct
				err = unmarshalMap(&map2, constructor, itemBuf)
				if err != nil {
					return errors.Wrap(err, "unmarshal field message-annotations failed")
				}
				t.MessageAnnotations = (*Fields)(map2)
				done = 3

			}
		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	SourceName       = "amqp:source:list"
	SourceDescriptor = 0x0000000000000028
)

type Source struct {
	Address               Address
	Durable               TerminusDurability
	ExpiryPolicy          TerminusExpiryPolicy
	Timeout               Seconds
	Dynamic               bool
	DynamicNodeProperties *NodeProperties
	DistributionMode      string
	Filter                *FilterSet
	DefaultOutcome        Outcome
	Outcomes              []string
	Capabilities          []string
}

func (*Source) isSource() {}

func (t *Source) Descriptor() uint64 {
	return SourceDescriptor
}

func (t *Source) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Source) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(SourceDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	if t.Address != nil {
		count = 1
	}
	if t.Durable != 0 {
		count = 2
	}
	if t.ExpiryPolicy != "" {
		count = 3
	}
	if t.Timeout != 0 {
		count = 4
	}
	if t.Dynamic != false {
		count = 5
	}
	if t.DynamicNodeProperties != nil {
		count = 6
	}
	if t.DistributionMode != "" {
		count = 7
	}
	if t.Filter != nil {
		count = 8
	}
	if t.DefaultOutcome != nil {
		count = 9
	}
	if len(t.Outcomes) > 0 {
		count = 10
	}
	if len(t.Capabilities) > 0 {
		count = 11
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			if t.Address != nil {
				err = marshalAddressUnion(t.Address, &itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field address failed")
				}
			} else {
				err = marshalNull(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field address failed")
				}
			}
			if count > 1 {
				if t.Durable != 0 {
					err = t.Durable.MarshalBuffer(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field durable failed")
					}
				} else {
					err = marshalNull(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field durable failed")
					}
				}
				if count > 2 {
					if t.ExpiryPolicy != "" {
						err = t.ExpiryPolicy.MarshalBuffer(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field expiry-policy failed")
						}
					} else {
						err = marshalNull(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field expiry-policy failed")
						}
					}
					if count > 3 {
						if t.Timeout != 0 {
							err = t.Timeout.MarshalBuffer(&itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field timeout failed")
							}
						} else {
							err = marshalNull(&itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field timeout failed")
							}
						}
						if count > 4 {
							if t.Dynamic != false {
								err = marshalBoolean(t.Dynamic, &itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field dynamic failed")
								}
							} else {
								err = marshalNull(&itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field dynamic failed")
								}
							}
							if count > 5 {
								if t.DynamicNodeProperties != nil {
									err = t.DynamicNodeProperties.MarshalBuffer(&itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field dynamic-node-properties failed")
									}
								} else {
									err = marshalNull(&itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field dynamic-node-properties failed")
									}
								}
								if count > 6 {
									if t.DistributionMode != "" {
										err = marshalSymbol(t.DistributionMode, &itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field distribution-mode failed")
										}
									} else {
										err = marshalNull(&itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field distribution-mode failed")
										}
									}
									if count > 7 {
										if t.Filter != nil {
											err = t.Filter.MarshalBuffer(&itemBuf)
											if err != nil {
												return errors.Wrap(err, "marshal field filter failed")
											}
										} else {
											err = marshalNull(&itemBuf)
											if err != nil {
												return errors.Wrap(err, "marshal field filter failed")
											}
										}
										if count > 8 {
											if t.DefaultOutcome != nil {
												err = marshalOutcomeUnion(t.DefaultOutcome, &itemBuf)
												if err != nil {
													return errors.Wrap(err, "marshal field default-outcome failed")
												}
											} else {
												err = marshalNull(&itemBuf)
												if err != nil {
													return errors.Wrap(err, "marshal field default-outcome failed")
												}
											}
											if count > 9 {
												if len(t.Outcomes) > 0 {
													err = marshalSymbolArray(t.Outcomes, &itemBuf)
													if err != nil {
														return errors.Wrap(err, "marshal field outcomes failed")
													}

												} else {
													err = marshalNull(&itemBuf)
													if err != nil {
														return errors.Wrap(err, "marshal field outcomes failed")
													}
												}
												if count > 10 {
													if len(t.Capabilities) > 0 {
														err = marshalSymbolArray(t.Capabilities, &itemBuf)
														if err != nil {
															return errors.Wrap(err, "marshal field capabilities failed")
														}

													} else {
														err = marshalNull(&itemBuf)
														if err != nil {
															return errors.Wrap(err, "marshal field capabilities failed")
														}
													}

												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Source) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Source) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != SourceDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal source failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		err = unmarshalAddressUnion(&t.Address, itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field address failed")
		}
		done = 1
		if count > 1 {
			err = t.Durable.UnmarshalBuffer(itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field durable failed")
			}
			done = 2
			if count > 2 {
				err = t.ExpiryPolicy.UnmarshalBuffer(itemBuf)
				if err != nil {
					return errors.Wrap(err, "unmarshal field expiry-policy failed")
				}
				done = 3
				if count > 3 {
					err = t.Timeout.UnmarshalBuffer(itemBuf)
					if err != nil {
						return errors.Wrap(err, "unmarshal field timeout failed")
					}
					done = 4
					if count > 4 {
						constructor, err = itemBuf.ReadByte()
						if err != nil {
							return errors.Wrap(err, "unmarshal field dynamic failed")
						}
						err = unmarshalBoolean(&t.Dynamic, constructor, itemBuf)
						if err != nil {
							return errors.Wrap(err, "unmarshal field dynamic failed")
						}
						done = 5
						if count > 5 {
							constructor, err = itemBuf.ReadByte()
							if err != nil {
								return errors.Wrap(err, "unmarshal field dynamic-node-properties failed")
							}
							var map5 *types.Struct
							err = unmarshalMap(&map5, constructor, itemBuf)
							if err != nil {
								return errors.Wrap(err, "unmarshal field dynamic-node-properties failed")
							}
							t.DynamicNodeProperties = (*NodeProperties)(map5)
							done = 6
							if count > 6 {
								constructor, err = itemBuf.ReadByte()
								if err != nil {
									return errors.Wrap(err, "unmarshal field distribution-mode failed")
								}
								err = unmarshalSymbol(&t.DistributionMode, constructor, itemBuf)
								if err != nil {
									return errors.Wrap(err, "unmarshal field distribution-mode failed")
								}
								done = 7
								if count > 7 {
									constructor, err = itemBuf.ReadByte()
									if err != nil {
										return errors.Wrap(err, "unmarshal field filter failed")
									}
									var map7 *types.Struct
									err = unmarshalMap(&map7, constructor, itemBuf)
									if err != nil {
										return errors.Wrap(err, "unmarshal field filter failed")
									}
									t.Filter = (*FilterSet)(map7)
									done = 8
									if count > 8 {
										err = unmarshalOutcomeUnion(&t.DefaultOutcome, itemBuf)
										if err != nil {
											return errors.Wrap(err, "unmarshal field default-outcome failed")
										}
										done = 9
										if count > 9 {
											constructor, err = itemBuf.ReadByte()
											if err != nil {
												return errors.Wrap(err, "unmarshal field outcomes failed")
											}
											err = unmarshalSymbolArray(&t.Outcomes, constructor, itemBuf)
											if err != nil {
												return errors.Wrap(err, "unmarshal field outcomes failed")
											}

											done = 10
											if count > 10 {
												constructor, err = itemBuf.ReadByte()
												if err != nil {
													return errors.Wrap(err, "unmarshal field capabilities failed")
												}
												err = unmarshalSymbolArray(&t.Capabilities, constructor, itemBuf)
												if err != nil {
													return errors.Wrap(err, "unmarshal field capabilities failed")
												}

												done = 11

											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	TargetName       = "amqp:target:list"
	TargetDescriptor = 0x0000000000000029
)

type Target struct {
	Address               Address
	Durable               TerminusDurability
	ExpiryPolicy          TerminusExpiryPolicy
	Timeout               Seconds
	Dynamic               bool
	DynamicNodeProperties *NodeProperties
	Capabilities          []string
}

func (*Target) isTarget() {}

func (t *Target) Descriptor() uint64 {
	return TargetDescriptor
}

func (t *Target) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *Target) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(TargetDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	if t.Address != nil {
		count = 1
	}
	if t.Durable != 0 {
		count = 2
	}
	if t.ExpiryPolicy != "" {
		count = 3
	}
	if t.Timeout != 0 {
		count = 4
	}
	if t.Dynamic != false {
		count = 5
	}
	if t.DynamicNodeProperties != nil {
		count = 6
	}
	if len(t.Capabilities) > 0 {
		count = 7
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			if t.Address != nil {
				err = marshalAddressUnion(t.Address, &itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field address failed")
				}
			} else {
				err = marshalNull(&itemBuf)
				if err != nil {
					return errors.Wrap(err, "marshal field address failed")
				}
			}
			if count > 1 {
				if t.Durable != 0 {
					err = t.Durable.MarshalBuffer(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field durable failed")
					}
				} else {
					err = marshalNull(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field durable failed")
					}
				}
				if count > 2 {
					if t.ExpiryPolicy != "" {
						err = t.ExpiryPolicy.MarshalBuffer(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field expiry-policy failed")
						}
					} else {
						err = marshalNull(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field expiry-policy failed")
						}
					}
					if count > 3 {
						if t.Timeout != 0 {
							err = t.Timeout.MarshalBuffer(&itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field timeout failed")
							}
						} else {
							err = marshalNull(&itemBuf)
							if err != nil {
								return errors.Wrap(err, "marshal field timeout failed")
							}
						}
						if count > 4 {
							if t.Dynamic != false {
								err = marshalBoolean(t.Dynamic, &itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field dynamic failed")
								}
							} else {
								err = marshalNull(&itemBuf)
								if err != nil {
									return errors.Wrap(err, "marshal field dynamic failed")
								}
							}
							if count > 5 {
								if t.DynamicNodeProperties != nil {
									err = t.DynamicNodeProperties.MarshalBuffer(&itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field dynamic-node-properties failed")
									}
								} else {
									err = marshalNull(&itemBuf)
									if err != nil {
										return errors.Wrap(err, "marshal field dynamic-node-properties failed")
									}
								}
								if count > 6 {
									if len(t.Capabilities) > 0 {
										err = marshalSymbolArray(t.Capabilities, &itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field capabilities failed")
										}

									} else {
										err = marshalNull(&itemBuf)
										if err != nil {
											return errors.Wrap(err, "marshal field capabilities failed")
										}
									}

								}
							}
						}
					}
				}
			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *Target) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *Target) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != TargetDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal target failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		err = unmarshalAddressUnion(&t.Address, itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field address failed")
		}
		done = 1
		if count > 1 {
			err = t.Durable.UnmarshalBuffer(itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field durable failed")
			}
			done = 2
			if count > 2 {
				err = t.ExpiryPolicy.UnmarshalBuffer(itemBuf)
				if err != nil {
					return errors.Wrap(err, "unmarshal field expiry-policy failed")
				}
				done = 3
				if count > 3 {
					err = t.Timeout.UnmarshalBuffer(itemBuf)
					if err != nil {
						return errors.Wrap(err, "unmarshal field timeout failed")
					}
					done = 4
					if count > 4 {
						constructor, err = itemBuf.ReadByte()
						if err != nil {
							return errors.Wrap(err, "unmarshal field dynamic failed")
						}
						err = unmarshalBoolean(&t.Dynamic, constructor, itemBuf)
						if err != nil {
							return errors.Wrap(err, "unmarshal field dynamic failed")
						}
						done = 5
						if count > 5 {
							constructor, err = itemBuf.ReadByte()
							if err != nil {
								return errors.Wrap(err, "unmarshal field dynamic-node-properties failed")
							}
							var map5 *types.Struct
							err = unmarshalMap(&map5, constructor, itemBuf)
							if err != nil {
								return errors.Wrap(err, "unmarshal field dynamic-node-properties failed")
							}
							t.DynamicNodeProperties = (*NodeProperties)(map5)
							done = 6
							if count > 6 {
								constructor, err = itemBuf.ReadByte()
								if err != nil {
									return errors.Wrap(err, "unmarshal field capabilities failed")
								}
								err = unmarshalSymbolArray(&t.Capabilities, constructor, itemBuf)
								if err != nil {
									return errors.Wrap(err, "unmarshal field capabilities failed")
								}

								done = 7

							}
						}
					}
				}
			}
		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

type TerminusDurability uint32

const (
	NoneTerminusDurability           TerminusDurability = 0
	ConfigurationTerminusDurability  TerminusDurability = 1
	UnsettledStateTerminusDurability TerminusDurability = 2
)

func (t TerminusDurability) String() string {
	switch t {
	case NoneTerminusDurability:
		return "none"
	case ConfigurationTerminusDurability:
		return "configuration"
	case UnsettledStateTerminusDurability:
		return "unsettled-state"
	default:
		return "<invalid>"
	}
}

func (t TerminusDurability) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t TerminusDurability) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalUint(uint32(t), buf)
}

func (t *TerminusDurability) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *TerminusDurability) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalUint((*uint32)(t), constructor, buf)
}

type TerminusExpiryPolicy string

const (
	LinkDetachTerminusExpiryPolicy      TerminusExpiryPolicy = "link-detach"
	SessionEndTerminusExpiryPolicy      TerminusExpiryPolicy = "session-end"
	ConnectionCloseTerminusExpiryPolicy TerminusExpiryPolicy = "connection-close"
	NeverTerminusExpiryPolicy           TerminusExpiryPolicy = "never"
)

func (t TerminusExpiryPolicy) String() string {
	return string(t)
}

func (t TerminusExpiryPolicy) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t TerminusExpiryPolicy) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalSymbol(string(t), buf)
}

func (t *TerminusExpiryPolicy) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *TerminusExpiryPolicy) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalSymbol((*string)(t), constructor, buf)
}

type StdDistMode string

const (
	MoveStdDistMode StdDistMode = "move"
	CopyStdDistMode StdDistMode = "copy"
)

func (t StdDistMode) String() string {
	return string(t)
}

func (StdDistMode) isDistributionMode() {}

func (t StdDistMode) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t StdDistMode) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalSymbol(string(t), buf)
}

func (t *StdDistMode) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *StdDistMode) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalSymbol((*string)(t), constructor, buf)
}

type FilterSet types.Struct

func (t *FilterSet) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *FilterSet) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalMap((*types.Struct)(t), buf)
}

func (t *FilterSet) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *FilterSet) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}

	var m *types.Struct
	err = unmarshalMap(&m, constructor, buf)
	if err != nil {
		return err
	}

	*t = (FilterSet)(*m)
	return nil
}

type NodeProperties types.Struct

func (t *NodeProperties) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *NodeProperties) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalMap((*types.Struct)(t), buf)
}

func (t *NodeProperties) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *NodeProperties) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}

	var m *types.Struct
	err = unmarshalMap(&m, constructor, buf)
	if err != nil {
		return err
	}

	*t = (NodeProperties)(*m)
	return nil
}

const (
	DeleteOnCloseName       = "amqp:delete-on-close:list"
	DeleteOnCloseDescriptor = 0x000000000000002b
)

type DeleteOnClose struct {
}

func (*DeleteOnClose) isLifetimePolicy() {}

func (t *DeleteOnClose) Descriptor() uint64 {
	return DeleteOnCloseDescriptor
}

func (t *DeleteOnClose) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *DeleteOnClose) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(DeleteOnCloseDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *DeleteOnClose) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *DeleteOnClose) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != DeleteOnCloseDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal delete-on-close failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	DeleteOnNoLinksName       = "amqp:delete-on-no-links:list"
	DeleteOnNoLinksDescriptor = 0x000000000000002c
)

type DeleteOnNoLinks struct {
}

func (*DeleteOnNoLinks) isLifetimePolicy() {}

func (t *DeleteOnNoLinks) Descriptor() uint64 {
	return DeleteOnNoLinksDescriptor
}

func (t *DeleteOnNoLinks) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *DeleteOnNoLinks) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(DeleteOnNoLinksDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *DeleteOnNoLinks) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *DeleteOnNoLinks) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != DeleteOnNoLinksDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal delete-on-no-links failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	DeleteOnNoMessagesName       = "amqp:delete-on-no-messages:list"
	DeleteOnNoMessagesDescriptor = 0x000000000000002d
)

type DeleteOnNoMessages struct {
}

func (*DeleteOnNoMessages) isLifetimePolicy() {}

func (t *DeleteOnNoMessages) Descriptor() uint64 {
	return DeleteOnNoMessagesDescriptor
}

func (t *DeleteOnNoMessages) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *DeleteOnNoMessages) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(DeleteOnNoMessagesDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *DeleteOnNoMessages) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *DeleteOnNoMessages) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != DeleteOnNoMessagesDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal delete-on-no-messages failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	DeleteOnNoLinksOrMessagesName       = "amqp:delete-on-no-links-or-messages:list"
	DeleteOnNoLinksOrMessagesDescriptor = 0x000000000000002e
)

type DeleteOnNoLinksOrMessages struct {
}

func (*DeleteOnNoLinksOrMessages) isLifetimePolicy() {}

func (t *DeleteOnNoLinksOrMessages) Descriptor() uint64 {
	return DeleteOnNoLinksOrMessagesDescriptor
}

func (t *DeleteOnNoLinksOrMessages) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *DeleteOnNoLinksOrMessages) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(DeleteOnNoLinksOrMessagesDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *DeleteOnNoLinksOrMessages) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *DeleteOnNoLinksOrMessages) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != DeleteOnNoLinksOrMessagesDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal delete-on-no-links-or-messages failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	TLSMajor    = 1
	TLSMinor    = 0
	TLSRevision = 0
)

const (
	SASLMajor    = 1
	SASLMinor    = 0
	SASLRevision = 0
)

const (
	SASLMechanismsName       = "amqp:sasl-mechanisms:list"
	SASLMechanismsDescriptor = 0x0000000000000040
)

type SASLMechanisms struct {
	FrameMeta
	SASLServerMechanisms []string
}

func (*SASLMechanisms) isSASLFrame() {}

func (t *SASLMechanisms) GetFrameMeta() *FrameMeta {
	return &t.FrameMeta
}

func (t *SASLMechanisms) Descriptor() uint64 {
	return SASLMechanismsDescriptor
}

func (t *SASLMechanisms) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *SASLMechanisms) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(SASLMechanismsDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	count = 1 // sasl-server-mechanisms is mandatory

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			err = marshalSymbolArray(t.SASLServerMechanisms, &itemBuf)
			if err != nil {
				return errors.Wrap(err, "marshal field sasl-server-mechanisms failed")
			}

		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *SASLMechanisms) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *SASLMechanisms) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != SASLMechanismsDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal sasl-mechanisms failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		constructor, err = itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "unmarshal field sasl-server-mechanisms failed")
		}
		err = unmarshalSymbolArray(&t.SASLServerMechanisms, constructor, itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field sasl-server-mechanisms failed")
		}

		done = 1

	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	SASLInitName       = "amqp:sasl-init:list"
	SASLInitDescriptor = 0x0000000000000041
)

type SASLInit struct {
	FrameMeta
	Mechanism       string
	InitialResponse []byte
	Hostname        string
}

func (*SASLInit) isSASLFrame() {}

func (t *SASLInit) GetFrameMeta() *FrameMeta {
	return &t.FrameMeta
}

func (t *SASLInit) Descriptor() uint64 {
	return SASLInitDescriptor
}

func (t *SASLInit) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *SASLInit) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(SASLInitDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	count = 1 // mechanism is mandatory
	if t.InitialResponse != nil {
		count = 2
	}
	if t.Hostname != "" {
		count = 3
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			err = marshalSymbol(t.Mechanism, &itemBuf)
			if err != nil {
				return errors.Wrap(err, "marshal field mechanism failed")
			}

			if count > 1 {
				if t.InitialResponse != nil {
					err = marshalBinary(t.InitialResponse, &itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field initial-response failed")
					}
				} else {
					err = marshalNull(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field initial-response failed")
					}
				}
				if count > 2 {
					if t.Hostname != "" {
						err = marshalString(t.Hostname, &itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field hostname failed")
						}
					} else {
						err = marshalNull(&itemBuf)
						if err != nil {
							return errors.Wrap(err, "marshal field hostname failed")
						}
					}

				}
			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *SASLInit) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *SASLInit) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != SASLInitDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal sasl-init failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		constructor, err = itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "unmarshal field mechanism failed")
		}
		err = unmarshalSymbol(&t.Mechanism, constructor, itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field mechanism failed")
		}
		done = 1
		if count > 1 {
			constructor, err = itemBuf.ReadByte()
			if err != nil {
				return errors.Wrap(err, "unmarshal field initial-response failed")
			}
			err = unmarshalBinary(&t.InitialResponse, constructor, itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field initial-response failed")
			}
			done = 2
			if count > 2 {
				constructor, err = itemBuf.ReadByte()
				if err != nil {
					return errors.Wrap(err, "unmarshal field hostname failed")
				}
				err = unmarshalString(&t.Hostname, constructor, itemBuf)
				if err != nil {
					return errors.Wrap(err, "unmarshal field hostname failed")
				}
				done = 3

			}
		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	SASLChallengeName       = "amqp:sasl-challenge:list"
	SASLChallengeDescriptor = 0x0000000000000042
)

type SASLChallenge struct {
	FrameMeta
	Challenge []byte
}

func (*SASLChallenge) isSASLFrame() {}

func (t *SASLChallenge) GetFrameMeta() *FrameMeta {
	return &t.FrameMeta
}

func (t *SASLChallenge) Descriptor() uint64 {
	return SASLChallengeDescriptor
}

func (t *SASLChallenge) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *SASLChallenge) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(SASLChallengeDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	count = 1 // challenge is mandatory

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			err = marshalBinary(t.Challenge, &itemBuf)
			if err != nil {
				return errors.Wrap(err, "marshal field challenge failed")
			}

		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *SASLChallenge) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *SASLChallenge) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != SASLChallengeDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal sasl-challenge failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		constructor, err = itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "unmarshal field challenge failed")
		}
		err = unmarshalBinary(&t.Challenge, constructor, itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field challenge failed")
		}
		done = 1

	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	SASLResponseName       = "amqp:sasl-response:list"
	SASLResponseDescriptor = 0x0000000000000043
)

type SASLResponse struct {
	FrameMeta
	Response []byte
}

func (*SASLResponse) isSASLFrame() {}

func (t *SASLResponse) GetFrameMeta() *FrameMeta {
	return &t.FrameMeta
}

func (t *SASLResponse) Descriptor() uint64 {
	return SASLResponseDescriptor
}

func (t *SASLResponse) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *SASLResponse) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(SASLResponseDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	count = 1 // response is mandatory

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			err = marshalBinary(t.Response, &itemBuf)
			if err != nil {
				return errors.Wrap(err, "marshal field response failed")
			}

		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *SASLResponse) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *SASLResponse) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != SASLResponseDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal sasl-response failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		constructor, err = itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "unmarshal field response failed")
		}
		err = unmarshalBinary(&t.Response, constructor, itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field response failed")
		}
		done = 1

	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

const (
	SASLOutcomeName       = "amqp:sasl-outcome:list"
	SASLOutcomeDescriptor = 0x0000000000000044
)

type SASLOutcome struct {
	FrameMeta
	Code           SASLCode
	AdditionalData []byte
}

func (*SASLOutcome) isSASLFrame() {}

func (t *SASLOutcome) GetFrameMeta() *FrameMeta {
	return &t.FrameMeta
}

func (t *SASLOutcome) Descriptor() uint64 {
	return SASLOutcomeDescriptor
}

func (t *SASLOutcome) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *SASLOutcome) MarshalBuffer(buf *bytes.Buffer) (err error) {
	if t == nil {
		return errors.New("<nil>")
	}

	buf.WriteByte(DescriptorEncoding)
	err = marshalUlong(SASLOutcomeDescriptor, buf)
	if err != nil {
		return errors.Wrap(err, "marshal descriptor failed")
	}

	var count uint32 = 0
	count = 1 // code is mandatory
	if t.AdditionalData != nil {
		count = 2
	}

	if count == 0 {
		buf.WriteByte(List0Encoding)
	} else {
		itemBuf := bytes.Buffer{}

		if count > 0 {
			err = t.Code.MarshalBuffer(&itemBuf)
			if err != nil {
				return errors.Wrap(err, "marshal field code failed")
			}

			if count > 1 {
				if t.AdditionalData != nil {
					err = marshalBinary(t.AdditionalData, &itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field additional-data failed")
					}
				} else {
					err = marshalNull(&itemBuf)
					if err != nil {
						return errors.Wrap(err, "marshal field additional-data failed")
					}
				}

			}
		}

		if itemBuf.Len()+1 <= math.MaxUint8 && count <= math.MaxUint8 {
			buf.WriteByte(List8Encoding)
			buf.WriteByte(uint8(itemBuf.Len() + 1))
			buf.WriteByte(uint8(count))
		} else {
			var x [4]byte
			buf.WriteByte(List32Encoding)
			endian.PutUint32(x[:], uint32(itemBuf.Len()+4))
			buf.Write(x[:])
			endian.PutUint32(x[:], count)
			buf.Write(x[:])
		}

		buf.Write(itemBuf.Bytes())
	}
	return nil
}

func (t *SASLOutcome) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *SASLOutcome) UnmarshalBuffer(buf *bytes.Buffer) error {
	if t == nil {
		return errors.New("<nil>")
	}

	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if constructor == NullEncoding {
		return errNull
	} else if constructor != DescriptorEncoding {
		return errors.Errorf("expected descriptor, got constructor 0x%02x", constructor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	var descriptor uint64
	err = unmarshalUlong(&descriptor, constructor, buf)
	if err != nil {
		return errors.Wrap(err, "read descriptor failed")
	}
	if descriptor != SASLOutcomeDescriptor {
		return errors.Errorf("unexpected descriptor 0x%08x:0x%08x", descriptor>>32, descriptor)
	}
	constructor, err = buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	var size int
	switch constructor {
	case NullEncoding:
		fallthrough
	case List0Encoding:
		return nil
	case List8Encoding:
		v, err := buf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		size = int(v)
	case List32Encoding:
		if buf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		size = int(endian.Uint32(buf.Next(4)))
	default:
		return errors.Errorf("unmarshal sasl-outcome failed: unexpected constructor 0x%02x", constructor)
	}

	if buf.Len() < size {
		return errors.New("buffer underflow")
	}
	itemBuf := bytes.NewBuffer(buf.Next(size))

	var count int
	switch constructor {
	case List8Encoding:
		v, err := itemBuf.ReadByte()
		if err != nil {
			return errors.Wrap(err, "read length failed")
		}
		count = int(v)
	case List32Encoding:
		if itemBuf.Len() < 4 {
			return errors.New("read length failed: buffer underflow")
		}
		count = int(endian.Uint32(itemBuf.Next(4)))
	}

	var done int = 0
	if count > 0 {
		err = t.Code.UnmarshalBuffer(itemBuf)
		if err != nil {
			return errors.Wrap(err, "unmarshal field code failed")
		}
		done = 1
		if count > 1 {
			constructor, err = itemBuf.ReadByte()
			if err != nil {
				return errors.Wrap(err, "unmarshal field additional-data failed")
			}
			err = unmarshalBinary(&t.AdditionalData, constructor, itemBuf)
			if err != nil {
				return errors.Wrap(err, "unmarshal field additional-data failed")
			}
			done = 2

		}
	}

	if count > done {
		return errors.New("unmarshal failed: some fields were not read")
	}

	return nil
}

type SASLCode uint8

const (
	OkSASLCode      SASLCode = 0
	AuthSASLCode    SASLCode = 1
	SysSASLCode     SASLCode = 2
	SysPermSASLCode SASLCode = 3
	SysTempSASLCode SASLCode = 4
)

func (t SASLCode) String() string {
	switch t {
	case OkSASLCode:
		return "ok"
	case AuthSASLCode:
		return "auth"
	case SysSASLCode:
		return "sys"
	case SysPermSASLCode:
		return "sys-perm"
	case SysTempSASLCode:
		return "sys-temp"
	default:
		return "<invalid>"
	}
}

func (t SASLCode) Marshal() ([]byte, error) {
	buf := bytes.Buffer{}
	err := t.MarshalBuffer(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t SASLCode) MarshalBuffer(buf *bytes.Buffer) error {
	return marshalUbyte(uint8(t), buf)
}

func (t *SASLCode) Unmarshal(data []byte) error {
	return t.UnmarshalBuffer(bytes.NewBuffer(data))
}

func (t *SASLCode) UnmarshalBuffer(buf *bytes.Buffer) error {
	constructor, err := buf.ReadByte()
	if err != nil {
		return errors.Wrap(err, "read constructor failed")
	}
	return unmarshalUbyte((*uint8)(t), constructor, buf)
}
