// Code generated by ./generator/main.go. DO NOT EDIT.
package v0

//go:generate go run ./generator/main.go ./amqp0-9-1.stripped.xml ./amqp.spec.go

import (
	"bytes"
	"math"
	"time"

	"github.com/gogo/protobuf/types"
	"github.com/pkg/errors"
)

type FrameType uint8
type ClassID uint16
type MethodID uint16

const (
	Major                        = 0
	Minor                        = 9
	Revision                     = 1
	Port                         = 5672
	FrameMethod        FrameType = 1
	FrameHeader        FrameType = 2
	FrameBody          FrameType = 3
	FrameHeartbeat     FrameType = 8
	FrameMinSize                 = 4096
	FrameEnd                     = 206
	ReplySuccess                 = 200
	ContentTooLarge              = 311
	NoConsumers                  = 313
	ConnectionForced             = 320
	InvalidPath                  = 402
	AccessRefused                = 403
	NotFound                     = 404
	ResourceLocked               = 405
	PreconditionFailed           = 406
	FrameError                   = 501
	SyntaxError                  = 502
	CommandInvalid               = 503
	ChannelError                 = 504
	UnexpectedFrame              = 505
	ResourceError                = 506
	NotAllowed                   = 530
	NotImplemented               = 540
	InternalError                = 541

	ConnectionClass          ClassID  = 10
	ConnectionStartMethod    MethodID = 10
	ConnectionStartOkMethod  MethodID = 11
	ConnectionSecureMethod   MethodID = 20
	ConnectionSecureOkMethod MethodID = 21
	ConnectionTuneMethod     MethodID = 30
	ConnectionTuneOkMethod   MethodID = 31
	ConnectionOpenMethod     MethodID = 40
	ConnectionOpenOkMethod   MethodID = 41
	ConnectionCloseMethod    MethodID = 50
	ConnectionCloseOkMethod  MethodID = 51

	ChannelClass         ClassID  = 20
	ChannelOpenMethod    MethodID = 10
	ChannelOpenOkMethod  MethodID = 11
	ChannelFlowMethod    MethodID = 20
	ChannelFlowOkMethod  MethodID = 21
	ChannelCloseMethod   MethodID = 40
	ChannelCloseOkMethod MethodID = 41

	ExchangeClass           ClassID  = 40
	ExchangeDeclareMethod   MethodID = 10
	ExchangeDeclareOkMethod MethodID = 11
	ExchangeDeleteMethod    MethodID = 20
	ExchangeDeleteOkMethod  MethodID = 21

	QueueClass           ClassID  = 50
	QueueDeclareMethod   MethodID = 10
	QueueDeclareOkMethod MethodID = 11
	QueueBindMethod      MethodID = 20
	QueueBindOkMethod    MethodID = 21
	QueueUnbindMethod    MethodID = 50
	QueueUnbindOkMethod  MethodID = 51
	QueuePurgeMethod     MethodID = 30
	QueuePurgeOkMethod   MethodID = 31
	QueueDeleteMethod    MethodID = 40
	QueueDeleteOkMethod  MethodID = 41

	BasicClass              ClassID  = 60
	BasicQosMethod          MethodID = 10
	BasicQosOkMethod        MethodID = 11
	BasicConsumeMethod      MethodID = 20
	BasicConsumeOkMethod    MethodID = 21
	BasicCancelMethod       MethodID = 30
	BasicCancelOkMethod     MethodID = 31
	BasicPublishMethod      MethodID = 40
	BasicReturnMethod       MethodID = 50
	BasicDeliverMethod      MethodID = 60
	BasicGetMethod          MethodID = 70
	BasicGetOkMethod        MethodID = 71
	BasicGetEmptyMethod     MethodID = 72
	BasicAckMethod          MethodID = 80
	BasicRejectMethod       MethodID = 90
	BasicRecoverAsyncMethod MethodID = 100
	BasicRecoverMethod      MethodID = 110
	BasicRecoverOkMethod    MethodID = 111

	TxClass            ClassID  = 90
	TxSelectMethod     MethodID = 10
	TxSelectOkMethod   MethodID = 11
	TxCommitMethod     MethodID = 20
	TxCommitOkMethod   MethodID = 21
	TxRollbackMethod   MethodID = 30
	TxRollbackOkMethod MethodID = 31
)

type Frame interface {
	FrameType() FrameType
}

type MethodFrame interface {
	Frame
	FrameClassID() ClassID
	FrameMethodID() MethodID
}

type FrameMeta struct {
	Type    FrameType
	Channel uint16
	Size    uint32
}

type MethodMeta struct {
	ClassID  ClassID
	MethodID MethodID
}

type ContentFrame struct {
	FrameMeta
	Data []byte
}

func (f *ContentFrame) FrameType() FrameType {
	return f.FrameMeta.Type
}

type HeartbeatFrame struct {
	FrameMeta
}

func (f *HeartbeatFrame) FrameType() FrameType {
	return f.FrameMeta.Type
}

type ConnectionStart struct {
	FrameMeta
	MethodMeta
	VersionMajor     uint8
	VersionMinor     uint8
	ServerProperties *types.Struct
	Mechanisms       string
	Locales          string
}

func (f *ConnectionStart) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ConnectionStart) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ConnectionStart) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ConnectionStart) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ConnectionStartMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionStartMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field version-major: read octet failed")
	} else {
		f.VersionMajor = b
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field version-minor: read octet failed")
	} else {
		f.VersionMinor = b
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field server-properties: read table failed")
	} else if n < 4 {
		return errors.New("field server-properties: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field server-properties: read table failed")
		}
		if f.ServerProperties, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field server-properties: read table failed")
		}
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field mechanisms: read longstr failed")
	} else if n < 4 {
		return errors.New("field mechanisms: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field mechanisms: read longstr failed")
		}
		f.Mechanisms = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field locales: read longstr failed")
	} else if n < 4 {
		return errors.New("field locales: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field locales: read longstr failed")
		}
		f.Locales = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionStart) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ConnectionClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ConnectionStartMethod))
	buf.Write(x[:2])
	buf.WriteByte(f.VersionMajor)
	buf.WriteByte(f.VersionMinor)
	if tableBuf, err := marshalTable(f.ServerProperties); err != nil {
		return nil, errors.Wrap(err, "server-properties table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	if l := len(f.Mechanisms); l > math.MaxUint32 {
		return nil, errors.Errorf("mechanisms can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Mechanisms)
	}
	if l := len(f.Locales); l > math.MaxUint32 {
		return nil, errors.Errorf("locales can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Locales)
	}
	return buf.Bytes(), nil
}

type ConnectionStartOk struct {
	FrameMeta
	MethodMeta
	ClientProperties *types.Struct
	Mechanism        string
	Response         string
	Locale           string
}

func (f *ConnectionStartOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ConnectionStartOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ConnectionStartOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ConnectionStartOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ConnectionStartOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionStartOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field client-properties: read table failed")
	} else if n < 4 {
		return errors.New("field client-properties: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field client-properties: read table failed")
		}
		if f.ClientProperties, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field client-properties: read table failed")
		}
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field mechanism: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field mechanism: read shortstr failed")
		}
		f.Mechanism = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field response: read longstr failed")
	} else if n < 4 {
		return errors.New("field response: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field response: read longstr failed")
		}
		f.Response = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field locale: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field locale: read shortstr failed")
		}
		f.Locale = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionStartOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ConnectionClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ConnectionStartOkMethod))
	buf.Write(x[:2])
	if tableBuf, err := marshalTable(f.ClientProperties); err != nil {
		return nil, errors.Wrap(err, "client-properties table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	if l := len(f.Mechanism); l > math.MaxUint8 {
		return nil, errors.Errorf("mechanism can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Mechanism)
	}
	if l := len(f.Response); l > math.MaxUint32 {
		return nil, errors.Errorf("response can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Response)
	}
	if l := len(f.Locale); l > math.MaxUint8 {
		return nil, errors.Errorf("locale can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Locale)
	}
	return buf.Bytes(), nil
}

type ConnectionSecure struct {
	FrameMeta
	MethodMeta
	Challenge string
}

func (f *ConnectionSecure) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ConnectionSecure) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ConnectionSecure) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ConnectionSecure) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ConnectionSecureMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionSecureMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field challenge: read longstr failed")
	} else if n < 4 {
		return errors.New("field challenge: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field challenge: read longstr failed")
		}
		f.Challenge = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionSecure) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ConnectionClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ConnectionSecureMethod))
	buf.Write(x[:2])
	if l := len(f.Challenge); l > math.MaxUint32 {
		return nil, errors.Errorf("challenge can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Challenge)
	}
	return buf.Bytes(), nil
}

type ConnectionSecureOk struct {
	FrameMeta
	MethodMeta
	Response string
}

func (f *ConnectionSecureOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ConnectionSecureOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ConnectionSecureOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ConnectionSecureOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ConnectionSecureOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionSecureOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field response: read longstr failed")
	} else if n < 4 {
		return errors.New("field response: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field response: read longstr failed")
		}
		f.Response = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionSecureOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ConnectionClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ConnectionSecureOkMethod))
	buf.Write(x[:2])
	if l := len(f.Response); l > math.MaxUint32 {
		return nil, errors.Errorf("response can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Response)
	}
	return buf.Bytes(), nil
}

type ConnectionTune struct {
	FrameMeta
	MethodMeta
	ChannelMax uint16
	FrameMax   uint32
	Heartbeat  uint16
}

func (f *ConnectionTune) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ConnectionTune) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ConnectionTune) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ConnectionTune) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ConnectionTuneMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionTuneMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field channel-max: read short failed")
	} else if n < 2 {
		return errors.New("field channel-max: read short failed")
	}
	f.ChannelMax = endian.Uint16(x[:2])
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field frame-max: read long failed")
	} else if n < 4 {
		return errors.New("field frame-max: read long failed")
	}
	f.FrameMax = endian.Uint32(x[:4])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field heartbeat: read short failed")
	} else if n < 2 {
		return errors.New("field heartbeat: read short failed")
	}
	f.Heartbeat = endian.Uint16(x[:2])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionTune) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ConnectionClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ConnectionTuneMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.ChannelMax)
	buf.Write(x[:2])
	endian.PutUint32(x[:4], f.FrameMax)
	buf.Write(x[:4])
	endian.PutUint16(x[:2], f.Heartbeat)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ConnectionTuneOk struct {
	FrameMeta
	MethodMeta
	ChannelMax uint16
	FrameMax   uint32
	Heartbeat  uint16
}

func (f *ConnectionTuneOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ConnectionTuneOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ConnectionTuneOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ConnectionTuneOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ConnectionTuneOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionTuneOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field channel-max: read short failed")
	} else if n < 2 {
		return errors.New("field channel-max: read short failed")
	}
	f.ChannelMax = endian.Uint16(x[:2])
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field frame-max: read long failed")
	} else if n < 4 {
		return errors.New("field frame-max: read long failed")
	}
	f.FrameMax = endian.Uint32(x[:4])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field heartbeat: read short failed")
	} else if n < 2 {
		return errors.New("field heartbeat: read short failed")
	}
	f.Heartbeat = endian.Uint16(x[:2])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionTuneOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ConnectionClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ConnectionTuneOkMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.ChannelMax)
	buf.Write(x[:2])
	endian.PutUint32(x[:4], f.FrameMax)
	buf.Write(x[:4])
	endian.PutUint16(x[:2], f.Heartbeat)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ConnectionOpen struct {
	FrameMeta
	MethodMeta
	VirtualHost string
	Reserved1   string
	Reserved2   bool
}

func (f *ConnectionOpen) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ConnectionOpen) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ConnectionOpen) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ConnectionOpen) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ConnectionOpenMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionOpenMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field virtual-host: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field virtual-host: read shortstr failed")
		}
		f.VirtualHost = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reserved-1: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read shortstr failed")
		}
		f.Reserved1 = string(s)
	}
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Reserved2 = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionOpen) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ConnectionClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ConnectionOpenMethod))
	buf.Write(x[:2])
	if l := len(f.VirtualHost); l > math.MaxUint8 {
		return nil, errors.Errorf("virtual-host can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.VirtualHost)
	}
	if l := len(f.Reserved1); l > math.MaxUint8 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Reserved1)
	}
	if f.Reserved2 {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type ConnectionOpenOk struct {
	FrameMeta
	MethodMeta
	Reserved1 string
}

func (f *ConnectionOpenOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ConnectionOpenOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ConnectionOpenOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ConnectionOpenOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ConnectionOpenOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionOpenOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reserved-1: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read shortstr failed")
		}
		f.Reserved1 = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionOpenOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ConnectionClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ConnectionOpenOkMethod))
	buf.Write(x[:2])
	if l := len(f.Reserved1); l > math.MaxUint8 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Reserved1)
	}
	return buf.Bytes(), nil
}

type ConnectionClose struct {
	FrameMeta
	MethodMeta
	ReplyCode uint16
	ReplyText string
	ClassID   uint16
	MethodID  uint16
}

func (f *ConnectionClose) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ConnectionClose) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ConnectionClose) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ConnectionClose) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ConnectionCloseMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionCloseMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reply-code: read short failed")
	} else if n < 2 {
		return errors.New("field reply-code: read short failed")
	}
	f.ReplyCode = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reply-text: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reply-text: read shortstr failed")
		}
		f.ReplyText = string(s)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field class-id: read short failed")
	} else if n < 2 {
		return errors.New("field class-id: read short failed")
	}
	f.ClassID = endian.Uint16(x[:2])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field method-id: read short failed")
	} else if n < 2 {
		return errors.New("field method-id: read short failed")
	}
	f.MethodID = endian.Uint16(x[:2])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionClose) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ConnectionClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ConnectionCloseMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.ReplyCode)
	buf.Write(x[:2])
	if l := len(f.ReplyText); l > math.MaxUint8 {
		return nil, errors.Errorf("reply-text can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ReplyText)
	}
	endian.PutUint16(x[:2], f.ClassID)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.MethodID)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ConnectionCloseOk struct {
	FrameMeta
	MethodMeta
}

func (f *ConnectionCloseOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ConnectionCloseOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ConnectionCloseOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ConnectionCloseOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ConnectionCloseOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionCloseOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionCloseOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ConnectionClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ConnectionCloseOkMethod))
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ChannelOpen struct {
	FrameMeta
	MethodMeta
	Reserved1 string
}

func (f *ChannelOpen) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ChannelOpen) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ChannelOpen) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ChannelOpen) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ChannelClass {
		return errors.Errorf("expected class ID %d, got %d", ChannelClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ChannelOpenMethod {
		return errors.Errorf("expected method ID %d, got %d", ChannelOpenMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reserved-1: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read shortstr failed")
		}
		f.Reserved1 = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ChannelOpen) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ChannelClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ChannelOpenMethod))
	buf.Write(x[:2])
	if l := len(f.Reserved1); l > math.MaxUint8 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Reserved1)
	}
	return buf.Bytes(), nil
}

type ChannelOpenOk struct {
	FrameMeta
	MethodMeta
	Reserved1 string
}

func (f *ChannelOpenOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ChannelOpenOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ChannelOpenOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ChannelOpenOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ChannelClass {
		return errors.Errorf("expected class ID %d, got %d", ChannelClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ChannelOpenOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ChannelOpenOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field reserved-1: read longstr failed")
	} else if n < 4 {
		return errors.New("field reserved-1: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read longstr failed")
		}
		f.Reserved1 = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ChannelOpenOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ChannelClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ChannelOpenOkMethod))
	buf.Write(x[:2])
	if l := len(f.Reserved1); l > math.MaxUint32 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Reserved1)
	}
	return buf.Bytes(), nil
}

type ChannelFlow struct {
	FrameMeta
	MethodMeta
	Active bool
}

func (f *ChannelFlow) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ChannelFlow) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ChannelFlow) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ChannelFlow) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ChannelClass {
		return errors.Errorf("expected class ID %d, got %d", ChannelClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ChannelFlowMethod {
		return errors.Errorf("expected method ID %d, got %d", ChannelFlowMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Active = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ChannelFlow) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ChannelClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ChannelFlowMethod))
	buf.Write(x[:2])
	if f.Active {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type ChannelFlowOk struct {
	FrameMeta
	MethodMeta
	Active bool
}

func (f *ChannelFlowOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ChannelFlowOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ChannelFlowOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ChannelFlowOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ChannelClass {
		return errors.Errorf("expected class ID %d, got %d", ChannelClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ChannelFlowOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ChannelFlowOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Active = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ChannelFlowOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ChannelClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ChannelFlowOkMethod))
	buf.Write(x[:2])
	if f.Active {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type ChannelClose struct {
	FrameMeta
	MethodMeta
	ReplyCode uint16
	ReplyText string
	ClassID   uint16
	MethodID  uint16
}

func (f *ChannelClose) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ChannelClose) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ChannelClose) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ChannelClose) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ChannelClass {
		return errors.Errorf("expected class ID %d, got %d", ChannelClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ChannelCloseMethod {
		return errors.Errorf("expected method ID %d, got %d", ChannelCloseMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reply-code: read short failed")
	} else if n < 2 {
		return errors.New("field reply-code: read short failed")
	}
	f.ReplyCode = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reply-text: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reply-text: read shortstr failed")
		}
		f.ReplyText = string(s)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field class-id: read short failed")
	} else if n < 2 {
		return errors.New("field class-id: read short failed")
	}
	f.ClassID = endian.Uint16(x[:2])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field method-id: read short failed")
	} else if n < 2 {
		return errors.New("field method-id: read short failed")
	}
	f.MethodID = endian.Uint16(x[:2])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ChannelClose) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ChannelClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ChannelCloseMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.ReplyCode)
	buf.Write(x[:2])
	if l := len(f.ReplyText); l > math.MaxUint8 {
		return nil, errors.Errorf("reply-text can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ReplyText)
	}
	endian.PutUint16(x[:2], f.ClassID)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.MethodID)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ChannelCloseOk struct {
	FrameMeta
	MethodMeta
}

func (f *ChannelCloseOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ChannelCloseOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ChannelCloseOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ChannelCloseOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ChannelClass {
		return errors.Errorf("expected class ID %d, got %d", ChannelClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ChannelCloseOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ChannelCloseOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ChannelCloseOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ChannelClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ChannelCloseOkMethod))
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ExchangeDeclare struct {
	FrameMeta
	MethodMeta
	Reserved1 uint16
	Exchange  string
	Type      string
	Passive   bool
	Durable   bool
	Reserved2 bool
	Reserved3 bool
	NoWait    bool
	Arguments *types.Struct
}

func (f *ExchangeDeclare) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ExchangeDeclare) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ExchangeDeclare) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ExchangeDeclare) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ExchangeClass {
		return errors.Errorf("expected class ID %d, got %d", ExchangeClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ExchangeDeclareMethod {
		return errors.Errorf("expected method ID %d, got %d", ExchangeDeclareMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field type: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field type: read shortstr failed")
		}
		f.Type = string(s)
	}

	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Passive = bits&1 == 1
		f.Durable = bits&2 == 2
		f.Reserved2 = bits&4 == 4
		f.Reserved3 = bits&8 == 8
		f.NoWait = bits&16 == 16
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ExchangeDeclare) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ExchangeClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ExchangeDeclareMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.Type); l > math.MaxUint8 {
		return nil, errors.Errorf("type can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Type)
	}
	if f.Passive {
		bits |= 1
	}

	if f.Durable {
		bits |= 2
	}

	if f.Reserved2 {
		bits |= 4
	}

	if f.Reserved3 {
		bits |= 8
	}

	if f.NoWait {
		bits |= 16
	}
	buf.WriteByte(bits)
	bits = 0
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type ExchangeDeclareOk struct {
	FrameMeta
	MethodMeta
}

func (f *ExchangeDeclareOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ExchangeDeclareOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ExchangeDeclareOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ExchangeDeclareOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ExchangeClass {
		return errors.Errorf("expected class ID %d, got %d", ExchangeClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ExchangeDeclareOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ExchangeDeclareOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ExchangeDeclareOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ExchangeClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ExchangeDeclareOkMethod))
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ExchangeDelete struct {
	FrameMeta
	MethodMeta
	Reserved1 uint16
	Exchange  string
	IfUnused  bool
	NoWait    bool
}

func (f *ExchangeDelete) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ExchangeDelete) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ExchangeDelete) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ExchangeDelete) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ExchangeClass {
		return errors.Errorf("expected class ID %d, got %d", ExchangeClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ExchangeDeleteMethod {
		return errors.Errorf("expected method ID %d, got %d", ExchangeDeleteMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}

	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.IfUnused = (bits & 1) == 1
		f.NoWait = (bits & 2) == 2
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ExchangeDelete) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ExchangeClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ExchangeDeleteMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if f.IfUnused {
		bits |= 1
	}

	if f.NoWait {
		bits |= 2
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type ExchangeDeleteOk struct {
	FrameMeta
	MethodMeta
}

func (f *ExchangeDeleteOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ExchangeDeleteOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *ExchangeDeleteOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *ExchangeDeleteOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != ExchangeClass {
		return errors.Errorf("expected class ID %d, got %d", ExchangeClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != ExchangeDeleteOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ExchangeDeleteOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ExchangeDeleteOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(ExchangeClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(ExchangeDeleteOkMethod))
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type QueueDeclare struct {
	FrameMeta
	MethodMeta
	Reserved1  uint16
	Queue      string
	Passive    bool
	Durable    bool
	Exclusive  bool
	AutoDelete bool
	NoWait     bool
	Arguments  *types.Struct
}

func (f *QueueDeclare) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *QueueDeclare) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *QueueDeclare) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *QueueDeclare) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != QueueDeclareMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueDeclareMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}

	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Passive = bits&1 == 1
		f.Durable = bits&2 == 2
		f.Exclusive = bits&4 == 4
		f.AutoDelete = bits&8 == 8
		f.NoWait = bits&16 == 16
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueDeclare) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(QueueClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(QueueDeclareMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if f.Passive {
		bits |= 1
	}

	if f.Durable {
		bits |= 2
	}

	if f.Exclusive {
		bits |= 4
	}

	if f.AutoDelete {
		bits |= 8
	}

	if f.NoWait {
		bits |= 16
	}
	buf.WriteByte(bits)
	bits = 0
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type QueueDeclareOk struct {
	FrameMeta
	MethodMeta
	Queue         string
	MessageCount  uint32
	ConsumerCount uint32
}

func (f *QueueDeclareOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *QueueDeclareOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *QueueDeclareOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *QueueDeclareOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != QueueDeclareOkMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueDeclareOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field message-count: read long failed")
	} else if n < 4 {
		return errors.New("field message-count: read long failed")
	}
	f.MessageCount = endian.Uint32(x[:4])
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field consumer-count: read long failed")
	} else if n < 4 {
		return errors.New("field consumer-count: read long failed")
	}
	f.ConsumerCount = endian.Uint32(x[:4])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueDeclareOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(QueueClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(QueueDeclareOkMethod))
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	endian.PutUint32(x[:4], f.MessageCount)
	buf.Write(x[:4])
	endian.PutUint32(x[:4], f.ConsumerCount)
	buf.Write(x[:4])
	return buf.Bytes(), nil
}

type QueueBind struct {
	FrameMeta
	MethodMeta
	Reserved1  uint16
	Queue      string
	Exchange   string
	RoutingKey string
	NoWait     bool
	Arguments  *types.Struct
}

func (f *QueueBind) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *QueueBind) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *QueueBind) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *QueueBind) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != QueueBindMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueBindMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.NoWait = bits&1 == 1
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueBind) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(QueueClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(QueueBindMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	if f.NoWait {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type QueueBindOk struct {
	FrameMeta
	MethodMeta
}

func (f *QueueBindOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *QueueBindOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *QueueBindOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *QueueBindOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != QueueBindOkMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueBindOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueBindOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(QueueClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(QueueBindOkMethod))
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type QueueUnbind struct {
	FrameMeta
	MethodMeta
	Reserved1  uint16
	Queue      string
	Exchange   string
	RoutingKey string
	Arguments  *types.Struct
}

func (f *QueueUnbind) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *QueueUnbind) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *QueueUnbind) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *QueueUnbind) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != QueueUnbindMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueUnbindMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueUnbind) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(QueueClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(QueueUnbindMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type QueueUnbindOk struct {
	FrameMeta
	MethodMeta
}

func (f *QueueUnbindOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *QueueUnbindOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *QueueUnbindOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *QueueUnbindOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != QueueUnbindOkMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueUnbindOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueUnbindOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(QueueClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(QueueUnbindOkMethod))
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type QueuePurge struct {
	FrameMeta
	MethodMeta
	Reserved1 uint16
	Queue     string
	NoWait    bool
}

func (f *QueuePurge) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *QueuePurge) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *QueuePurge) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *QueuePurge) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != QueuePurgeMethod {
		return errors.Errorf("expected method ID %d, got %d", QueuePurgeMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.NoWait = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueuePurge) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(QueueClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(QueuePurgeMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if f.NoWait {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type QueuePurgeOk struct {
	FrameMeta
	MethodMeta
	MessageCount uint32
}

func (f *QueuePurgeOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *QueuePurgeOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *QueuePurgeOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *QueuePurgeOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != QueuePurgeOkMethod {
		return errors.Errorf("expected method ID %d, got %d", QueuePurgeOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field message-count: read long failed")
	} else if n < 4 {
		return errors.New("field message-count: read long failed")
	}
	f.MessageCount = endian.Uint32(x[:4])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueuePurgeOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(QueueClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(QueuePurgeOkMethod))
	buf.Write(x[:2])
	endian.PutUint32(x[:4], f.MessageCount)
	buf.Write(x[:4])
	return buf.Bytes(), nil
}

type QueueDelete struct {
	FrameMeta
	MethodMeta
	Reserved1 uint16
	Queue     string
	IfUnused  bool
	IfEmpty   bool
	NoWait    bool
}

func (f *QueueDelete) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *QueueDelete) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *QueueDelete) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *QueueDelete) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != QueueDeleteMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueDeleteMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}

	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.IfUnused = (bits & 1) == 1
		f.IfEmpty = (bits & 2) == 2
		f.NoWait = (bits & 4) == 4
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueDelete) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(QueueClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(QueueDeleteMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if f.IfUnused {
		bits |= 1
	}

	if f.IfEmpty {
		bits |= 2
	}

	if f.NoWait {
		bits |= 4
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type QueueDeleteOk struct {
	FrameMeta
	MethodMeta
	MessageCount uint32
}

func (f *QueueDeleteOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *QueueDeleteOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *QueueDeleteOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *QueueDeleteOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != QueueDeleteOkMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueDeleteOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field message-count: read long failed")
	} else if n < 4 {
		return errors.New("field message-count: read long failed")
	}
	f.MessageCount = endian.Uint32(x[:4])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueDeleteOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(QueueClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(QueueDeleteOkMethod))
	buf.Write(x[:2])
	endian.PutUint32(x[:4], f.MessageCount)
	buf.Write(x[:4])
	return buf.Bytes(), nil
}

type ContentHeaderFrame struct {
	FrameMeta
	ClassID         ClassID
	Weight          uint16
	BodySize        uint64
	ContentType     string
	ContentEncoding string
	Headers         *types.Struct
	DeliveryMode    uint8
	Priority        uint8
	CorrelationID   string
	ReplyTo         string
	Expiration      string
	MessageID       string
	Timestamp       time.Time
	Type            string
	UserID          string
	AppID           string
	Reserved        string
}

func (f *ContentHeaderFrame) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *ContentHeaderFrame) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.ClassID = id
	}

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read weight failed")
	} else if n < 2 {
		return errors.New("read weight failed")
	}
	f.Weight = endian.Uint16(x[:2])

	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "read body size failed")
	} else if n < 8 {
		return errors.New("read body size failed")
	}
	f.BodySize = endian.Uint64(x[:8])

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read flags failed")
	} else if n < 2 {
		return errors.New("read flags failed")
	}
	flags := endian.Uint16(x[:2])

	if flags&1 == 1 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field content-type: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field content-type: read shortstr failed")
			}
			f.ContentType = string(s)
		}
	}

	if flags&2 == 2 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field content-encoding: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field content-encoding: read shortstr failed")
			}
			f.ContentEncoding = string(s)
		}
	}

	if flags&4 == 4 {
		if n, err := buf.Read(x[:4]); err != nil {
			return errors.Wrap(err, "field headers: read table failed")
		} else if n < 4 {
			return errors.New("field headers: read table failed")
		} else {
			l := int(endian.Uint32(x[:4]))
			b := buf.Next(l)
			if len(b) < l {
				return errors.New("field headers: read table failed")
			}
			if f.Headers, err = unmarshalTable(b); err != nil {
				return errors.Wrap(err, "field headers: read table failed")
			}
		}
	}

	if flags&8 == 8 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field delivery-mode: read octet failed")
		} else {
			f.DeliveryMode = b
		}
	}

	if flags&16 == 16 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field priority: read octet failed")
		} else {
			f.Priority = b
		}
	}

	if flags&32 == 32 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field correlation-id: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field correlation-id: read shortstr failed")
			}
			f.CorrelationID = string(s)
		}
	}

	if flags&64 == 64 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field reply-to: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field reply-to: read shortstr failed")
			}
			f.ReplyTo = string(s)
		}
	}

	if flags&128 == 128 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field expiration: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field expiration: read shortstr failed")
			}
			f.Expiration = string(s)
		}
	}

	if flags&256 == 256 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field message-id: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field message-id: read shortstr failed")
			}
			f.MessageID = string(s)
		}
	}

	if flags&512 == 512 {
		if n, err := buf.Read(x[:8]); err != nil {
			return errors.Wrap(err, "field timestamp: read timestamp failed")
		} else if n < 8 {
			return errors.New("field timestamp: read timestamp failed")
		}
		f.Timestamp = time.Unix(int64(endian.Uint64(x[:8])), 0)
	}

	if flags&1024 == 1024 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field type: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field type: read shortstr failed")
			}
			f.Type = string(s)
		}
	}

	if flags&2048 == 2048 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field user-id: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field user-id: read shortstr failed")
			}
			f.UserID = string(s)
		}
	}

	if flags&4096 == 4096 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field app-id: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field app-id: read shortstr failed")
			}
			f.AppID = string(s)
		}
	}

	if flags&8192 == 8192 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field reserved: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field reserved: read shortstr failed")
			}
			f.Reserved = string(s)
		}
	}

	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}

	return nil
}

func (f *ContentHeaderFrame) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var flags uint16
	buf := bytes.Buffer{}

	if f.ContentType != "" {
		flags |= 1

		if l := len(f.ContentType); l > math.MaxUint8 {
			return nil, errors.Errorf("content-type can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.ContentType)
		}
	}

	if f.ContentEncoding != "" {
		flags |= 2

		if l := len(f.ContentEncoding); l > math.MaxUint8 {
			return nil, errors.Errorf("content-encoding can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.ContentEncoding)
		}
	}

	if f.Headers != nil {
		flags |= 4

		if tableBuf, err := marshalTable(f.Headers); err != nil {
			return nil, errors.Wrap(err, "headers table marshal failed")
		} else {
			endian.PutUint32(x[:4], uint32(len(tableBuf)))
			buf.Write(x[:4])
			buf.Write(tableBuf)
		}
	}

	if f.DeliveryMode > 0 {
		flags |= 8

		buf.WriteByte(f.DeliveryMode)
	}

	if f.Priority > 0 {
		flags |= 16

		buf.WriteByte(f.Priority)
	}

	if f.CorrelationID != "" {
		flags |= 32

		if l := len(f.CorrelationID); l > math.MaxUint8 {
			return nil, errors.Errorf("correlation-id can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.CorrelationID)
		}
	}

	if f.ReplyTo != "" {
		flags |= 64

		if l := len(f.ReplyTo); l > math.MaxUint8 {
			return nil, errors.Errorf("reply-to can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.ReplyTo)
		}
	}

	if f.Expiration != "" {
		flags |= 128

		if l := len(f.Expiration); l > math.MaxUint8 {
			return nil, errors.Errorf("expiration can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.Expiration)
		}
	}

	if f.MessageID != "" {
		flags |= 256

		if l := len(f.MessageID); l > math.MaxUint8 {
			return nil, errors.Errorf("message-id can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.MessageID)
		}
	}

	if !f.Timestamp.IsZero() {
		flags |= 512

		endian.PutUint64(x[:8], uint64(f.Timestamp.Unix()))
		buf.Write(x[:8])
	}

	if f.Type != "" {
		flags |= 1024

		if l := len(f.Type); l > math.MaxUint8 {
			return nil, errors.Errorf("type can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.Type)
		}
	}

	if f.UserID != "" {
		flags |= 2048

		if l := len(f.UserID); l > math.MaxUint8 {
			return nil, errors.Errorf("user-id can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.UserID)
		}
	}

	if f.AppID != "" {
		flags |= 4096

		if l := len(f.AppID); l > math.MaxUint8 {
			return nil, errors.Errorf("app-id can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.AppID)
		}
	}

	if f.Reserved != "" {
		flags |= 8192

		if l := len(f.Reserved); l > math.MaxUint8 {
			return nil, errors.Errorf("reserved can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.Reserved)
		}
	}

	ret := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(f.ClassID))
	ret.Write(x[:2])
	endian.PutUint16(x[:2], f.Weight)
	ret.Write(x[:2])
	endian.PutUint64(x[:8], f.BodySize)
	ret.Write(x[:8])
	endian.PutUint16(x[:2], flags)
	ret.Write(x[:2])
	ret.Write(buf.Bytes())

	return ret.Bytes(), nil
}

type BasicQos struct {
	FrameMeta
	MethodMeta
	PrefetchSize  uint32
	PrefetchCount uint16
	Global        bool
}

func (f *BasicQos) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicQos) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicQos) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicQos) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicQosMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicQosMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field prefetch-size: read long failed")
	} else if n < 4 {
		return errors.New("field prefetch-size: read long failed")
	}
	f.PrefetchSize = endian.Uint32(x[:4])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field prefetch-count: read short failed")
	} else if n < 2 {
		return errors.New("field prefetch-count: read short failed")
	}
	f.PrefetchCount = endian.Uint16(x[:2])
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Global = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicQos) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicQosMethod))
	buf.Write(x[:2])
	endian.PutUint32(x[:4], f.PrefetchSize)
	buf.Write(x[:4])
	endian.PutUint16(x[:2], f.PrefetchCount)
	buf.Write(x[:2])
	if f.Global {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicQosOk struct {
	FrameMeta
	MethodMeta
}

func (f *BasicQosOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicQosOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicQosOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicQosOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicQosOkMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicQosOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicQosOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicQosOkMethod))
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type BasicConsume struct {
	FrameMeta
	MethodMeta
	Reserved1   uint16
	Queue       string
	ConsumerTag string
	NoLocal     bool
	NoAck       bool
	Exclusive   bool
	NoWait      bool
	Arguments   *types.Struct
}

func (f *BasicConsume) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicConsume) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicConsume) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicConsume) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicConsumeMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicConsumeMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}

	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.NoLocal = bits&1 == 1
		f.NoAck = bits&2 == 2
		f.Exclusive = bits&4 == 4
		f.NoWait = bits&8 == 8
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicConsume) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicConsumeMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	if f.NoLocal {
		bits |= 1
	}

	if f.NoAck {
		bits |= 2
	}

	if f.Exclusive {
		bits |= 4
	}

	if f.NoWait {
		bits |= 8
	}
	buf.WriteByte(bits)
	bits = 0
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type BasicConsumeOk struct {
	FrameMeta
	MethodMeta
	ConsumerTag string
}

func (f *BasicConsumeOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicConsumeOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicConsumeOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicConsumeOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicConsumeOkMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicConsumeOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicConsumeOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicConsumeOkMethod))
	buf.Write(x[:2])
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	return buf.Bytes(), nil
}

type BasicCancel struct {
	FrameMeta
	MethodMeta
	ConsumerTag string
	NoWait      bool
}

func (f *BasicCancel) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicCancel) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicCancel) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicCancel) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicCancelMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicCancelMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.NoWait = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicCancel) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicCancelMethod))
	buf.Write(x[:2])
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	if f.NoWait {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicCancelOk struct {
	FrameMeta
	MethodMeta
	ConsumerTag string
}

func (f *BasicCancelOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicCancelOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicCancelOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicCancelOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicCancelOkMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicCancelOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicCancelOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicCancelOkMethod))
	buf.Write(x[:2])
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	return buf.Bytes(), nil
}

type BasicPublish struct {
	FrameMeta
	MethodMeta
	Reserved1  uint16
	Exchange   string
	RoutingKey string
	Mandatory  bool
	Immediate  bool
}

func (f *BasicPublish) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicPublish) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicPublish) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicPublish) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicPublishMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicPublishMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}

	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Mandatory = (bits & 1) == 1
		f.Immediate = (bits & 2) == 2
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicPublish) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicPublishMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	if f.Mandatory {
		bits |= 1
	}

	if f.Immediate {
		bits |= 2
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicReturn struct {
	FrameMeta
	MethodMeta
	ReplyCode  uint16
	ReplyText  string
	Exchange   string
	RoutingKey string
}

func (f *BasicReturn) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicReturn) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicReturn) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicReturn) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicReturnMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicReturnMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reply-code: read short failed")
	} else if n < 2 {
		return errors.New("field reply-code: read short failed")
	}
	f.ReplyCode = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reply-text: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reply-text: read shortstr failed")
		}
		f.ReplyText = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicReturn) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicReturnMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.ReplyCode)
	buf.Write(x[:2])
	if l := len(f.ReplyText); l > math.MaxUint8 {
		return nil, errors.Errorf("reply-text can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ReplyText)
	}
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	return buf.Bytes(), nil
}

type BasicDeliver struct {
	FrameMeta
	MethodMeta
	ConsumerTag string
	DeliveryTag uint64
	Redelivered bool
	Exchange    string
	RoutingKey  string
}

func (f *BasicDeliver) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicDeliver) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicDeliver) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicDeliver) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicDeliverMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicDeliverMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}
	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "field delivery-tag: read longlong failed")
	} else if n < 8 {
		return errors.New("field delivery-tag: read longlong failed")
	}
	f.DeliveryTag = endian.Uint64(x[:8])
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Redelivered = bits&1 == 1
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicDeliver) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicDeliverMethod))
	buf.Write(x[:2])
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	endian.PutUint64(x[:8], f.DeliveryTag)
	buf.Write(x[:8])
	if f.Redelivered {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	return buf.Bytes(), nil
}

type BasicGet struct {
	FrameMeta
	MethodMeta
	Reserved1 uint16
	Queue     string
	NoAck     bool
}

func (f *BasicGet) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicGet) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicGet) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicGet) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicGetMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicGetMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.NoAck = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicGet) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicGetMethod))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if f.NoAck {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicGetOk struct {
	FrameMeta
	MethodMeta
	DeliveryTag  uint64
	Redelivered  bool
	Exchange     string
	RoutingKey   string
	MessageCount uint32
}

func (f *BasicGetOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicGetOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicGetOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicGetOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicGetOkMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicGetOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "field delivery-tag: read longlong failed")
	} else if n < 8 {
		return errors.New("field delivery-tag: read longlong failed")
	}
	f.DeliveryTag = endian.Uint64(x[:8])
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Redelivered = bits&1 == 1
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field message-count: read long failed")
	} else if n < 4 {
		return errors.New("field message-count: read long failed")
	}
	f.MessageCount = endian.Uint32(x[:4])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicGetOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicGetOkMethod))
	buf.Write(x[:2])
	endian.PutUint64(x[:8], f.DeliveryTag)
	buf.Write(x[:8])
	if f.Redelivered {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	endian.PutUint32(x[:4], f.MessageCount)
	buf.Write(x[:4])
	return buf.Bytes(), nil
}

type BasicGetEmpty struct {
	FrameMeta
	MethodMeta
	Reserved1 string
}

func (f *BasicGetEmpty) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicGetEmpty) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicGetEmpty) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicGetEmpty) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicGetEmptyMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicGetEmptyMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reserved-1: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read shortstr failed")
		}
		f.Reserved1 = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicGetEmpty) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicGetEmptyMethod))
	buf.Write(x[:2])
	if l := len(f.Reserved1); l > math.MaxUint8 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Reserved1)
	}
	return buf.Bytes(), nil
}

type BasicAck struct {
	FrameMeta
	MethodMeta
	DeliveryTag uint64
	Multiple    bool
}

func (f *BasicAck) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicAck) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicAck) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicAck) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicAckMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicAckMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "field delivery-tag: read longlong failed")
	} else if n < 8 {
		return errors.New("field delivery-tag: read longlong failed")
	}
	f.DeliveryTag = endian.Uint64(x[:8])
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Multiple = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicAck) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicAckMethod))
	buf.Write(x[:2])
	endian.PutUint64(x[:8], f.DeliveryTag)
	buf.Write(x[:8])
	if f.Multiple {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicReject struct {
	FrameMeta
	MethodMeta
	DeliveryTag uint64
	Requeue     bool
}

func (f *BasicReject) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicReject) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicReject) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicReject) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicRejectMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicRejectMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "field delivery-tag: read longlong failed")
	} else if n < 8 {
		return errors.New("field delivery-tag: read longlong failed")
	}
	f.DeliveryTag = endian.Uint64(x[:8])
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Requeue = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicReject) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicRejectMethod))
	buf.Write(x[:2])
	endian.PutUint64(x[:8], f.DeliveryTag)
	buf.Write(x[:8])
	if f.Requeue {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicRecoverAsync struct {
	FrameMeta
	MethodMeta
	Requeue bool
}

func (f *BasicRecoverAsync) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicRecoverAsync) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicRecoverAsync) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicRecoverAsync) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicRecoverAsyncMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicRecoverAsyncMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Requeue = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicRecoverAsync) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicRecoverAsyncMethod))
	buf.Write(x[:2])
	if f.Requeue {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicRecover struct {
	FrameMeta
	MethodMeta
	Requeue bool
}

func (f *BasicRecover) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicRecover) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicRecover) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicRecover) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicRecoverMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicRecoverMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Requeue = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicRecover) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicRecoverMethod))
	buf.Write(x[:2])
	if f.Requeue {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicRecoverOk struct {
	FrameMeta
	MethodMeta
}

func (f *BasicRecoverOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *BasicRecoverOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *BasicRecoverOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *BasicRecoverOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != BasicRecoverOkMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicRecoverOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicRecoverOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(BasicClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(BasicRecoverOkMethod))
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type TxSelect struct {
	FrameMeta
	MethodMeta
}

func (f *TxSelect) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *TxSelect) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *TxSelect) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *TxSelect) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != TxClass {
		return errors.Errorf("expected class ID %d, got %d", TxClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != TxSelectMethod {
		return errors.Errorf("expected method ID %d, got %d", TxSelectMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *TxSelect) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(TxClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(TxSelectMethod))
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type TxSelectOk struct {
	FrameMeta
	MethodMeta
}

func (f *TxSelectOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *TxSelectOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *TxSelectOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *TxSelectOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != TxClass {
		return errors.Errorf("expected class ID %d, got %d", TxClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != TxSelectOkMethod {
		return errors.Errorf("expected method ID %d, got %d", TxSelectOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *TxSelectOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(TxClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(TxSelectOkMethod))
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type TxCommit struct {
	FrameMeta
	MethodMeta
}

func (f *TxCommit) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *TxCommit) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *TxCommit) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *TxCommit) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != TxClass {
		return errors.Errorf("expected class ID %d, got %d", TxClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != TxCommitMethod {
		return errors.Errorf("expected method ID %d, got %d", TxCommitMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *TxCommit) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(TxClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(TxCommitMethod))
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type TxCommitOk struct {
	FrameMeta
	MethodMeta
}

func (f *TxCommitOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *TxCommitOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *TxCommitOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *TxCommitOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != TxClass {
		return errors.Errorf("expected class ID %d, got %d", TxClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != TxCommitOkMethod {
		return errors.Errorf("expected method ID %d, got %d", TxCommitOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *TxCommitOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(TxClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(TxCommitOkMethod))
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type TxRollback struct {
	FrameMeta
	MethodMeta
}

func (f *TxRollback) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *TxRollback) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *TxRollback) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *TxRollback) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != TxClass {
		return errors.Errorf("expected class ID %d, got %d", TxClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != TxRollbackMethod {
		return errors.Errorf("expected method ID %d, got %d", TxRollbackMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *TxRollback) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(TxClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(TxRollbackMethod))
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type TxRollbackOk struct {
	FrameMeta
	MethodMeta
}

func (f *TxRollbackOk) FrameType() FrameType {
	return f.FrameMeta.Type
}

func (f *TxRollbackOk) FrameClassID() ClassID {
	return f.MethodMeta.ClassID
}

func (f *TxRollbackOk) FrameMethodID() MethodID {
	return f.MethodMeta.MethodID
}

func (f *TxRollbackOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != TxClass {
		return errors.Errorf("expected class ID %d, got %d", TxClass, id)
	} else {
		f.MethodMeta.ClassID = id
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := MethodID(endian.Uint16(x[:2])); id != TxRollbackOkMethod {
		return errors.Errorf("expected method ID %d, got %d", TxRollbackOkMethod, id)
	} else {
		f.MethodMeta.MethodID = id
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *TxRollbackOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(TxClass))
	buf.Write(x[:2])
	endian.PutUint16(x[:2], uint16(TxRollbackOkMethod))
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

func decodeMethodFrame(frameMeta FrameMeta, data []byte) (MethodFrame, error) {
	if len(data) < 4 {
		return nil, errors.New("method frame too short")
	}

	classID := ClassID(endian.Uint16(data[0:2]))
	methodID := MethodID(endian.Uint16(data[2:4]))

	switch classID {
	case ConnectionClass:
		switch methodID {
		case ConnectionStartMethod:
			f := &ConnectionStart{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ConnectionStartOkMethod:
			f := &ConnectionStartOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ConnectionSecureMethod:
			f := &ConnectionSecure{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ConnectionSecureOkMethod:
			f := &ConnectionSecureOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ConnectionTuneMethod:
			f := &ConnectionTune{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ConnectionTuneOkMethod:
			f := &ConnectionTuneOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ConnectionOpenMethod:
			f := &ConnectionOpen{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ConnectionOpenOkMethod:
			f := &ConnectionOpenOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ConnectionCloseMethod:
			f := &ConnectionClose{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ConnectionCloseOkMethod:
			f := &ConnectionCloseOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		default:
			return nil, errors.Errorf("unhandled method ID %d of class connection", methodID)
		}

	case ChannelClass:
		switch methodID {
		case ChannelOpenMethod:
			f := &ChannelOpen{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ChannelOpenOkMethod:
			f := &ChannelOpenOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ChannelFlowMethod:
			f := &ChannelFlow{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ChannelFlowOkMethod:
			f := &ChannelFlowOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ChannelCloseMethod:
			f := &ChannelClose{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ChannelCloseOkMethod:
			f := &ChannelCloseOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		default:
			return nil, errors.Errorf("unhandled method ID %d of class channel", methodID)
		}

	case ExchangeClass:
		switch methodID {
		case ExchangeDeclareMethod:
			f := &ExchangeDeclare{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ExchangeDeclareOkMethod:
			f := &ExchangeDeclareOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ExchangeDeleteMethod:
			f := &ExchangeDelete{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case ExchangeDeleteOkMethod:
			f := &ExchangeDeleteOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		default:
			return nil, errors.Errorf("unhandled method ID %d of class exchange", methodID)
		}

	case QueueClass:
		switch methodID {
		case QueueDeclareMethod:
			f := &QueueDeclare{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case QueueDeclareOkMethod:
			f := &QueueDeclareOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case QueueBindMethod:
			f := &QueueBind{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case QueueBindOkMethod:
			f := &QueueBindOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case QueueUnbindMethod:
			f := &QueueUnbind{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case QueueUnbindOkMethod:
			f := &QueueUnbindOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case QueuePurgeMethod:
			f := &QueuePurge{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case QueuePurgeOkMethod:
			f := &QueuePurgeOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case QueueDeleteMethod:
			f := &QueueDelete{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case QueueDeleteOkMethod:
			f := &QueueDeleteOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		default:
			return nil, errors.Errorf("unhandled method ID %d of class queue", methodID)
		}

	case BasicClass:
		switch methodID {
		case BasicQosMethod:
			f := &BasicQos{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicQosOkMethod:
			f := &BasicQosOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicConsumeMethod:
			f := &BasicConsume{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicConsumeOkMethod:
			f := &BasicConsumeOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicCancelMethod:
			f := &BasicCancel{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicCancelOkMethod:
			f := &BasicCancelOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicPublishMethod:
			f := &BasicPublish{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicReturnMethod:
			f := &BasicReturn{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicDeliverMethod:
			f := &BasicDeliver{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicGetMethod:
			f := &BasicGet{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicGetOkMethod:
			f := &BasicGetOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicGetEmptyMethod:
			f := &BasicGetEmpty{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicAckMethod:
			f := &BasicAck{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicRejectMethod:
			f := &BasicReject{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicRecoverAsyncMethod:
			f := &BasicRecoverAsync{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicRecoverMethod:
			f := &BasicRecover{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case BasicRecoverOkMethod:
			f := &BasicRecoverOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		default:
			return nil, errors.Errorf("unhandled method ID %d of class basic", methodID)
		}

	case TxClass:
		switch methodID {
		case TxSelectMethod:
			f := &TxSelect{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case TxSelectOkMethod:
			f := &TxSelectOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case TxCommitMethod:
			f := &TxCommit{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case TxCommitOkMethod:
			f := &TxCommitOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case TxRollbackMethod:
			f := &TxRollback{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		case TxRollbackOkMethod:
			f := &TxRollbackOk{FrameMeta: frameMeta}
			return f, f.Unmarshal(data)

		default:
			return nil, errors.Errorf("unhandled method ID %d of class tx", methodID)
		}

	default:
		return nil, errors.Errorf("unhandled class ID %d", classID)
	}
}
