// Code generated by ./generator/main.go. DO NOT EDIT.
package v0

//go:generate go run ./generator/main.go ./amqp0-9-1.stripped.xml ./amqp.spec.go

import (
	"bytes"
	"encoding/binary"
	"math"
	"time"

	"github.com/gogo/protobuf/types"
	"github.com/pkg/errors"
)

const (
	Major              = 0
	Minor              = 9
	Revision           = 1
	Port               = 5672
	FrameMethod        = 1
	FrameHeader        = 2
	FrameBody          = 3
	FrameHeartbeat     = 8
	FrameMinSize       = 4096
	FrameEnd           = 206
	ReplySuccess       = 200
	ContentTooLarge    = 311
	NoConsumers        = 313
	ConnectionForced   = 320
	InvalidPath        = 402
	AccessRefused      = 403
	NotFound           = 404
	ResourceLocked     = 405
	PreconditionFailed = 406
	FrameError         = 501
	SyntaxError        = 502
	CommandInvalid     = 503
	ChannelError       = 504
	UnexpectedFrame    = 505
	ResourceError      = 506
	NotAllowed         = 530
	NotImplemented     = 540
	InternalError      = 541

	ConnectionClass          = 10
	ConnectionStartMethod    = 10
	ConnectionStartOkMethod  = 11
	ConnectionSecureMethod   = 20
	ConnectionSecureOkMethod = 21
	ConnectionTuneMethod     = 30
	ConnectionTuneOkMethod   = 31
	ConnectionOpenMethod     = 40
	ConnectionOpenOkMethod   = 41
	ConnectionCloseMethod    = 50
	ConnectionCloseOkMethod  = 51

	ChannelClass         = 20
	ChannelOpenMethod    = 10
	ChannelOpenOkMethod  = 11
	ChannelFlowMethod    = 20
	ChannelFlowOkMethod  = 21
	ChannelCloseMethod   = 40
	ChannelCloseOkMethod = 41

	ExchangeClass           = 40
	ExchangeDeclareMethod   = 10
	ExchangeDeclareOkMethod = 11
	ExchangeDeleteMethod    = 20
	ExchangeDeleteOkMethod  = 21

	QueueClass           = 50
	QueueDeclareMethod   = 10
	QueueDeclareOkMethod = 11
	QueueBindMethod      = 20
	QueueBindOkMethod    = 21
	QueueUnbindMethod    = 50
	QueueUnbindOkMethod  = 51
	QueuePurgeMethod     = 30
	QueuePurgeOkMethod   = 31
	QueueDeleteMethod    = 40
	QueueDeleteOkMethod  = 41

	BasicClass              = 60
	BasicQosMethod          = 10
	BasicQosOkMethod        = 11
	BasicConsumeMethod      = 20
	BasicConsumeOkMethod    = 21
	BasicCancelMethod       = 30
	BasicCancelOkMethod     = 31
	BasicPublishMethod      = 40
	BasicReturnMethod       = 50
	BasicDeliverMethod      = 60
	BasicGetMethod          = 70
	BasicGetOkMethod        = 71
	BasicGetEmptyMethod     = 72
	BasicAckMethod          = 80
	BasicRejectMethod       = 90
	BasicRecoverAsyncMethod = 100
	BasicRecoverMethod      = 110
	BasicRecoverOkMethod    = 111

	TxClass            = 90
	TxSelectMethod     = 10
	TxSelectOkMethod   = 11
	TxCommitMethod     = 20
	TxCommitOkMethod   = 21
	TxRollbackMethod   = 30
	TxRollbackOkMethod = 31
)

var endian = binary.BigEndian

type ConnectionStart struct {
	VersionMajor     uint8
	VersionMinor     uint8
	ServerProperties *types.Struct
	Mechanisms       string
	Locales          string
}

func (f *ConnectionStart) Unmarshal(data []byte) error {
	*f = ConnectionStart{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionStartMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionStartMethod, id)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field version-major: read octet failed")
	} else {
		f.VersionMajor = b
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field version-minor: read octet failed")
	} else {
		f.VersionMinor = b
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field server-properties: read table failed")
	} else if n < 4 {
		return errors.New("field server-properties: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field server-properties: read table failed")
		}
		if f.ServerProperties, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field server-properties: read table failed")
		}
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field mechanisms: read longstr failed")
	} else if n < 4 {
		return errors.New("field mechanisms: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field mechanisms: read longstr failed")
		}
		f.Mechanisms = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field locales: read longstr failed")
	} else if n < 4 {
		return errors.New("field locales: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field locales: read longstr failed")
		}
		f.Locales = string(s)
	}
	return nil
}

func (f *ConnectionStart) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ConnectionClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ConnectionStartMethod)
	buf.Write(x[:2])
	buf.WriteByte(f.VersionMajor)
	buf.WriteByte(f.VersionMinor)
	if tableBuf, err := marshalTable(f.ServerProperties); err != nil {
		return nil, errors.Wrap(err, "server-properties table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	if l := len(f.Mechanisms); l > math.MaxUint32 {
		return nil, errors.Errorf("mechanisms can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Mechanisms)
	}
	if l := len(f.Locales); l > math.MaxUint32 {
		return nil, errors.Errorf("locales can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Locales)
	}
	return buf.Bytes(), nil
}

type ConnectionStartOk struct {
	ClientProperties *types.Struct
	Mechanism        string
	Response         string
	Locale           string
}

func (f *ConnectionStartOk) Unmarshal(data []byte) error {
	*f = ConnectionStartOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionStartOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionStartOkMethod, id)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field client-properties: read table failed")
	} else if n < 4 {
		return errors.New("field client-properties: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field client-properties: read table failed")
		}
		if f.ClientProperties, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field client-properties: read table failed")
		}
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field mechanism: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field mechanism: read shortstr failed")
		}
		f.Mechanism = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field response: read longstr failed")
	} else if n < 4 {
		return errors.New("field response: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field response: read longstr failed")
		}
		f.Response = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field locale: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field locale: read shortstr failed")
		}
		f.Locale = string(s)
	}
	return nil
}

func (f *ConnectionStartOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ConnectionClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ConnectionStartOkMethod)
	buf.Write(x[:2])
	if tableBuf, err := marshalTable(f.ClientProperties); err != nil {
		return nil, errors.Wrap(err, "client-properties table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	if l := len(f.Mechanism); l > math.MaxUint8 {
		return nil, errors.Errorf("mechanism can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Mechanism)
	}
	if l := len(f.Response); l > math.MaxUint32 {
		return nil, errors.Errorf("response can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Response)
	}
	if l := len(f.Locale); l > math.MaxUint8 {
		return nil, errors.Errorf("locale can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Locale)
	}
	return buf.Bytes(), nil
}

type ConnectionSecure struct {
	Challenge string
}

func (f *ConnectionSecure) Unmarshal(data []byte) error {
	*f = ConnectionSecure{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionSecureMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionSecureMethod, id)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field challenge: read longstr failed")
	} else if n < 4 {
		return errors.New("field challenge: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field challenge: read longstr failed")
		}
		f.Challenge = string(s)
	}
	return nil
}

func (f *ConnectionSecure) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ConnectionClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ConnectionSecureMethod)
	buf.Write(x[:2])
	if l := len(f.Challenge); l > math.MaxUint32 {
		return nil, errors.Errorf("challenge can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Challenge)
	}
	return buf.Bytes(), nil
}

type ConnectionSecureOk struct {
	Response string
}

func (f *ConnectionSecureOk) Unmarshal(data []byte) error {
	*f = ConnectionSecureOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionSecureOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionSecureOkMethod, id)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field response: read longstr failed")
	} else if n < 4 {
		return errors.New("field response: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field response: read longstr failed")
		}
		f.Response = string(s)
	}
	return nil
}

func (f *ConnectionSecureOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ConnectionClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ConnectionSecureOkMethod)
	buf.Write(x[:2])
	if l := len(f.Response); l > math.MaxUint32 {
		return nil, errors.Errorf("response can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Response)
	}
	return buf.Bytes(), nil
}

type ConnectionTune struct {
	ChannelMax uint16
	FrameMax   uint32
	Heartbeat  uint16
}

func (f *ConnectionTune) Unmarshal(data []byte) error {
	*f = ConnectionTune{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionTuneMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionTuneMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field channel-max: read short failed")
	} else if n < 2 {
		return errors.New("field channel-max: read short failed")
	}
	f.ChannelMax = endian.Uint16(x[:2])
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field frame-max: read long failed")
	} else if n < 4 {
		return errors.New("field frame-max: read long failed")
	}
	f.FrameMax = endian.Uint32(x[:4])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field heartbeat: read short failed")
	} else if n < 2 {
		return errors.New("field heartbeat: read short failed")
	}
	f.Heartbeat = endian.Uint16(x[:2])
	return nil
}

func (f *ConnectionTune) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ConnectionClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ConnectionTuneMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.ChannelMax)
	buf.Write(x[:2])
	endian.PutUint32(x[:4], f.FrameMax)
	buf.Write(x[:4])
	endian.PutUint16(x[:2], f.Heartbeat)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ConnectionTuneOk struct {
	ChannelMax uint16
	FrameMax   uint32
	Heartbeat  uint16
}

func (f *ConnectionTuneOk) Unmarshal(data []byte) error {
	*f = ConnectionTuneOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionTuneOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionTuneOkMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field channel-max: read short failed")
	} else if n < 2 {
		return errors.New("field channel-max: read short failed")
	}
	f.ChannelMax = endian.Uint16(x[:2])
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field frame-max: read long failed")
	} else if n < 4 {
		return errors.New("field frame-max: read long failed")
	}
	f.FrameMax = endian.Uint32(x[:4])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field heartbeat: read short failed")
	} else if n < 2 {
		return errors.New("field heartbeat: read short failed")
	}
	f.Heartbeat = endian.Uint16(x[:2])
	return nil
}

func (f *ConnectionTuneOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ConnectionClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ConnectionTuneOkMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.ChannelMax)
	buf.Write(x[:2])
	endian.PutUint32(x[:4], f.FrameMax)
	buf.Write(x[:4])
	endian.PutUint16(x[:2], f.Heartbeat)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ConnectionOpen struct {
	VirtualHost string
	Reserved1   string
	Reserved2   bool
}

func (f *ConnectionOpen) Unmarshal(data []byte) error {
	*f = ConnectionOpen{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionOpenMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionOpenMethod, id)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field virtual-host: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field virtual-host: read shortstr failed")
		}
		f.VirtualHost = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reserved-1: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read shortstr failed")
		}
		f.Reserved1 = string(s)
	}
	// TODO: end bit fields
	return nil
}

func (f *ConnectionOpen) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ConnectionClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ConnectionOpenMethod)
	buf.Write(x[:2])
	if l := len(f.VirtualHost); l > math.MaxUint8 {
		return nil, errors.Errorf("virtual-host can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.VirtualHost)
	}
	if l := len(f.Reserved1); l > math.MaxUint8 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Reserved1)
	}
	if f.Reserved2 {
		bits |= 1 << 0
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type ConnectionOpenOk struct {
	Reserved1 string
}

func (f *ConnectionOpenOk) Unmarshal(data []byte) error {
	*f = ConnectionOpenOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionOpenOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionOpenOkMethod, id)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reserved-1: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read shortstr failed")
		}
		f.Reserved1 = string(s)
	}
	return nil
}

func (f *ConnectionOpenOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ConnectionClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ConnectionOpenOkMethod)
	buf.Write(x[:2])
	if l := len(f.Reserved1); l > math.MaxUint8 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Reserved1)
	}
	return buf.Bytes(), nil
}

type ConnectionClose struct {
	ReplyCode uint16
	ReplyText string
	ClassID   uint16
	MethodID  uint16
}

func (f *ConnectionClose) Unmarshal(data []byte) error {
	*f = ConnectionClose{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionCloseMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionCloseMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reply-code: read short failed")
	} else if n < 2 {
		return errors.New("field reply-code: read short failed")
	}
	f.ReplyCode = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reply-text: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reply-text: read shortstr failed")
		}
		f.ReplyText = string(s)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field class-id: read short failed")
	} else if n < 2 {
		return errors.New("field class-id: read short failed")
	}
	f.ClassID = endian.Uint16(x[:2])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field method-id: read short failed")
	} else if n < 2 {
		return errors.New("field method-id: read short failed")
	}
	f.MethodID = endian.Uint16(x[:2])
	return nil
}

func (f *ConnectionClose) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ConnectionClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ConnectionCloseMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.ReplyCode)
	buf.Write(x[:2])
	if l := len(f.ReplyText); l > math.MaxUint8 {
		return nil, errors.Errorf("reply-text can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ReplyText)
	}
	endian.PutUint16(x[:2], f.ClassID)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.MethodID)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ConnectionCloseOk struct {
}

func (f *ConnectionCloseOk) Unmarshal(data []byte) error {
	*f = ConnectionCloseOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionClass {
		return errors.Errorf("expected class ID %d, got %d", ConnectionClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ConnectionCloseOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ConnectionCloseOkMethod, id)
	}
	return nil
}

func (f *ConnectionCloseOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ConnectionClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ConnectionCloseOkMethod)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ChannelOpen struct {
	Reserved1 string
}

func (f *ChannelOpen) Unmarshal(data []byte) error {
	*f = ChannelOpen{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ChannelClass {
		return errors.Errorf("expected class ID %d, got %d", ChannelClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ChannelOpenMethod {
		return errors.Errorf("expected method ID %d, got %d", ChannelOpenMethod, id)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reserved-1: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read shortstr failed")
		}
		f.Reserved1 = string(s)
	}
	return nil
}

func (f *ChannelOpen) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ChannelClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ChannelOpenMethod)
	buf.Write(x[:2])
	if l := len(f.Reserved1); l > math.MaxUint8 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Reserved1)
	}
	return buf.Bytes(), nil
}

type ChannelOpenOk struct {
	Reserved1 string
}

func (f *ChannelOpenOk) Unmarshal(data []byte) error {
	*f = ChannelOpenOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ChannelClass {
		return errors.Errorf("expected class ID %d, got %d", ChannelClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ChannelOpenOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ChannelOpenOkMethod, id)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field reserved-1: read longstr failed")
	} else if n < 4 {
		return errors.New("field reserved-1: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read longstr failed")
		}
		f.Reserved1 = string(s)
	}
	return nil
}

func (f *ChannelOpenOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ChannelClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ChannelOpenOkMethod)
	buf.Write(x[:2])
	if l := len(f.Reserved1); l > math.MaxUint32 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Reserved1)
	}
	return buf.Bytes(), nil
}

type ChannelFlow struct {
	Active bool
}

func (f *ChannelFlow) Unmarshal(data []byte) error {
	*f = ChannelFlow{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ChannelClass {
		return errors.Errorf("expected class ID %d, got %d", ChannelClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ChannelFlowMethod {
		return errors.Errorf("expected method ID %d, got %d", ChannelFlowMethod, id)
	}
	// TODO: end bit fields
	return nil
}

func (f *ChannelFlow) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ChannelClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ChannelFlowMethod)
	buf.Write(x[:2])
	if f.Active {
		bits |= 1 << 0
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type ChannelFlowOk struct {
	Active bool
}

func (f *ChannelFlowOk) Unmarshal(data []byte) error {
	*f = ChannelFlowOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ChannelClass {
		return errors.Errorf("expected class ID %d, got %d", ChannelClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ChannelFlowOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ChannelFlowOkMethod, id)
	}
	// TODO: end bit fields
	return nil
}

func (f *ChannelFlowOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ChannelClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ChannelFlowOkMethod)
	buf.Write(x[:2])
	if f.Active {
		bits |= 1 << 0
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type ChannelClose struct {
	ReplyCode uint16
	ReplyText string
	ClassID   uint16
	MethodID  uint16
}

func (f *ChannelClose) Unmarshal(data []byte) error {
	*f = ChannelClose{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ChannelClass {
		return errors.Errorf("expected class ID %d, got %d", ChannelClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ChannelCloseMethod {
		return errors.Errorf("expected method ID %d, got %d", ChannelCloseMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reply-code: read short failed")
	} else if n < 2 {
		return errors.New("field reply-code: read short failed")
	}
	f.ReplyCode = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reply-text: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reply-text: read shortstr failed")
		}
		f.ReplyText = string(s)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field class-id: read short failed")
	} else if n < 2 {
		return errors.New("field class-id: read short failed")
	}
	f.ClassID = endian.Uint16(x[:2])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field method-id: read short failed")
	} else if n < 2 {
		return errors.New("field method-id: read short failed")
	}
	f.MethodID = endian.Uint16(x[:2])
	return nil
}

func (f *ChannelClose) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ChannelClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ChannelCloseMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.ReplyCode)
	buf.Write(x[:2])
	if l := len(f.ReplyText); l > math.MaxUint8 {
		return nil, errors.Errorf("reply-text can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ReplyText)
	}
	endian.PutUint16(x[:2], f.ClassID)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.MethodID)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ChannelCloseOk struct {
}

func (f *ChannelCloseOk) Unmarshal(data []byte) error {
	*f = ChannelCloseOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ChannelClass {
		return errors.Errorf("expected class ID %d, got %d", ChannelClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ChannelCloseOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ChannelCloseOkMethod, id)
	}
	return nil
}

func (f *ChannelCloseOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ChannelClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ChannelCloseOkMethod)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ExchangeDeclare struct {
	Reserved1 uint16
	Exchange  string
	Type      string
	Passive   bool
	Durable   bool
	Reserved2 bool
	Reserved3 bool
	NoWait    bool
	Arguments *types.Struct
}

func (f *ExchangeDeclare) Unmarshal(data []byte) error {
	*f = ExchangeDeclare{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ExchangeClass {
		return errors.Errorf("expected class ID %d, got %d", ExchangeClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ExchangeDeclareMethod {
		return errors.Errorf("expected method ID %d, got %d", ExchangeDeclareMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field type: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field type: read shortstr failed")
		}
		f.Type = string(s)
	}

	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		_ = b
		// TODO: bit fields
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	return nil
}

func (f *ExchangeDeclare) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ExchangeClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ExchangeDeclareMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.Type); l > math.MaxUint8 {
		return nil, errors.Errorf("type can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Type)
	}
	if f.Passive {
		bits |= 1 << 0
	}

	if f.Durable {
		bits |= 1 << 1
	}

	if f.Reserved2 {
		bits |= 1 << 2
	}

	if f.Reserved3 {
		bits |= 1 << 3
	}

	if f.NoWait {
		bits |= 1 << 4
	}
	buf.WriteByte(bits)
	bits = 0
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type ExchangeDeclareOk struct {
}

func (f *ExchangeDeclareOk) Unmarshal(data []byte) error {
	*f = ExchangeDeclareOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ExchangeClass {
		return errors.Errorf("expected class ID %d, got %d", ExchangeClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ExchangeDeclareOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ExchangeDeclareOkMethod, id)
	}
	return nil
}

func (f *ExchangeDeclareOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ExchangeClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ExchangeDeclareOkMethod)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ExchangeDelete struct {
	Reserved1 uint16
	Exchange  string
	IfUnused  bool
	NoWait    bool
}

func (f *ExchangeDelete) Unmarshal(data []byte) error {
	*f = ExchangeDelete{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ExchangeClass {
		return errors.Errorf("expected class ID %d, got %d", ExchangeClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ExchangeDeleteMethod {
		return errors.Errorf("expected method ID %d, got %d", ExchangeDeleteMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}

	// TODO: end bit fields
	return nil
}

func (f *ExchangeDelete) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ExchangeClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ExchangeDeleteMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if f.IfUnused {
		bits |= 1 << 0
	}

	if f.NoWait {
		bits |= 1 << 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type ExchangeDeleteOk struct {
}

func (f *ExchangeDeleteOk) Unmarshal(data []byte) error {
	*f = ExchangeDeleteOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ExchangeClass {
		return errors.Errorf("expected class ID %d, got %d", ExchangeClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != ExchangeDeleteOkMethod {
		return errors.Errorf("expected method ID %d, got %d", ExchangeDeleteOkMethod, id)
	}
	return nil
}

func (f *ExchangeDeleteOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], ExchangeClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], ExchangeDeleteOkMethod)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type QueueDeclare struct {
	Reserved1  uint16
	Queue      string
	Passive    bool
	Durable    bool
	Exclusive  bool
	AutoDelete bool
	NoWait     bool
	Arguments  *types.Struct
}

func (f *QueueDeclare) Unmarshal(data []byte) error {
	*f = QueueDeclare{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueDeclareMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueDeclareMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}

	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		_ = b
		// TODO: bit fields
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	return nil
}

func (f *QueueDeclare) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], QueueClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], QueueDeclareMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if f.Passive {
		bits |= 1 << 0
	}

	if f.Durable {
		bits |= 1 << 1
	}

	if f.Exclusive {
		bits |= 1 << 2
	}

	if f.AutoDelete {
		bits |= 1 << 3
	}

	if f.NoWait {
		bits |= 1 << 4
	}
	buf.WriteByte(bits)
	bits = 0
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type QueueDeclareOk struct {
	Queue         string
	MessageCount  uint32
	ConsumerCount uint32
}

func (f *QueueDeclareOk) Unmarshal(data []byte) error {
	*f = QueueDeclareOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueDeclareOkMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueDeclareOkMethod, id)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field message-count: read long failed")
	} else if n < 4 {
		return errors.New("field message-count: read long failed")
	}
	f.MessageCount = endian.Uint32(x[:4])
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field consumer-count: read long failed")
	} else if n < 4 {
		return errors.New("field consumer-count: read long failed")
	}
	f.ConsumerCount = endian.Uint32(x[:4])
	return nil
}

func (f *QueueDeclareOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], QueueClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], QueueDeclareOkMethod)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	endian.PutUint32(x[:4], f.MessageCount)
	buf.Write(x[:4])
	endian.PutUint32(x[:4], f.ConsumerCount)
	buf.Write(x[:4])
	return buf.Bytes(), nil
}

type QueueBind struct {
	Reserved1  uint16
	Queue      string
	Exchange   string
	RoutingKey string
	NoWait     bool
	Arguments  *types.Struct
}

func (f *QueueBind) Unmarshal(data []byte) error {
	*f = QueueBind{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueBindMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueBindMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		_ = b
		// TODO: bit fields
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	return nil
}

func (f *QueueBind) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], QueueClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], QueueBindMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	if f.NoWait {
		bits |= 1 << 0
	}
	buf.WriteByte(bits)
	bits = 0
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type QueueBindOk struct {
}

func (f *QueueBindOk) Unmarshal(data []byte) error {
	*f = QueueBindOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueBindOkMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueBindOkMethod, id)
	}
	return nil
}

func (f *QueueBindOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], QueueClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], QueueBindOkMethod)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type QueueUnbind struct {
	Reserved1  uint16
	Queue      string
	Exchange   string
	RoutingKey string
	Arguments  *types.Struct
}

func (f *QueueUnbind) Unmarshal(data []byte) error {
	*f = QueueUnbind{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueUnbindMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueUnbindMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	return nil
}

func (f *QueueUnbind) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], QueueClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], QueueUnbindMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type QueueUnbindOk struct {
}

func (f *QueueUnbindOk) Unmarshal(data []byte) error {
	*f = QueueUnbindOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueUnbindOkMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueUnbindOkMethod, id)
	}
	return nil
}

func (f *QueueUnbindOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], QueueClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], QueueUnbindOkMethod)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type QueuePurge struct {
	Reserved1 uint16
	Queue     string
	NoWait    bool
}

func (f *QueuePurge) Unmarshal(data []byte) error {
	*f = QueuePurge{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueuePurgeMethod {
		return errors.Errorf("expected method ID %d, got %d", QueuePurgeMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	// TODO: end bit fields
	return nil
}

func (f *QueuePurge) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], QueueClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], QueuePurgeMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if f.NoWait {
		bits |= 1 << 0
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type QueuePurgeOk struct {
	MessageCount uint32
}

func (f *QueuePurgeOk) Unmarshal(data []byte) error {
	*f = QueuePurgeOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueuePurgeOkMethod {
		return errors.Errorf("expected method ID %d, got %d", QueuePurgeOkMethod, id)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field message-count: read long failed")
	} else if n < 4 {
		return errors.New("field message-count: read long failed")
	}
	f.MessageCount = endian.Uint32(x[:4])
	return nil
}

func (f *QueuePurgeOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], QueueClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], QueuePurgeOkMethod)
	buf.Write(x[:2])
	endian.PutUint32(x[:4], f.MessageCount)
	buf.Write(x[:4])
	return buf.Bytes(), nil
}

type QueueDelete struct {
	Reserved1 uint16
	Queue     string
	IfUnused  bool
	IfEmpty   bool
	NoWait    bool
}

func (f *QueueDelete) Unmarshal(data []byte) error {
	*f = QueueDelete{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueDeleteMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueDeleteMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}

	// TODO: end bit fields
	return nil
}

func (f *QueueDelete) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], QueueClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], QueueDeleteMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if f.IfUnused {
		bits |= 1 << 0
	}

	if f.IfEmpty {
		bits |= 1 << 1
	}

	if f.NoWait {
		bits |= 1 << 2
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type QueueDeleteOk struct {
	MessageCount uint32
}

func (f *QueueDeleteOk) Unmarshal(data []byte) error {
	*f = QueueDeleteOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueClass {
		return errors.Errorf("expected class ID %d, got %d", QueueClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != QueueDeleteOkMethod {
		return errors.Errorf("expected method ID %d, got %d", QueueDeleteOkMethod, id)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field message-count: read long failed")
	} else if n < 4 {
		return errors.New("field message-count: read long failed")
	}
	f.MessageCount = endian.Uint32(x[:4])
	return nil
}

func (f *QueueDeleteOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], QueueClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], QueueDeleteOkMethod)
	buf.Write(x[:2])
	endian.PutUint32(x[:4], f.MessageCount)
	buf.Write(x[:4])
	return buf.Bytes(), nil
}

type ContentHeader struct {
	ClassID         uint16
	Weight          uint16
	BodySize        uint64
	ContentType     string
	ContentEncoding string
	Headers         *types.Struct
	DeliveryMode    uint8
	Priority        uint8
	CorrelationID   string
	ReplyTo         string
	Expiration      string
	MessageID       string
	Timestamp       time.Time
	Type            string
	UserID          string
	AppID           string
	Reserved        string
}

func (f *ContentHeader) Unmarshal(buf []byte) error {
	panic("implement me")
}

func (f *ContentHeader) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var flags uint16
	buf := bytes.Buffer{}

	if f.ContentType != "" {
		flags |= 1 << 0

		if l := len(f.ContentType); l > math.MaxUint8 {
			return nil, errors.Errorf("content-type can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.ContentType)
		}
	}

	if f.ContentEncoding != "" {
		flags |= 1 << 1

		if l := len(f.ContentEncoding); l > math.MaxUint8 {
			return nil, errors.Errorf("content-encoding can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.ContentEncoding)
		}
	}

	if f.Headers != nil {
		flags |= 1 << 2

		if tableBuf, err := marshalTable(f.Headers); err != nil {
			return nil, errors.Wrap(err, "headers table marshal failed")
		} else {
			endian.PutUint32(x[:4], uint32(len(tableBuf)))
			buf.Write(x[:4])
			buf.Write(tableBuf)
		}
	}

	if f.DeliveryMode > 0 {
		flags |= 1 << 3

		buf.WriteByte(f.DeliveryMode)
	}

	if f.Priority > 0 {
		flags |= 1 << 4

		buf.WriteByte(f.Priority)
	}

	if f.CorrelationID != "" {
		flags |= 1 << 5

		if l := len(f.CorrelationID); l > math.MaxUint8 {
			return nil, errors.Errorf("correlation-id can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.CorrelationID)
		}
	}

	if f.ReplyTo != "" {
		flags |= 1 << 6

		if l := len(f.ReplyTo); l > math.MaxUint8 {
			return nil, errors.Errorf("reply-to can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.ReplyTo)
		}
	}

	if f.Expiration != "" {
		flags |= 1 << 7

		if l := len(f.Expiration); l > math.MaxUint8 {
			return nil, errors.Errorf("expiration can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.Expiration)
		}
	}

	if f.MessageID != "" {
		flags |= 1 << 8

		if l := len(f.MessageID); l > math.MaxUint8 {
			return nil, errors.Errorf("message-id can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.MessageID)
		}
	}

	if !f.Timestamp.IsZero() {
		flags |= 1 << 9

		endian.PutUint64(x[:8], uint64(f.Timestamp.Unix()))
		buf.Write(x[:8])
	}

	if f.Type != "" {
		flags |= 1 << 10

		if l := len(f.Type); l > math.MaxUint8 {
			return nil, errors.Errorf("type can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.Type)
		}
	}

	if f.UserID != "" {
		flags |= 1 << 11

		if l := len(f.UserID); l > math.MaxUint8 {
			return nil, errors.Errorf("user-id can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.UserID)
		}
	}

	if f.AppID != "" {
		flags |= 1 << 12

		if l := len(f.AppID); l > math.MaxUint8 {
			return nil, errors.Errorf("app-id can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.AppID)
		}
	}

	if f.Reserved != "" {
		flags |= 1 << 13

		if l := len(f.Reserved); l > math.MaxUint8 {
			return nil, errors.Errorf("reserved can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.Reserved)
		}
	}

	ret := bytes.Buffer{}
	endian.PutUint16(x[:2], f.ClassID)
	ret.Write(x[:2])
	endian.PutUint16(x[:2], f.Weight)
	ret.Write(x[:2])
	endian.PutUint64(x[:8], f.BodySize)
	ret.Write(x[:8])
	endian.PutUint16(x[:2], flags)
	ret.Write(x[:2])
	ret.Write(buf.Bytes())

	return ret.Bytes(), nil
}

type BasicQos struct {
	PrefetchSize  uint32
	PrefetchCount uint16
	Global        bool
}

func (f *BasicQos) Unmarshal(data []byte) error {
	*f = BasicQos{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicQosMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicQosMethod, id)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field prefetch-size: read long failed")
	} else if n < 4 {
		return errors.New("field prefetch-size: read long failed")
	}
	f.PrefetchSize = endian.Uint32(x[:4])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field prefetch-count: read short failed")
	} else if n < 2 {
		return errors.New("field prefetch-count: read short failed")
	}
	f.PrefetchCount = endian.Uint16(x[:2])
	// TODO: end bit fields
	return nil
}

func (f *BasicQos) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicQosMethod)
	buf.Write(x[:2])
	endian.PutUint32(x[:4], f.PrefetchSize)
	buf.Write(x[:4])
	endian.PutUint16(x[:2], f.PrefetchCount)
	buf.Write(x[:2])
	if f.Global {
		bits |= 1 << 0
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicQosOk struct {
}

func (f *BasicQosOk) Unmarshal(data []byte) error {
	*f = BasicQosOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicQosOkMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicQosOkMethod, id)
	}
	return nil
}

func (f *BasicQosOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicQosOkMethod)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type BasicConsume struct {
	Reserved1   uint16
	Queue       string
	ConsumerTag string
	NoLocal     bool
	NoAck       bool
	Exclusive   bool
	NoWait      bool
	Arguments   *types.Struct
}

func (f *BasicConsume) Unmarshal(data []byte) error {
	*f = BasicConsume{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicConsumeMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicConsumeMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}

	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		_ = b
		// TODO: bit fields
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	return nil
}

func (f *BasicConsume) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicConsumeMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	if f.NoLocal {
		bits |= 1 << 0
	}

	if f.NoAck {
		bits |= 1 << 1
	}

	if f.Exclusive {
		bits |= 1 << 2
	}

	if f.NoWait {
		bits |= 1 << 3
	}
	buf.WriteByte(bits)
	bits = 0
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type BasicConsumeOk struct {
	ConsumerTag string
}

func (f *BasicConsumeOk) Unmarshal(data []byte) error {
	*f = BasicConsumeOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicConsumeOkMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicConsumeOkMethod, id)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}
	return nil
}

func (f *BasicConsumeOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicConsumeOkMethod)
	buf.Write(x[:2])
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	return buf.Bytes(), nil
}

type BasicCancel struct {
	ConsumerTag string
	NoWait      bool
}

func (f *BasicCancel) Unmarshal(data []byte) error {
	*f = BasicCancel{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicCancelMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicCancelMethod, id)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}
	// TODO: end bit fields
	return nil
}

func (f *BasicCancel) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicCancelMethod)
	buf.Write(x[:2])
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	if f.NoWait {
		bits |= 1 << 0
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicCancelOk struct {
	ConsumerTag string
}

func (f *BasicCancelOk) Unmarshal(data []byte) error {
	*f = BasicCancelOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicCancelOkMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicCancelOkMethod, id)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}
	return nil
}

func (f *BasicCancelOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicCancelOkMethod)
	buf.Write(x[:2])
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	return buf.Bytes(), nil
}

type BasicPublish struct {
	Reserved1  uint16
	Exchange   string
	RoutingKey string
	Mandatory  bool
	Immediate  bool
}

func (f *BasicPublish) Unmarshal(data []byte) error {
	*f = BasicPublish{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicPublishMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicPublishMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}

	// TODO: end bit fields
	return nil
}

func (f *BasicPublish) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicPublishMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	if f.Mandatory {
		bits |= 1 << 0
	}

	if f.Immediate {
		bits |= 1 << 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicReturn struct {
	ReplyCode  uint16
	ReplyText  string
	Exchange   string
	RoutingKey string
}

func (f *BasicReturn) Unmarshal(data []byte) error {
	*f = BasicReturn{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicReturnMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicReturnMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reply-code: read short failed")
	} else if n < 2 {
		return errors.New("field reply-code: read short failed")
	}
	f.ReplyCode = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reply-text: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reply-text: read shortstr failed")
		}
		f.ReplyText = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	return nil
}

func (f *BasicReturn) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicReturnMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.ReplyCode)
	buf.Write(x[:2])
	if l := len(f.ReplyText); l > math.MaxUint8 {
		return nil, errors.Errorf("reply-text can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ReplyText)
	}
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	return buf.Bytes(), nil
}

type BasicDeliver struct {
	ConsumerTag string
	DeliveryTag uint64
	Redelivered bool
	Exchange    string
	RoutingKey  string
}

func (f *BasicDeliver) Unmarshal(data []byte) error {
	*f = BasicDeliver{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicDeliverMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicDeliverMethod, id)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}
	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "field delivery-tag: read longlong failed")
	} else if n < 8 {
		return errors.New("field delivery-tag: read longlong failed")
	}
	f.DeliveryTag = endian.Uint64(x[:8])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		_ = b
		// TODO: bit fields
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	return nil
}

func (f *BasicDeliver) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicDeliverMethod)
	buf.Write(x[:2])
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	endian.PutUint64(x[:8], f.DeliveryTag)
	buf.Write(x[:8])
	if f.Redelivered {
		bits |= 1 << 0
	}
	buf.WriteByte(bits)
	bits = 0
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	return buf.Bytes(), nil
}

type BasicGet struct {
	Reserved1 uint16
	Queue     string
	NoAck     bool
}

func (f *BasicGet) Unmarshal(data []byte) error {
	*f = BasicGet{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicGetMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicGetMethod, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	// TODO: end bit fields
	return nil
}

func (f *BasicGet) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicGetMethod)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if f.NoAck {
		bits |= 1 << 0
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicGetOk struct {
	DeliveryTag  uint64
	Redelivered  bool
	Exchange     string
	RoutingKey   string
	MessageCount uint32
}

func (f *BasicGetOk) Unmarshal(data []byte) error {
	*f = BasicGetOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicGetOkMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicGetOkMethod, id)
	}
	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "field delivery-tag: read longlong failed")
	} else if n < 8 {
		return errors.New("field delivery-tag: read longlong failed")
	}
	f.DeliveryTag = endian.Uint64(x[:8])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		_ = b
		// TODO: bit fields
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field message-count: read long failed")
	} else if n < 4 {
		return errors.New("field message-count: read long failed")
	}
	f.MessageCount = endian.Uint32(x[:4])
	return nil
}

func (f *BasicGetOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicGetOkMethod)
	buf.Write(x[:2])
	endian.PutUint64(x[:8], f.DeliveryTag)
	buf.Write(x[:8])
	if f.Redelivered {
		bits |= 1 << 0
	}
	buf.WriteByte(bits)
	bits = 0
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	endian.PutUint32(x[:4], f.MessageCount)
	buf.Write(x[:4])
	return buf.Bytes(), nil
}

type BasicGetEmpty struct {
	Reserved1 string
}

func (f *BasicGetEmpty) Unmarshal(data []byte) error {
	*f = BasicGetEmpty{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicGetEmptyMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicGetEmptyMethod, id)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reserved-1: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read shortstr failed")
		}
		f.Reserved1 = string(s)
	}
	return nil
}

func (f *BasicGetEmpty) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicGetEmptyMethod)
	buf.Write(x[:2])
	if l := len(f.Reserved1); l > math.MaxUint8 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Reserved1)
	}
	return buf.Bytes(), nil
}

type BasicAck struct {
	DeliveryTag uint64
	Multiple    bool
}

func (f *BasicAck) Unmarshal(data []byte) error {
	*f = BasicAck{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicAckMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicAckMethod, id)
	}
	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "field delivery-tag: read longlong failed")
	} else if n < 8 {
		return errors.New("field delivery-tag: read longlong failed")
	}
	f.DeliveryTag = endian.Uint64(x[:8])
	// TODO: end bit fields
	return nil
}

func (f *BasicAck) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicAckMethod)
	buf.Write(x[:2])
	endian.PutUint64(x[:8], f.DeliveryTag)
	buf.Write(x[:8])
	if f.Multiple {
		bits |= 1 << 0
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicReject struct {
	DeliveryTag uint64
	Requeue     bool
}

func (f *BasicReject) Unmarshal(data []byte) error {
	*f = BasicReject{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicRejectMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicRejectMethod, id)
	}
	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "field delivery-tag: read longlong failed")
	} else if n < 8 {
		return errors.New("field delivery-tag: read longlong failed")
	}
	f.DeliveryTag = endian.Uint64(x[:8])
	// TODO: end bit fields
	return nil
}

func (f *BasicReject) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicRejectMethod)
	buf.Write(x[:2])
	endian.PutUint64(x[:8], f.DeliveryTag)
	buf.Write(x[:8])
	if f.Requeue {
		bits |= 1 << 0
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicRecoverAsync struct {
	Requeue bool
}

func (f *BasicRecoverAsync) Unmarshal(data []byte) error {
	*f = BasicRecoverAsync{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicRecoverAsyncMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicRecoverAsyncMethod, id)
	}
	// TODO: end bit fields
	return nil
}

func (f *BasicRecoverAsync) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicRecoverAsyncMethod)
	buf.Write(x[:2])
	if f.Requeue {
		bits |= 1 << 0
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicRecover struct {
	Requeue bool
}

func (f *BasicRecover) Unmarshal(data []byte) error {
	*f = BasicRecover{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicRecoverMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicRecoverMethod, id)
	}
	// TODO: end bit fields
	return nil
}

func (f *BasicRecover) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicRecoverMethod)
	buf.Write(x[:2])
	if f.Requeue {
		bits |= 1 << 0
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicRecoverOk struct {
}

func (f *BasicRecoverOk) Unmarshal(data []byte) error {
	*f = BasicRecoverOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != BasicRecoverOkMethod {
		return errors.Errorf("expected method ID %d, got %d", BasicRecoverOkMethod, id)
	}
	return nil
}

func (f *BasicRecoverOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], BasicClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], BasicRecoverOkMethod)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type TxSelect struct {
}

func (f *TxSelect) Unmarshal(data []byte) error {
	*f = TxSelect{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != TxClass {
		return errors.Errorf("expected class ID %d, got %d", TxClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != TxSelectMethod {
		return errors.Errorf("expected method ID %d, got %d", TxSelectMethod, id)
	}
	return nil
}

func (f *TxSelect) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], TxClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], TxSelectMethod)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type TxSelectOk struct {
}

func (f *TxSelectOk) Unmarshal(data []byte) error {
	*f = TxSelectOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != TxClass {
		return errors.Errorf("expected class ID %d, got %d", TxClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != TxSelectOkMethod {
		return errors.Errorf("expected method ID %d, got %d", TxSelectOkMethod, id)
	}
	return nil
}

func (f *TxSelectOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], TxClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], TxSelectOkMethod)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type TxCommit struct {
}

func (f *TxCommit) Unmarshal(data []byte) error {
	*f = TxCommit{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != TxClass {
		return errors.Errorf("expected class ID %d, got %d", TxClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != TxCommitMethod {
		return errors.Errorf("expected method ID %d, got %d", TxCommitMethod, id)
	}
	return nil
}

func (f *TxCommit) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], TxClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], TxCommitMethod)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type TxCommitOk struct {
}

func (f *TxCommitOk) Unmarshal(data []byte) error {
	*f = TxCommitOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != TxClass {
		return errors.Errorf("expected class ID %d, got %d", TxClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != TxCommitOkMethod {
		return errors.Errorf("expected method ID %d, got %d", TxCommitOkMethod, id)
	}
	return nil
}

func (f *TxCommitOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], TxClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], TxCommitOkMethod)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type TxRollback struct {
}

func (f *TxRollback) Unmarshal(data []byte) error {
	*f = TxRollback{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != TxClass {
		return errors.Errorf("expected class ID %d, got %d", TxClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != TxRollbackMethod {
		return errors.Errorf("expected method ID %d, got %d", TxRollbackMethod, id)
	}
	return nil
}

func (f *TxRollback) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], TxClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], TxRollbackMethod)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type TxRollbackOk struct {
}

func (f *TxRollbackOk) Unmarshal(data []byte) error {
	*f = TxRollbackOk{}
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := endian.Uint16(x[:2]); id != TxClass {
		return errors.Errorf("expected class ID %d, got %d", TxClass, id)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read method ID failed")
	} else if n < 2 {
		return errors.New("read method ID failed")
	}
	if id := endian.Uint16(x[:2]); id != TxRollbackOkMethod {
		return errors.Errorf("expected method ID %d, got %d", TxRollbackOkMethod, id)
	}
	return nil
}

func (f *TxRollbackOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], TxClass)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], TxRollbackOkMethod)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}
