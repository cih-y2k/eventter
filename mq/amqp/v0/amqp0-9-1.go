// Code generated by ./generator/main.go. DO NOT EDIT.
package v0

//go:generate go run ./generator/main.go ./amqp0-9-1.stripped.xml ./amqp0-9-1.go

import (
	"bytes"
	"math"
	"strconv"
	"time"

	"github.com/gogo/protobuf/types"
	"github.com/pkg/errors"
)

type FrameType uint8
type ClassID uint16
type MethodID uint16

var ErrMalformedFrame = errors.New("malformed frame")

const (
	Major                        = 0
	Minor                        = 9
	Revision                     = 1
	Port                         = 5672
	FrameMethod        FrameType = 1
	FrameHeader        FrameType = 2
	FrameBody          FrameType = 3
	FrameHeartbeat     FrameType = 8
	FrameMinSize                 = 4096
	FrameEnd                     = 206
	ReplySuccess                 = 200
	ContentTooLarge              = 311 // soft-error
	NoConsumers                  = 313 // soft-error
	ConnectionForced             = 320 // hard-error
	InvalidPath                  = 402 // hard-error
	AccessRefused                = 403 // soft-error
	NotFound                     = 404 // soft-error
	ResourceLocked               = 405 // soft-error
	PreconditionFailed           = 406 // soft-error
	FrameError                   = 501 // hard-error
	SyntaxError                  = 502 // hard-error
	CommandInvalid               = 503 // hard-error
	ChannelError                 = 504 // hard-error
	UnexpectedFrame              = 505 // hard-error
	ResourceError                = 506 // hard-error
	NotAllowed                   = 530 // hard-error
	NotImplemented               = 540 // hard-error
	InternalError                = 541 // hard-error

	ConnectionClass          ClassID  = 10
	ConnectionStartMethod    MethodID = 10
	ConnectionStartOkMethod  MethodID = 11
	ConnectionSecureMethod   MethodID = 20
	ConnectionSecureOkMethod MethodID = 21
	ConnectionTuneMethod     MethodID = 30
	ConnectionTuneOkMethod   MethodID = 31
	ConnectionOpenMethod     MethodID = 40
	ConnectionOpenOkMethod   MethodID = 41
	ConnectionCloseMethod    MethodID = 50
	ConnectionCloseOkMethod  MethodID = 51

	ChannelClass         ClassID  = 20
	ChannelOpenMethod    MethodID = 10
	ChannelOpenOkMethod  MethodID = 11
	ChannelFlowMethod    MethodID = 20
	ChannelFlowOkMethod  MethodID = 21
	ChannelCloseMethod   MethodID = 40
	ChannelCloseOkMethod MethodID = 41

	ExchangeClass           ClassID  = 40
	ExchangeDeclareMethod   MethodID = 10
	ExchangeDeclareOkMethod MethodID = 11
	ExchangeDeleteMethod    MethodID = 20
	ExchangeDeleteOkMethod  MethodID = 21

	QueueClass           ClassID  = 50
	QueueDeclareMethod   MethodID = 10
	QueueDeclareOkMethod MethodID = 11
	QueueBindMethod      MethodID = 20
	QueueBindOkMethod    MethodID = 21
	QueueUnbindMethod    MethodID = 50
	QueueUnbindOkMethod  MethodID = 51
	QueuePurgeMethod     MethodID = 30
	QueuePurgeOkMethod   MethodID = 31
	QueueDeleteMethod    MethodID = 40
	QueueDeleteOkMethod  MethodID = 41

	BasicClass              ClassID  = 60
	BasicQosMethod          MethodID = 10
	BasicQosOkMethod        MethodID = 11
	BasicConsumeMethod      MethodID = 20
	BasicConsumeOkMethod    MethodID = 21
	BasicCancelMethod       MethodID = 30
	BasicCancelOkMethod     MethodID = 31
	BasicPublishMethod      MethodID = 40
	BasicReturnMethod       MethodID = 50
	BasicDeliverMethod      MethodID = 60
	BasicGetMethod          MethodID = 70
	BasicGetOkMethod        MethodID = 71
	BasicGetEmptyMethod     MethodID = 72
	BasicAckMethod          MethodID = 80
	BasicRejectMethod       MethodID = 90
	BasicRecoverAsyncMethod MethodID = 100
	BasicRecoverMethod      MethodID = 110
	BasicRecoverOkMethod    MethodID = 111
	BasicNackMethod         MethodID = 120

	TxClass            ClassID  = 90
	TxSelectMethod     MethodID = 10
	TxSelectOkMethod   MethodID = 11
	TxCommitMethod     MethodID = 20
	TxCommitOkMethod   MethodID = 21
	TxRollbackMethod   MethodID = 30
	TxRollbackOkMethod MethodID = 31
)

type Frame interface {
	GetFrameMeta() *FrameMeta
}

type MethodFrame interface {
	Frame
	FixMethodMeta()
	GetMethodMeta() *MethodMeta
	Marshal() ([]byte, error)
}

type FrameMeta struct {
	Type    FrameType
	Channel uint16
	Size    uint32
}

type MethodMeta struct {
	ClassID  ClassID
	MethodID MethodID
}

type ContentBodyFrame struct {
	FrameMeta
	Data []byte
}

func (f *ContentBodyFrame) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

type HeartbeatFrame struct {
	FrameMeta
}

func (f *HeartbeatFrame) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

type ConnectionStart struct {
	FrameMeta
	MethodMeta
	VersionMajor     uint8
	VersionMinor     uint8
	ServerProperties *types.Struct
	Mechanisms       string
	Locales          string
}

func (f *ConnectionStart) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ConnectionStart) FixMethodMeta() {
	f.MethodMeta.ClassID = ConnectionClass
	f.MethodMeta.MethodID = ConnectionStartMethod
}

func (f *ConnectionStart) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ConnectionStart) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field version-major: read octet failed")
	} else {
		f.VersionMajor = b
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field version-minor: read octet failed")
	} else {
		f.VersionMinor = b
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field server-properties: read table failed")
	} else if n < 4 {
		return errors.New("field server-properties: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field server-properties: read table failed")
		}
		if f.ServerProperties, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field server-properties: read table failed")
		}
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field mechanisms: read longstr failed")
	} else if n < 4 {
		return errors.New("field mechanisms: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field mechanisms: read longstr failed")
		}
		f.Mechanisms = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field locales: read longstr failed")
	} else if n < 4 {
		return errors.New("field locales: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field locales: read longstr failed")
		}
		f.Locales = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionStart) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	buf.WriteByte(f.VersionMajor)
	buf.WriteByte(f.VersionMinor)
	if tableBuf, err := marshalTable(f.ServerProperties); err != nil {
		return nil, errors.Wrap(err, "server-properties table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	if l := len(f.Mechanisms); l > math.MaxUint32 {
		return nil, errors.Errorf("mechanisms can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Mechanisms)
	}
	if l := len(f.Locales); l > math.MaxUint32 {
		return nil, errors.Errorf("locales can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Locales)
	}
	return buf.Bytes(), nil
}

type ConnectionStartOk struct {
	FrameMeta
	MethodMeta
	ClientProperties *types.Struct
	Mechanism        string
	Response         string
	Locale           string
}

func (f *ConnectionStartOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ConnectionStartOk) FixMethodMeta() {
	f.MethodMeta.ClassID = ConnectionClass
	f.MethodMeta.MethodID = ConnectionStartOkMethod
}

func (f *ConnectionStartOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ConnectionStartOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field client-properties: read table failed")
	} else if n < 4 {
		return errors.New("field client-properties: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field client-properties: read table failed")
		}
		if f.ClientProperties, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field client-properties: read table failed")
		}
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field mechanism: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field mechanism: read shortstr failed")
		}
		f.Mechanism = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field response: read longstr failed")
	} else if n < 4 {
		return errors.New("field response: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field response: read longstr failed")
		}
		f.Response = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field locale: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field locale: read shortstr failed")
		}
		f.Locale = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionStartOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if tableBuf, err := marshalTable(f.ClientProperties); err != nil {
		return nil, errors.Wrap(err, "client-properties table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	if l := len(f.Mechanism); l > math.MaxUint8 {
		return nil, errors.Errorf("mechanism can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Mechanism)
	}
	if l := len(f.Response); l > math.MaxUint32 {
		return nil, errors.Errorf("response can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Response)
	}
	if l := len(f.Locale); l > math.MaxUint8 {
		return nil, errors.Errorf("locale can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Locale)
	}
	return buf.Bytes(), nil
}

type ConnectionSecure struct {
	FrameMeta
	MethodMeta
	Challenge string
}

func (f *ConnectionSecure) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ConnectionSecure) FixMethodMeta() {
	f.MethodMeta.ClassID = ConnectionClass
	f.MethodMeta.MethodID = ConnectionSecureMethod
}

func (f *ConnectionSecure) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ConnectionSecure) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field challenge: read longstr failed")
	} else if n < 4 {
		return errors.New("field challenge: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field challenge: read longstr failed")
		}
		f.Challenge = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionSecure) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if l := len(f.Challenge); l > math.MaxUint32 {
		return nil, errors.Errorf("challenge can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Challenge)
	}
	return buf.Bytes(), nil
}

type ConnectionSecureOk struct {
	FrameMeta
	MethodMeta
	Response string
}

func (f *ConnectionSecureOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ConnectionSecureOk) FixMethodMeta() {
	f.MethodMeta.ClassID = ConnectionClass
	f.MethodMeta.MethodID = ConnectionSecureOkMethod
}

func (f *ConnectionSecureOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ConnectionSecureOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field response: read longstr failed")
	} else if n < 4 {
		return errors.New("field response: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field response: read longstr failed")
		}
		f.Response = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionSecureOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if l := len(f.Response); l > math.MaxUint32 {
		return nil, errors.Errorf("response can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Response)
	}
	return buf.Bytes(), nil
}

type ConnectionTune struct {
	FrameMeta
	MethodMeta
	ChannelMax uint16
	FrameMax   uint32
	Heartbeat  uint16
}

func (f *ConnectionTune) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ConnectionTune) FixMethodMeta() {
	f.MethodMeta.ClassID = ConnectionClass
	f.MethodMeta.MethodID = ConnectionTuneMethod
}

func (f *ConnectionTune) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ConnectionTune) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field channel-max: read short failed")
	} else if n < 2 {
		return errors.New("field channel-max: read short failed")
	}
	f.ChannelMax = endian.Uint16(x[:2])
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field frame-max: read long failed")
	} else if n < 4 {
		return errors.New("field frame-max: read long failed")
	}
	f.FrameMax = endian.Uint32(x[:4])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field heartbeat: read short failed")
	} else if n < 2 {
		return errors.New("field heartbeat: read short failed")
	}
	f.Heartbeat = endian.Uint16(x[:2])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionTune) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.ChannelMax)
	buf.Write(x[:2])
	endian.PutUint32(x[:4], f.FrameMax)
	buf.Write(x[:4])
	endian.PutUint16(x[:2], f.Heartbeat)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ConnectionTuneOk struct {
	FrameMeta
	MethodMeta
	ChannelMax uint16
	FrameMax   uint32
	Heartbeat  uint16
}

func (f *ConnectionTuneOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ConnectionTuneOk) FixMethodMeta() {
	f.MethodMeta.ClassID = ConnectionClass
	f.MethodMeta.MethodID = ConnectionTuneOkMethod
}

func (f *ConnectionTuneOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ConnectionTuneOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field channel-max: read short failed")
	} else if n < 2 {
		return errors.New("field channel-max: read short failed")
	}
	f.ChannelMax = endian.Uint16(x[:2])
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field frame-max: read long failed")
	} else if n < 4 {
		return errors.New("field frame-max: read long failed")
	}
	f.FrameMax = endian.Uint32(x[:4])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field heartbeat: read short failed")
	} else if n < 2 {
		return errors.New("field heartbeat: read short failed")
	}
	f.Heartbeat = endian.Uint16(x[:2])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionTuneOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.ChannelMax)
	buf.Write(x[:2])
	endian.PutUint32(x[:4], f.FrameMax)
	buf.Write(x[:4])
	endian.PutUint16(x[:2], f.Heartbeat)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ConnectionOpen struct {
	FrameMeta
	MethodMeta
	VirtualHost string
	Reserved1   string
	Reserved2   bool
}

func (f *ConnectionOpen) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ConnectionOpen) FixMethodMeta() {
	f.MethodMeta.ClassID = ConnectionClass
	f.MethodMeta.MethodID = ConnectionOpenMethod
}

func (f *ConnectionOpen) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ConnectionOpen) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field virtual-host: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field virtual-host: read shortstr failed")
		}
		f.VirtualHost = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reserved-1: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read shortstr failed")
		}
		f.Reserved1 = string(s)
	}
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Reserved2 = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionOpen) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if l := len(f.VirtualHost); l > math.MaxUint8 {
		return nil, errors.Errorf("virtual-host can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.VirtualHost)
	}
	if l := len(f.Reserved1); l > math.MaxUint8 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Reserved1)
	}
	if f.Reserved2 {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type ConnectionOpenOk struct {
	FrameMeta
	MethodMeta
	Reserved1 string
}

func (f *ConnectionOpenOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ConnectionOpenOk) FixMethodMeta() {
	f.MethodMeta.ClassID = ConnectionClass
	f.MethodMeta.MethodID = ConnectionOpenOkMethod
}

func (f *ConnectionOpenOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ConnectionOpenOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reserved-1: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read shortstr failed")
		}
		f.Reserved1 = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionOpenOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if l := len(f.Reserved1); l > math.MaxUint8 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Reserved1)
	}
	return buf.Bytes(), nil
}

type ConnectionClose struct {
	FrameMeta
	MethodMeta
	ReplyCode uint16
	ReplyText string
	ClassID   uint16
	MethodID  uint16
}

func (f *ConnectionClose) Error() string {
	return f.ReplyText + " (" + strconv.Itoa(int(f.ReplyCode)) + ")"
}

func (f *ConnectionClose) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ConnectionClose) FixMethodMeta() {
	f.MethodMeta.ClassID = ConnectionClass
	f.MethodMeta.MethodID = ConnectionCloseMethod
}

func (f *ConnectionClose) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ConnectionClose) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reply-code: read short failed")
	} else if n < 2 {
		return errors.New("field reply-code: read short failed")
	}
	f.ReplyCode = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reply-text: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reply-text: read shortstr failed")
		}
		f.ReplyText = string(s)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field class-id: read short failed")
	} else if n < 2 {
		return errors.New("field class-id: read short failed")
	}
	f.ClassID = endian.Uint16(x[:2])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field method-id: read short failed")
	} else if n < 2 {
		return errors.New("field method-id: read short failed")
	}
	f.MethodID = endian.Uint16(x[:2])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionClose) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.ReplyCode)
	buf.Write(x[:2])
	if l := len(f.ReplyText); l > math.MaxUint8 {
		return nil, errors.Errorf("reply-text can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ReplyText)
	}
	endian.PutUint16(x[:2], f.ClassID)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.MethodID)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ConnectionCloseOk struct {
	FrameMeta
	MethodMeta
}

func (f *ConnectionCloseOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ConnectionCloseOk) FixMethodMeta() {
	f.MethodMeta.ClassID = ConnectionClass
	f.MethodMeta.MethodID = ConnectionCloseOkMethod
}

func (f *ConnectionCloseOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ConnectionCloseOk) Unmarshal(data []byte) error {
	if remains := len(data); remains > 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ConnectionCloseOk) Marshal() ([]byte, error) {
	return nil, nil
}

type ChannelOpen struct {
	FrameMeta
	MethodMeta
	Reserved1 string
}

func (f *ChannelOpen) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ChannelOpen) FixMethodMeta() {
	f.MethodMeta.ClassID = ChannelClass
	f.MethodMeta.MethodID = ChannelOpenMethod
}

func (f *ChannelOpen) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ChannelOpen) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reserved-1: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read shortstr failed")
		}
		f.Reserved1 = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ChannelOpen) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if l := len(f.Reserved1); l > math.MaxUint8 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Reserved1)
	}
	return buf.Bytes(), nil
}

type ChannelOpenOk struct {
	FrameMeta
	MethodMeta
	Reserved1 string
}

func (f *ChannelOpenOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ChannelOpenOk) FixMethodMeta() {
	f.MethodMeta.ClassID = ChannelClass
	f.MethodMeta.MethodID = ChannelOpenOkMethod
}

func (f *ChannelOpenOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ChannelOpenOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field reserved-1: read longstr failed")
	} else if n < 4 {
		return errors.New("field reserved-1: read longstr failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read longstr failed")
		}
		f.Reserved1 = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ChannelOpenOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if l := len(f.Reserved1); l > math.MaxUint32 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint32, l)
	} else {
		endian.PutUint32(x[:4], uint32(l))
		buf.Write(x[:4])
		buf.WriteString(f.Reserved1)
	}
	return buf.Bytes(), nil
}

type ChannelFlow struct {
	FrameMeta
	MethodMeta
	Active bool
}

func (f *ChannelFlow) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ChannelFlow) FixMethodMeta() {
	f.MethodMeta.ClassID = ChannelClass
	f.MethodMeta.MethodID = ChannelFlowMethod
}

func (f *ChannelFlow) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ChannelFlow) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Active = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ChannelFlow) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if f.Active {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type ChannelFlowOk struct {
	FrameMeta
	MethodMeta
	Active bool
}

func (f *ChannelFlowOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ChannelFlowOk) FixMethodMeta() {
	f.MethodMeta.ClassID = ChannelClass
	f.MethodMeta.MethodID = ChannelFlowOkMethod
}

func (f *ChannelFlowOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ChannelFlowOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Active = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ChannelFlowOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if f.Active {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type ChannelClose struct {
	FrameMeta
	MethodMeta
	ReplyCode uint16
	ReplyText string
	ClassID   uint16
	MethodID  uint16
}

func (f *ChannelClose) Error() string {
	return f.ReplyText + " (" + strconv.Itoa(int(f.ReplyCode)) + ")"
}

func (f *ChannelClose) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ChannelClose) FixMethodMeta() {
	f.MethodMeta.ClassID = ChannelClass
	f.MethodMeta.MethodID = ChannelCloseMethod
}

func (f *ChannelClose) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ChannelClose) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reply-code: read short failed")
	} else if n < 2 {
		return errors.New("field reply-code: read short failed")
	}
	f.ReplyCode = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reply-text: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reply-text: read shortstr failed")
		}
		f.ReplyText = string(s)
	}
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field class-id: read short failed")
	} else if n < 2 {
		return errors.New("field class-id: read short failed")
	}
	f.ClassID = endian.Uint16(x[:2])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field method-id: read short failed")
	} else if n < 2 {
		return errors.New("field method-id: read short failed")
	}
	f.MethodID = endian.Uint16(x[:2])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ChannelClose) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.ReplyCode)
	buf.Write(x[:2])
	if l := len(f.ReplyText); l > math.MaxUint8 {
		return nil, errors.Errorf("reply-text can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ReplyText)
	}
	endian.PutUint16(x[:2], f.ClassID)
	buf.Write(x[:2])
	endian.PutUint16(x[:2], f.MethodID)
	buf.Write(x[:2])
	return buf.Bytes(), nil
}

type ChannelCloseOk struct {
	FrameMeta
	MethodMeta
}

func (f *ChannelCloseOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ChannelCloseOk) FixMethodMeta() {
	f.MethodMeta.ClassID = ChannelClass
	f.MethodMeta.MethodID = ChannelCloseOkMethod
}

func (f *ChannelCloseOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ChannelCloseOk) Unmarshal(data []byte) error {
	if remains := len(data); remains > 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ChannelCloseOk) Marshal() ([]byte, error) {
	return nil, nil
}

type ExchangeDeclare struct {
	FrameMeta
	MethodMeta
	Reserved1 uint16
	Exchange  string
	Type      string
	Passive   bool
	Durable   bool
	Reserved2 bool
	Reserved3 bool
	NoWait    bool
	Arguments *types.Struct
}

func (f *ExchangeDeclare) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ExchangeDeclare) FixMethodMeta() {
	f.MethodMeta.ClassID = ExchangeClass
	f.MethodMeta.MethodID = ExchangeDeclareMethod
}

func (f *ExchangeDeclare) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ExchangeDeclare) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field type: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field type: read shortstr failed")
		}
		f.Type = string(s)
	}

	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Passive = bits&1 == 1
		f.Durable = bits&2 == 2
		f.Reserved2 = bits&4 == 4
		f.Reserved3 = bits&8 == 8
		f.NoWait = bits&16 == 16
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ExchangeDeclare) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.Type); l > math.MaxUint8 {
		return nil, errors.Errorf("type can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Type)
	}
	if f.Passive {
		bits |= 1
	}

	if f.Durable {
		bits |= 2
	}

	if f.Reserved2 {
		bits |= 4
	}

	if f.Reserved3 {
		bits |= 8
	}

	if f.NoWait {
		bits |= 16
	}
	buf.WriteByte(bits)
	bits = 0
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type ExchangeDeclareOk struct {
	FrameMeta
	MethodMeta
}

func (f *ExchangeDeclareOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ExchangeDeclareOk) FixMethodMeta() {
	f.MethodMeta.ClassID = ExchangeClass
	f.MethodMeta.MethodID = ExchangeDeclareOkMethod
}

func (f *ExchangeDeclareOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ExchangeDeclareOk) Unmarshal(data []byte) error {
	if remains := len(data); remains > 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ExchangeDeclareOk) Marshal() ([]byte, error) {
	return nil, nil
}

type ExchangeDelete struct {
	FrameMeta
	MethodMeta
	Reserved1 uint16
	Exchange  string
	IfUnused  bool
	NoWait    bool
}

func (f *ExchangeDelete) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ExchangeDelete) FixMethodMeta() {
	f.MethodMeta.ClassID = ExchangeClass
	f.MethodMeta.MethodID = ExchangeDeleteMethod
}

func (f *ExchangeDelete) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ExchangeDelete) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}

	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.IfUnused = (bits & 1) == 1
		f.NoWait = (bits & 2) == 2
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ExchangeDelete) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if f.IfUnused {
		bits |= 1
	}

	if f.NoWait {
		bits |= 2
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type ExchangeDeleteOk struct {
	FrameMeta
	MethodMeta
}

func (f *ExchangeDeleteOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ExchangeDeleteOk) FixMethodMeta() {
	f.MethodMeta.ClassID = ExchangeClass
	f.MethodMeta.MethodID = ExchangeDeleteOkMethod
}

func (f *ExchangeDeleteOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *ExchangeDeleteOk) Unmarshal(data []byte) error {
	if remains := len(data); remains > 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *ExchangeDeleteOk) Marshal() ([]byte, error) {
	return nil, nil
}

type QueueDeclare struct {
	FrameMeta
	MethodMeta
	Reserved1  uint16
	Queue      string
	Passive    bool
	Durable    bool
	Exclusive  bool
	AutoDelete bool
	NoWait     bool
	Arguments  *types.Struct
}

func (f *QueueDeclare) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *QueueDeclare) FixMethodMeta() {
	f.MethodMeta.ClassID = QueueClass
	f.MethodMeta.MethodID = QueueDeclareMethod
}

func (f *QueueDeclare) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *QueueDeclare) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}

	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Passive = bits&1 == 1
		f.Durable = bits&2 == 2
		f.Exclusive = bits&4 == 4
		f.AutoDelete = bits&8 == 8
		f.NoWait = bits&16 == 16
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueDeclare) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if f.Passive {
		bits |= 1
	}

	if f.Durable {
		bits |= 2
	}

	if f.Exclusive {
		bits |= 4
	}

	if f.AutoDelete {
		bits |= 8
	}

	if f.NoWait {
		bits |= 16
	}
	buf.WriteByte(bits)
	bits = 0
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type QueueDeclareOk struct {
	FrameMeta
	MethodMeta
	Queue         string
	MessageCount  uint32
	ConsumerCount uint32
}

func (f *QueueDeclareOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *QueueDeclareOk) FixMethodMeta() {
	f.MethodMeta.ClassID = QueueClass
	f.MethodMeta.MethodID = QueueDeclareOkMethod
}

func (f *QueueDeclareOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *QueueDeclareOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field message-count: read long failed")
	} else if n < 4 {
		return errors.New("field message-count: read long failed")
	}
	f.MessageCount = endian.Uint32(x[:4])
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field consumer-count: read long failed")
	} else if n < 4 {
		return errors.New("field consumer-count: read long failed")
	}
	f.ConsumerCount = endian.Uint32(x[:4])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueDeclareOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	endian.PutUint32(x[:4], f.MessageCount)
	buf.Write(x[:4])
	endian.PutUint32(x[:4], f.ConsumerCount)
	buf.Write(x[:4])
	return buf.Bytes(), nil
}

type QueueBind struct {
	FrameMeta
	MethodMeta
	Reserved1  uint16
	Queue      string
	Exchange   string
	RoutingKey string
	NoWait     bool
	Arguments  *types.Struct
}

func (f *QueueBind) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *QueueBind) FixMethodMeta() {
	f.MethodMeta.ClassID = QueueClass
	f.MethodMeta.MethodID = QueueBindMethod
}

func (f *QueueBind) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *QueueBind) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.NoWait = bits&1 == 1
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueBind) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	if f.NoWait {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type QueueBindOk struct {
	FrameMeta
	MethodMeta
}

func (f *QueueBindOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *QueueBindOk) FixMethodMeta() {
	f.MethodMeta.ClassID = QueueClass
	f.MethodMeta.MethodID = QueueBindOkMethod
}

func (f *QueueBindOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *QueueBindOk) Unmarshal(data []byte) error {
	if remains := len(data); remains > 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueBindOk) Marshal() ([]byte, error) {
	return nil, nil
}

type QueueUnbind struct {
	FrameMeta
	MethodMeta
	Reserved1  uint16
	Queue      string
	Exchange   string
	RoutingKey string
	Arguments  *types.Struct
}

func (f *QueueUnbind) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *QueueUnbind) FixMethodMeta() {
	f.MethodMeta.ClassID = QueueClass
	f.MethodMeta.MethodID = QueueUnbindMethod
}

func (f *QueueUnbind) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *QueueUnbind) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueUnbind) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type QueueUnbindOk struct {
	FrameMeta
	MethodMeta
}

func (f *QueueUnbindOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *QueueUnbindOk) FixMethodMeta() {
	f.MethodMeta.ClassID = QueueClass
	f.MethodMeta.MethodID = QueueUnbindOkMethod
}

func (f *QueueUnbindOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *QueueUnbindOk) Unmarshal(data []byte) error {
	if remains := len(data); remains > 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueUnbindOk) Marshal() ([]byte, error) {
	return nil, nil
}

type QueuePurge struct {
	FrameMeta
	MethodMeta
	Reserved1 uint16
	Queue     string
	NoWait    bool
}

func (f *QueuePurge) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *QueuePurge) FixMethodMeta() {
	f.MethodMeta.ClassID = QueueClass
	f.MethodMeta.MethodID = QueuePurgeMethod
}

func (f *QueuePurge) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *QueuePurge) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.NoWait = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueuePurge) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if f.NoWait {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type QueuePurgeOk struct {
	FrameMeta
	MethodMeta
	MessageCount uint32
}

func (f *QueuePurgeOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *QueuePurgeOk) FixMethodMeta() {
	f.MethodMeta.ClassID = QueueClass
	f.MethodMeta.MethodID = QueuePurgeOkMethod
}

func (f *QueuePurgeOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *QueuePurgeOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field message-count: read long failed")
	} else if n < 4 {
		return errors.New("field message-count: read long failed")
	}
	f.MessageCount = endian.Uint32(x[:4])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueuePurgeOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint32(x[:4], f.MessageCount)
	buf.Write(x[:4])
	return buf.Bytes(), nil
}

type QueueDelete struct {
	FrameMeta
	MethodMeta
	Reserved1 uint16
	Queue     string
	IfUnused  bool
	IfEmpty   bool
	NoWait    bool
}

func (f *QueueDelete) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *QueueDelete) FixMethodMeta() {
	f.MethodMeta.ClassID = QueueClass
	f.MethodMeta.MethodID = QueueDeleteMethod
}

func (f *QueueDelete) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *QueueDelete) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}

	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.IfUnused = (bits & 1) == 1
		f.IfEmpty = (bits & 2) == 2
		f.NoWait = (bits & 4) == 4
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueDelete) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if f.IfUnused {
		bits |= 1
	}

	if f.IfEmpty {
		bits |= 2
	}

	if f.NoWait {
		bits |= 4
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type QueueDeleteOk struct {
	FrameMeta
	MethodMeta
	MessageCount uint32
}

func (f *QueueDeleteOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *QueueDeleteOk) FixMethodMeta() {
	f.MethodMeta.ClassID = QueueClass
	f.MethodMeta.MethodID = QueueDeleteOkMethod
}

func (f *QueueDeleteOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *QueueDeleteOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field message-count: read long failed")
	} else if n < 4 {
		return errors.New("field message-count: read long failed")
	}
	f.MessageCount = endian.Uint32(x[:4])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *QueueDeleteOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint32(x[:4], f.MessageCount)
	buf.Write(x[:4])
	return buf.Bytes(), nil
}

type ContentHeaderFrame struct {
	FrameMeta
	ClassID         ClassID
	Weight          uint16
	BodySize        uint64
	ContentType     string
	ContentEncoding string
	Headers         *types.Struct
	DeliveryMode    uint8
	Priority        uint8
	CorrelationID   string
	ReplyTo         string
	Expiration      string
	MessageID       string
	Timestamp       time.Time
	Type            string
	UserID          string
	AppID           string
	Reserved        string
}

func (f *ContentHeaderFrame) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *ContentHeaderFrame) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read class ID failed")
	} else if n < 2 {
		return errors.New("read class ID failed")
	}
	if id := ClassID(endian.Uint16(x[:2])); id != BasicClass {
		return errors.Errorf("expected class ID %d, got %d", BasicClass, id)
	} else {
		f.ClassID = id
	}

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read weight failed")
	} else if n < 2 {
		return errors.New("read weight failed")
	}
	f.Weight = endian.Uint16(x[:2])

	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "read body size failed")
	} else if n < 8 {
		return errors.New("read body size failed")
	}
	f.BodySize = endian.Uint64(x[:8])

	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "read flags failed")
	} else if n < 2 {
		return errors.New("read flags failed")
	}
	flags := endian.Uint16(x[:2])

	if flags&1 == 1 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field content-type: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field content-type: read shortstr failed")
			}
			f.ContentType = string(s)
		}
	}

	if flags&2 == 2 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field content-encoding: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field content-encoding: read shortstr failed")
			}
			f.ContentEncoding = string(s)
		}
	}

	if flags&4 == 4 {
		if n, err := buf.Read(x[:4]); err != nil {
			return errors.Wrap(err, "field headers: read table failed")
		} else if n < 4 {
			return errors.New("field headers: read table failed")
		} else {
			l := int(endian.Uint32(x[:4]))
			b := buf.Next(l)
			if len(b) < l {
				return errors.New("field headers: read table failed")
			}
			if f.Headers, err = unmarshalTable(b); err != nil {
				return errors.Wrap(err, "field headers: read table failed")
			}
		}
	}

	if flags&8 == 8 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field delivery-mode: read octet failed")
		} else {
			f.DeliveryMode = b
		}
	}

	if flags&16 == 16 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field priority: read octet failed")
		} else {
			f.Priority = b
		}
	}

	if flags&32 == 32 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field correlation-id: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field correlation-id: read shortstr failed")
			}
			f.CorrelationID = string(s)
		}
	}

	if flags&64 == 64 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field reply-to: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field reply-to: read shortstr failed")
			}
			f.ReplyTo = string(s)
		}
	}

	if flags&128 == 128 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field expiration: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field expiration: read shortstr failed")
			}
			f.Expiration = string(s)
		}
	}

	if flags&256 == 256 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field message-id: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field message-id: read shortstr failed")
			}
			f.MessageID = string(s)
		}
	}

	if flags&512 == 512 {
		if n, err := buf.Read(x[:8]); err != nil {
			return errors.Wrap(err, "field timestamp: read timestamp failed")
		} else if n < 8 {
			return errors.New("field timestamp: read timestamp failed")
		}
		f.Timestamp = time.Unix(int64(endian.Uint64(x[:8])), 0)
	}

	if flags&1024 == 1024 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field type: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field type: read shortstr failed")
			}
			f.Type = string(s)
		}
	}

	if flags&2048 == 2048 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field user-id: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field user-id: read shortstr failed")
			}
			f.UserID = string(s)
		}
	}

	if flags&4096 == 4096 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field app-id: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field app-id: read shortstr failed")
			}
			f.AppID = string(s)
		}
	}

	if flags&8192 == 8192 {
		if b, err := buf.ReadByte(); err != nil {
			return errors.Wrap(err, "field reserved: read shortstr failed")
		} else {
			l := int(b)
			s := buf.Next(l)
			if len(s) < l {
				return errors.New("field reserved: read shortstr failed")
			}
			f.Reserved = string(s)
		}
	}

	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}

	return nil
}

func (f *ContentHeaderFrame) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var flags uint16
	buf := bytes.Buffer{}

	if f.ContentType != "" {
		flags |= 1

		if l := len(f.ContentType); l > math.MaxUint8 {
			return nil, errors.Errorf("content-type can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.ContentType)
		}
	}

	if f.ContentEncoding != "" {
		flags |= 2

		if l := len(f.ContentEncoding); l > math.MaxUint8 {
			return nil, errors.Errorf("content-encoding can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.ContentEncoding)
		}
	}

	if f.Headers != nil {
		flags |= 4

		if tableBuf, err := marshalTable(f.Headers); err != nil {
			return nil, errors.Wrap(err, "headers table marshal failed")
		} else {
			endian.PutUint32(x[:4], uint32(len(tableBuf)))
			buf.Write(x[:4])
			buf.Write(tableBuf)
		}
	}

	if f.DeliveryMode > 0 {
		flags |= 8

		buf.WriteByte(f.DeliveryMode)
	}

	if f.Priority > 0 {
		flags |= 16

		buf.WriteByte(f.Priority)
	}

	if f.CorrelationID != "" {
		flags |= 32

		if l := len(f.CorrelationID); l > math.MaxUint8 {
			return nil, errors.Errorf("correlation-id can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.CorrelationID)
		}
	}

	if f.ReplyTo != "" {
		flags |= 64

		if l := len(f.ReplyTo); l > math.MaxUint8 {
			return nil, errors.Errorf("reply-to can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.ReplyTo)
		}
	}

	if f.Expiration != "" {
		flags |= 128

		if l := len(f.Expiration); l > math.MaxUint8 {
			return nil, errors.Errorf("expiration can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.Expiration)
		}
	}

	if f.MessageID != "" {
		flags |= 256

		if l := len(f.MessageID); l > math.MaxUint8 {
			return nil, errors.Errorf("message-id can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.MessageID)
		}
	}

	if !f.Timestamp.IsZero() {
		flags |= 512

		endian.PutUint64(x[:8], uint64(f.Timestamp.Unix()))
		buf.Write(x[:8])
	}

	if f.Type != "" {
		flags |= 1024

		if l := len(f.Type); l > math.MaxUint8 {
			return nil, errors.Errorf("type can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.Type)
		}
	}

	if f.UserID != "" {
		flags |= 2048

		if l := len(f.UserID); l > math.MaxUint8 {
			return nil, errors.Errorf("user-id can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.UserID)
		}
	}

	if f.AppID != "" {
		flags |= 4096

		if l := len(f.AppID); l > math.MaxUint8 {
			return nil, errors.Errorf("app-id can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.AppID)
		}
	}

	if f.Reserved != "" {
		flags |= 8192

		if l := len(f.Reserved); l > math.MaxUint8 {
			return nil, errors.Errorf("reserved can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
		} else {
			buf.WriteByte(byte(l))
			buf.WriteString(f.Reserved)
		}
	}

	ret := bytes.Buffer{}
	endian.PutUint16(x[:2], uint16(f.ClassID))
	ret.Write(x[:2])
	endian.PutUint16(x[:2], f.Weight)
	ret.Write(x[:2])
	endian.PutUint64(x[:8], f.BodySize)
	ret.Write(x[:8])
	endian.PutUint16(x[:2], flags)
	ret.Write(x[:2])
	ret.Write(buf.Bytes())

	return ret.Bytes(), nil
}

type BasicQos struct {
	FrameMeta
	MethodMeta
	PrefetchSize  uint32
	PrefetchCount uint16
	Global        bool
}

func (f *BasicQos) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicQos) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicQosMethod
}

func (f *BasicQos) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicQos) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field prefetch-size: read long failed")
	} else if n < 4 {
		return errors.New("field prefetch-size: read long failed")
	}
	f.PrefetchSize = endian.Uint32(x[:4])
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field prefetch-count: read short failed")
	} else if n < 2 {
		return errors.New("field prefetch-count: read short failed")
	}
	f.PrefetchCount = endian.Uint16(x[:2])
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Global = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicQos) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint32(x[:4], f.PrefetchSize)
	buf.Write(x[:4])
	endian.PutUint16(x[:2], f.PrefetchCount)
	buf.Write(x[:2])
	if f.Global {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicQosOk struct {
	FrameMeta
	MethodMeta
}

func (f *BasicQosOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicQosOk) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicQosOkMethod
}

func (f *BasicQosOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicQosOk) Unmarshal(data []byte) error {
	if remains := len(data); remains > 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicQosOk) Marshal() ([]byte, error) {
	return nil, nil
}

type BasicConsume struct {
	FrameMeta
	MethodMeta
	Reserved1   uint16
	Queue       string
	ConsumerTag string
	NoLocal     bool
	NoAck       bool
	Exclusive   bool
	NoWait      bool
	Arguments   *types.Struct
}

func (f *BasicConsume) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicConsume) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicConsumeMethod
}

func (f *BasicConsume) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicConsume) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}

	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.NoLocal = bits&1 == 1
		f.NoAck = bits&2 == 2
		f.Exclusive = bits&4 == 4
		f.NoWait = bits&8 == 8
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field arguments: read table failed")
	} else if n < 4 {
		return errors.New("field arguments: read table failed")
	} else {
		l := int(endian.Uint32(x[:4]))
		b := buf.Next(l)
		if len(b) < l {
			return errors.New("field arguments: read table failed")
		}
		if f.Arguments, err = unmarshalTable(b); err != nil {
			return errors.Wrap(err, "field arguments: read table failed")
		}
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicConsume) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	if f.NoLocal {
		bits |= 1
	}

	if f.NoAck {
		bits |= 2
	}

	if f.Exclusive {
		bits |= 4
	}

	if f.NoWait {
		bits |= 8
	}
	buf.WriteByte(bits)
	bits = 0
	if tableBuf, err := marshalTable(f.Arguments); err != nil {
		return nil, errors.Wrap(err, "arguments table marshal failed")
	} else {
		endian.PutUint32(x[:4], uint32(len(tableBuf)))
		buf.Write(x[:4])
		buf.Write(tableBuf)
	}
	return buf.Bytes(), nil
}

type BasicConsumeOk struct {
	FrameMeta
	MethodMeta
	ConsumerTag string
}

func (f *BasicConsumeOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicConsumeOk) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicConsumeOkMethod
}

func (f *BasicConsumeOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicConsumeOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicConsumeOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	return buf.Bytes(), nil
}

type BasicCancel struct {
	FrameMeta
	MethodMeta
	ConsumerTag string
	NoWait      bool
}

func (f *BasicCancel) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicCancel) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicCancelMethod
}

func (f *BasicCancel) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicCancel) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.NoWait = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicCancel) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	if f.NoWait {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicCancelOk struct {
	FrameMeta
	MethodMeta
	ConsumerTag string
}

func (f *BasicCancelOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicCancelOk) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicCancelOkMethod
}

func (f *BasicCancelOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicCancelOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicCancelOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	return buf.Bytes(), nil
}

type BasicPublish struct {
	FrameMeta
	MethodMeta
	Reserved1  uint16
	Exchange   string
	RoutingKey string
	Mandatory  bool
	Immediate  bool
}

func (f *BasicPublish) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicPublish) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicPublishMethod
}

func (f *BasicPublish) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicPublish) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}

	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Mandatory = (bits & 1) == 1
		f.Immediate = (bits & 2) == 2
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicPublish) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	if f.Mandatory {
		bits |= 1
	}

	if f.Immediate {
		bits |= 2
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicReturn struct {
	FrameMeta
	MethodMeta
	ReplyCode  uint16
	ReplyText  string
	Exchange   string
	RoutingKey string
}

func (f *BasicReturn) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicReturn) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicReturnMethod
}

func (f *BasicReturn) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicReturn) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reply-code: read short failed")
	} else if n < 2 {
		return errors.New("field reply-code: read short failed")
	}
	f.ReplyCode = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reply-text: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reply-text: read shortstr failed")
		}
		f.ReplyText = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicReturn) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.ReplyCode)
	buf.Write(x[:2])
	if l := len(f.ReplyText); l > math.MaxUint8 {
		return nil, errors.Errorf("reply-text can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ReplyText)
	}
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	return buf.Bytes(), nil
}

type BasicDeliver struct {
	FrameMeta
	MethodMeta
	ConsumerTag string
	DeliveryTag uint64
	Redelivered bool
	Exchange    string
	RoutingKey  string
}

func (f *BasicDeliver) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicDeliver) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicDeliverMethod
}

func (f *BasicDeliver) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicDeliver) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field consumer-tag: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field consumer-tag: read shortstr failed")
		}
		f.ConsumerTag = string(s)
	}
	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "field delivery-tag: read longlong failed")
	} else if n < 8 {
		return errors.New("field delivery-tag: read longlong failed")
	}
	f.DeliveryTag = endian.Uint64(x[:8])
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Redelivered = bits&1 == 1
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicDeliver) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if l := len(f.ConsumerTag); l > math.MaxUint8 {
		return nil, errors.Errorf("consumer-tag can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.ConsumerTag)
	}
	endian.PutUint64(x[:8], f.DeliveryTag)
	buf.Write(x[:8])
	if f.Redelivered {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	return buf.Bytes(), nil
}

type BasicGet struct {
	FrameMeta
	MethodMeta
	Reserved1 uint16
	Queue     string
	NoAck     bool
}

func (f *BasicGet) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicGet) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicGetMethod
}

func (f *BasicGet) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicGet) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:2]); err != nil {
		return errors.Wrap(err, "field reserved-1: read short failed")
	} else if n < 2 {
		return errors.New("field reserved-1: read short failed")
	}
	f.Reserved1 = endian.Uint16(x[:2])
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field queue: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field queue: read shortstr failed")
		}
		f.Queue = string(s)
	}
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.NoAck = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicGet) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint16(x[:2], f.Reserved1)
	buf.Write(x[:2])
	if l := len(f.Queue); l > math.MaxUint8 {
		return nil, errors.Errorf("queue can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Queue)
	}
	if f.NoAck {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicGetOk struct {
	FrameMeta
	MethodMeta
	DeliveryTag  uint64
	Redelivered  bool
	Exchange     string
	RoutingKey   string
	MessageCount uint32
}

func (f *BasicGetOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicGetOk) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicGetOkMethod
}

func (f *BasicGetOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicGetOk) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "field delivery-tag: read longlong failed")
	} else if n < 8 {
		return errors.New("field delivery-tag: read longlong failed")
	}
	f.DeliveryTag = endian.Uint64(x[:8])
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Redelivered = bits&1 == 1
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field exchange: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field exchange: read shortstr failed")
		}
		f.Exchange = string(s)
	}
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field routing-key: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field routing-key: read shortstr failed")
		}
		f.RoutingKey = string(s)
	}
	if n, err := buf.Read(x[:4]); err != nil {
		return errors.Wrap(err, "field message-count: read long failed")
	} else if n < 4 {
		return errors.New("field message-count: read long failed")
	}
	f.MessageCount = endian.Uint32(x[:4])
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicGetOk) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint64(x[:8], f.DeliveryTag)
	buf.Write(x[:8])
	if f.Redelivered {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	if l := len(f.Exchange); l > math.MaxUint8 {
		return nil, errors.Errorf("exchange can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Exchange)
	}
	if l := len(f.RoutingKey); l > math.MaxUint8 {
		return nil, errors.Errorf("routing-key can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.RoutingKey)
	}
	endian.PutUint32(x[:4], f.MessageCount)
	buf.Write(x[:4])
	return buf.Bytes(), nil
}

type BasicGetEmpty struct {
	FrameMeta
	MethodMeta
	Reserved1 string
}

func (f *BasicGetEmpty) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicGetEmpty) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicGetEmptyMethod
}

func (f *BasicGetEmpty) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicGetEmpty) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if b, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "field reserved-1: read shortstr failed")
	} else {
		l := int(b)
		s := buf.Next(l)
		if len(s) < l {
			return errors.New("field reserved-1: read shortstr failed")
		}
		f.Reserved1 = string(s)
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicGetEmpty) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if l := len(f.Reserved1); l > math.MaxUint8 {
		return nil, errors.Errorf("reserved-1 can be at most %d bytes long, got %d bytes", math.MaxUint8, l)
	} else {
		buf.WriteByte(byte(l))
		buf.WriteString(f.Reserved1)
	}
	return buf.Bytes(), nil
}

type BasicAck struct {
	FrameMeta
	MethodMeta
	DeliveryTag uint64
	Multiple    bool
}

func (f *BasicAck) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicAck) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicAckMethod
}

func (f *BasicAck) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicAck) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "field delivery-tag: read longlong failed")
	} else if n < 8 {
		return errors.New("field delivery-tag: read longlong failed")
	}
	f.DeliveryTag = endian.Uint64(x[:8])
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Multiple = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicAck) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint64(x[:8], f.DeliveryTag)
	buf.Write(x[:8])
	if f.Multiple {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicReject struct {
	FrameMeta
	MethodMeta
	DeliveryTag uint64
	Requeue     bool
}

func (f *BasicReject) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicReject) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicRejectMethod
}

func (f *BasicReject) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicReject) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "field delivery-tag: read longlong failed")
	} else if n < 8 {
		return errors.New("field delivery-tag: read longlong failed")
	}
	f.DeliveryTag = endian.Uint64(x[:8])
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Requeue = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicReject) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint64(x[:8], f.DeliveryTag)
	buf.Write(x[:8])
	if f.Requeue {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicRecoverAsync struct {
	FrameMeta
	MethodMeta
	Requeue bool
}

func (f *BasicRecoverAsync) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicRecoverAsync) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicRecoverAsyncMethod
}

func (f *BasicRecoverAsync) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicRecoverAsync) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Requeue = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicRecoverAsync) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if f.Requeue {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicRecover struct {
	FrameMeta
	MethodMeta
	Requeue bool
}

func (f *BasicRecover) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicRecover) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicRecoverMethod
}

func (f *BasicRecover) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicRecover) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Requeue = (bits & 1) == 1
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicRecover) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	if f.Requeue {
		bits |= 1
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type BasicRecoverOk struct {
	FrameMeta
	MethodMeta
}

func (f *BasicRecoverOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicRecoverOk) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicRecoverOkMethod
}

func (f *BasicRecoverOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicRecoverOk) Unmarshal(data []byte) error {
	if remains := len(data); remains > 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicRecoverOk) Marshal() ([]byte, error) {
	return nil, nil
}

type BasicNack struct {
	FrameMeta
	MethodMeta
	DeliveryTag uint64
	Multiple    bool
	Requeue     bool
}

func (f *BasicNack) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *BasicNack) FixMethodMeta() {
	f.MethodMeta.ClassID = BasicClass
	f.MethodMeta.MethodID = BasicNackMethod
}

func (f *BasicNack) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *BasicNack) Unmarshal(data []byte) error {
	var x [8]byte
	_ = x
	buf := bytes.NewBuffer(data)
	if n, err := buf.Read(x[:8]); err != nil {
		return errors.Wrap(err, "field delivery-tag: read longlong failed")
	} else if n < 8 {
		return errors.New("field delivery-tag: read longlong failed")
	}
	f.DeliveryTag = endian.Uint64(x[:8])

	if bits, err := buf.ReadByte(); err != nil {
		return errors.Wrap(err, "read bits failed")
	} else {
		f.Multiple = (bits & 1) == 1
		f.Requeue = (bits & 2) == 2
	}
	if remains := buf.Len(); remains != 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *BasicNack) Marshal() ([]byte, error) {
	var x [8]byte
	_ = x
	var bits byte = 0
	_ = bits
	buf := bytes.Buffer{}
	endian.PutUint64(x[:8], f.DeliveryTag)
	buf.Write(x[:8])
	if f.Multiple {
		bits |= 1
	}

	if f.Requeue {
		bits |= 2
	}
	buf.WriteByte(bits)
	bits = 0
	return buf.Bytes(), nil
}

type TxSelect struct {
	FrameMeta
	MethodMeta
}

func (f *TxSelect) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *TxSelect) FixMethodMeta() {
	f.MethodMeta.ClassID = TxClass
	f.MethodMeta.MethodID = TxSelectMethod
}

func (f *TxSelect) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *TxSelect) Unmarshal(data []byte) error {
	if remains := len(data); remains > 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *TxSelect) Marshal() ([]byte, error) {
	return nil, nil
}

type TxSelectOk struct {
	FrameMeta
	MethodMeta
}

func (f *TxSelectOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *TxSelectOk) FixMethodMeta() {
	f.MethodMeta.ClassID = TxClass
	f.MethodMeta.MethodID = TxSelectOkMethod
}

func (f *TxSelectOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *TxSelectOk) Unmarshal(data []byte) error {
	if remains := len(data); remains > 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *TxSelectOk) Marshal() ([]byte, error) {
	return nil, nil
}

type TxCommit struct {
	FrameMeta
	MethodMeta
}

func (f *TxCommit) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *TxCommit) FixMethodMeta() {
	f.MethodMeta.ClassID = TxClass
	f.MethodMeta.MethodID = TxCommitMethod
}

func (f *TxCommit) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *TxCommit) Unmarshal(data []byte) error {
	if remains := len(data); remains > 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *TxCommit) Marshal() ([]byte, error) {
	return nil, nil
}

type TxCommitOk struct {
	FrameMeta
	MethodMeta
}

func (f *TxCommitOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *TxCommitOk) FixMethodMeta() {
	f.MethodMeta.ClassID = TxClass
	f.MethodMeta.MethodID = TxCommitOkMethod
}

func (f *TxCommitOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *TxCommitOk) Unmarshal(data []byte) error {
	if remains := len(data); remains > 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *TxCommitOk) Marshal() ([]byte, error) {
	return nil, nil
}

type TxRollback struct {
	FrameMeta
	MethodMeta
}

func (f *TxRollback) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *TxRollback) FixMethodMeta() {
	f.MethodMeta.ClassID = TxClass
	f.MethodMeta.MethodID = TxRollbackMethod
}

func (f *TxRollback) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *TxRollback) Unmarshal(data []byte) error {
	if remains := len(data); remains > 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *TxRollback) Marshal() ([]byte, error) {
	return nil, nil
}

type TxRollbackOk struct {
	FrameMeta
	MethodMeta
}

func (f *TxRollbackOk) GetFrameMeta() *FrameMeta {
	return &f.FrameMeta
}

func (f *TxRollbackOk) FixMethodMeta() {
	f.MethodMeta.ClassID = TxClass
	f.MethodMeta.MethodID = TxRollbackOkMethod
}

func (f *TxRollbackOk) GetMethodMeta() *MethodMeta {
	return &f.MethodMeta
}

func (f *TxRollbackOk) Unmarshal(data []byte) error {
	if remains := len(data); remains > 0 {
		return errors.Errorf("buffer not fully read, remains %d bytes", remains)
	}
	return nil
}

func (f *TxRollbackOk) Marshal() ([]byte, error) {
	return nil, nil
}

func decodeMethodFrame(frameMeta FrameMeta, data []byte) (MethodFrame, error) {
	if len(data) < 4 {
		return nil, ErrMalformedFrame
	}

	classID := ClassID(endian.Uint16(data[0:2]))
	methodID := MethodID(endian.Uint16(data[2:4]))

	switch classID {
	case ConnectionClass:
		switch methodID {
		case ConnectionStartMethod:
			frame := &ConnectionStart{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ConnectionStartOkMethod:
			frame := &ConnectionStartOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ConnectionSecureMethod:
			frame := &ConnectionSecure{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ConnectionSecureOkMethod:
			frame := &ConnectionSecureOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ConnectionTuneMethod:
			frame := &ConnectionTune{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ConnectionTuneOkMethod:
			frame := &ConnectionTuneOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ConnectionOpenMethod:
			frame := &ConnectionOpen{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ConnectionOpenOkMethod:
			frame := &ConnectionOpenOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ConnectionCloseMethod:
			frame := &ConnectionClose{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ConnectionCloseOkMethod:
			frame := &ConnectionCloseOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		default:
			return nil, errors.Errorf("unhandled method ID %d of class connection", methodID)
		}

	case ChannelClass:
		switch methodID {
		case ChannelOpenMethod:
			frame := &ChannelOpen{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ChannelOpenOkMethod:
			frame := &ChannelOpenOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ChannelFlowMethod:
			frame := &ChannelFlow{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ChannelFlowOkMethod:
			frame := &ChannelFlowOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ChannelCloseMethod:
			frame := &ChannelClose{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ChannelCloseOkMethod:
			frame := &ChannelCloseOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		default:
			return nil, errors.Errorf("unhandled method ID %d of class channel", methodID)
		}

	case ExchangeClass:
		switch methodID {
		case ExchangeDeclareMethod:
			frame := &ExchangeDeclare{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ExchangeDeclareOkMethod:
			frame := &ExchangeDeclareOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ExchangeDeleteMethod:
			frame := &ExchangeDelete{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case ExchangeDeleteOkMethod:
			frame := &ExchangeDeleteOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		default:
			return nil, errors.Errorf("unhandled method ID %d of class exchange", methodID)
		}

	case QueueClass:
		switch methodID {
		case QueueDeclareMethod:
			frame := &QueueDeclare{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case QueueDeclareOkMethod:
			frame := &QueueDeclareOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case QueueBindMethod:
			frame := &QueueBind{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case QueueBindOkMethod:
			frame := &QueueBindOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case QueueUnbindMethod:
			frame := &QueueUnbind{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case QueueUnbindOkMethod:
			frame := &QueueUnbindOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case QueuePurgeMethod:
			frame := &QueuePurge{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case QueuePurgeOkMethod:
			frame := &QueuePurgeOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case QueueDeleteMethod:
			frame := &QueueDelete{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case QueueDeleteOkMethod:
			frame := &QueueDeleteOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		default:
			return nil, errors.Errorf("unhandled method ID %d of class queue", methodID)
		}

	case BasicClass:
		switch methodID {
		case BasicQosMethod:
			frame := &BasicQos{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicQosOkMethod:
			frame := &BasicQosOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicConsumeMethod:
			frame := &BasicConsume{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicConsumeOkMethod:
			frame := &BasicConsumeOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicCancelMethod:
			frame := &BasicCancel{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicCancelOkMethod:
			frame := &BasicCancelOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicPublishMethod:
			frame := &BasicPublish{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicReturnMethod:
			frame := &BasicReturn{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicDeliverMethod:
			frame := &BasicDeliver{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicGetMethod:
			frame := &BasicGet{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicGetOkMethod:
			frame := &BasicGetOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicGetEmptyMethod:
			frame := &BasicGetEmpty{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicAckMethod:
			frame := &BasicAck{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicRejectMethod:
			frame := &BasicReject{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicRecoverAsyncMethod:
			frame := &BasicRecoverAsync{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicRecoverMethod:
			frame := &BasicRecover{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicRecoverOkMethod:
			frame := &BasicRecoverOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case BasicNackMethod:
			frame := &BasicNack{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		default:
			return nil, errors.Errorf("unhandled method ID %d of class basic", methodID)
		}

	case TxClass:
		switch methodID {
		case TxSelectMethod:
			frame := &TxSelect{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case TxSelectOkMethod:
			frame := &TxSelectOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case TxCommitMethod:
			frame := &TxCommit{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case TxCommitOkMethod:
			frame := &TxCommitOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case TxRollbackMethod:
			frame := &TxRollback{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		case TxRollbackOkMethod:
			frame := &TxRollbackOk{
				FrameMeta: frameMeta,
				MethodMeta: MethodMeta{
					ClassID:  classID,
					MethodID: methodID,
				},
			}
			if err := frame.Unmarshal(data[4:]); err != nil {
				return nil, err
			}
			return frame, nil

		default:
			return nil, errors.Errorf("unhandled method ID %d of class tx", methodID)
		}

	default:
		return nil, errors.Errorf("unhandled class ID %d", classID)
	}
}
