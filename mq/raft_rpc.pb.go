// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: raft_rpc.proto

package mq

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type AppendEntriesRequest_Entry_Type int32

const (
	AppendEntriesRequest_Entry_COMMAND       AppendEntriesRequest_Entry_Type = 0
	AppendEntriesRequest_Entry_NOOP          AppendEntriesRequest_Entry_Type = 1
	AppendEntriesRequest_Entry_ADD_PEER      AppendEntriesRequest_Entry_Type = 2
	AppendEntriesRequest_Entry_REMOVE_PEER   AppendEntriesRequest_Entry_Type = 3
	AppendEntriesRequest_Entry_BARRIER       AppendEntriesRequest_Entry_Type = 4
	AppendEntriesRequest_Entry_CONFIGURATION AppendEntriesRequest_Entry_Type = 5
)

var AppendEntriesRequest_Entry_Type_name = map[int32]string{
	0: "COMMAND",
	1: "NOOP",
	2: "ADD_PEER",
	3: "REMOVE_PEER",
	4: "BARRIER",
	5: "CONFIGURATION",
}
var AppendEntriesRequest_Entry_Type_value = map[string]int32{
	"COMMAND":       0,
	"NOOP":          1,
	"ADD_PEER":      2,
	"REMOVE_PEER":   3,
	"BARRIER":       4,
	"CONFIGURATION": 5,
}

func (x AppendEntriesRequest_Entry_Type) String() string {
	return proto.EnumName(AppendEntriesRequest_Entry_Type_name, int32(x))
}
func (AppendEntriesRequest_Entry_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_raft_rpc_03cad6222b9223c1, []int{0, 0, 0}
}

type AppendEntriesRequest struct {
	Term                 uint64                        `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Leader               []byte                        `protobuf:"bytes,2,opt,name=leader,proto3" json:"leader,omitempty"`
	PrevLogEntry         uint64                        `protobuf:"varint,3,opt,name=prev_log_entry,json=prevLogEntry,proto3" json:"prev_log_entry,omitempty"`
	PrevLogTerm          uint64                        `protobuf:"varint,4,opt,name=prev_log_term,json=prevLogTerm,proto3" json:"prev_log_term,omitempty"`
	Entries              []*AppendEntriesRequest_Entry `protobuf:"bytes,5,rep,name=entries" json:"entries,omitempty"`
	LeaderCommitIndex    uint64                        `protobuf:"varint,6,opt,name=leader_commit_index,json=leaderCommitIndex,proto3" json:"leader_commit_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *AppendEntriesRequest) Reset()         { *m = AppendEntriesRequest{} }
func (m *AppendEntriesRequest) String() string { return proto.CompactTextString(m) }
func (*AppendEntriesRequest) ProtoMessage()    {}
func (*AppendEntriesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_rpc_03cad6222b9223c1, []int{0}
}
func (m *AppendEntriesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendEntriesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendEntriesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AppendEntriesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendEntriesRequest.Merge(dst, src)
}
func (m *AppendEntriesRequest) XXX_Size() int {
	return m.Size()
}
func (m *AppendEntriesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendEntriesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AppendEntriesRequest proto.InternalMessageInfo

func (m *AppendEntriesRequest) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *AppendEntriesRequest) GetLeader() []byte {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *AppendEntriesRequest) GetPrevLogEntry() uint64 {
	if m != nil {
		return m.PrevLogEntry
	}
	return 0
}

func (m *AppendEntriesRequest) GetPrevLogTerm() uint64 {
	if m != nil {
		return m.PrevLogTerm
	}
	return 0
}

func (m *AppendEntriesRequest) GetEntries() []*AppendEntriesRequest_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *AppendEntriesRequest) GetLeaderCommitIndex() uint64 {
	if m != nil {
		return m.LeaderCommitIndex
	}
	return 0
}

type AppendEntriesRequest_Entry struct {
	Index                uint64                          `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Term                 uint64                          `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	Type                 AppendEntriesRequest_Entry_Type `protobuf:"varint,3,opt,name=type,proto3,enum=io.eventter.mq.AppendEntriesRequest_Entry_Type" json:"type,omitempty"`
	Data                 []byte                          `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *AppendEntriesRequest_Entry) Reset()         { *m = AppendEntriesRequest_Entry{} }
func (m *AppendEntriesRequest_Entry) String() string { return proto.CompactTextString(m) }
func (*AppendEntriesRequest_Entry) ProtoMessage()    {}
func (*AppendEntriesRequest_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_rpc_03cad6222b9223c1, []int{0, 0}
}
func (m *AppendEntriesRequest_Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendEntriesRequest_Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendEntriesRequest_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AppendEntriesRequest_Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendEntriesRequest_Entry.Merge(dst, src)
}
func (m *AppendEntriesRequest_Entry) XXX_Size() int {
	return m.Size()
}
func (m *AppendEntriesRequest_Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendEntriesRequest_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_AppendEntriesRequest_Entry proto.InternalMessageInfo

func (m *AppendEntriesRequest_Entry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *AppendEntriesRequest_Entry) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *AppendEntriesRequest_Entry) GetType() AppendEntriesRequest_Entry_Type {
	if m != nil {
		return m.Type
	}
	return AppendEntriesRequest_Entry_COMMAND
}

func (m *AppendEntriesRequest_Entry) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type AppendEntriesResponse struct {
	Term                 uint64   `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	LastLog              uint64   `protobuf:"varint,2,opt,name=last_log,json=lastLog,proto3" json:"last_log,omitempty"`
	Success              bool     `protobuf:"varint,3,opt,name=success,proto3" json:"success,omitempty"`
	NoRetryBackoff       bool     `protobuf:"varint,4,opt,name=no_retry_backoff,json=noRetryBackoff,proto3" json:"no_retry_backoff,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppendEntriesResponse) Reset()         { *m = AppendEntriesResponse{} }
func (m *AppendEntriesResponse) String() string { return proto.CompactTextString(m) }
func (*AppendEntriesResponse) ProtoMessage()    {}
func (*AppendEntriesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_rpc_03cad6222b9223c1, []int{1}
}
func (m *AppendEntriesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendEntriesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendEntriesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AppendEntriesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendEntriesResponse.Merge(dst, src)
}
func (m *AppendEntriesResponse) XXX_Size() int {
	return m.Size()
}
func (m *AppendEntriesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendEntriesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AppendEntriesResponse proto.InternalMessageInfo

func (m *AppendEntriesResponse) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *AppendEntriesResponse) GetLastLog() uint64 {
	if m != nil {
		return m.LastLog
	}
	return 0
}

func (m *AppendEntriesResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *AppendEntriesResponse) GetNoRetryBackoff() bool {
	if m != nil {
		return m.NoRetryBackoff
	}
	return false
}

type RequestVoteRequest struct {
	Term                 uint64   `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Candidate            []byte   `protobuf:"bytes,2,opt,name=candidate,proto3" json:"candidate,omitempty"`
	LastLogIndex         uint64   `protobuf:"varint,3,opt,name=last_log_index,json=lastLogIndex,proto3" json:"last_log_index,omitempty"`
	LastLogTerm          uint64   `protobuf:"varint,4,opt,name=last_log_term,json=lastLogTerm,proto3" json:"last_log_term,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestVoteRequest) Reset()         { *m = RequestVoteRequest{} }
func (m *RequestVoteRequest) String() string { return proto.CompactTextString(m) }
func (*RequestVoteRequest) ProtoMessage()    {}
func (*RequestVoteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_rpc_03cad6222b9223c1, []int{2}
}
func (m *RequestVoteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestVoteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestVoteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RequestVoteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestVoteRequest.Merge(dst, src)
}
func (m *RequestVoteRequest) XXX_Size() int {
	return m.Size()
}
func (m *RequestVoteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestVoteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RequestVoteRequest proto.InternalMessageInfo

func (m *RequestVoteRequest) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RequestVoteRequest) GetCandidate() []byte {
	if m != nil {
		return m.Candidate
	}
	return nil
}

func (m *RequestVoteRequest) GetLastLogIndex() uint64 {
	if m != nil {
		return m.LastLogIndex
	}
	return 0
}

func (m *RequestVoteRequest) GetLastLogTerm() uint64 {
	if m != nil {
		return m.LastLogTerm
	}
	return 0
}

type RequestVoteResponse struct {
	Term                 uint64   `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Granted              bool     `protobuf:"varint,2,opt,name=granted,proto3" json:"granted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestVoteResponse) Reset()         { *m = RequestVoteResponse{} }
func (m *RequestVoteResponse) String() string { return proto.CompactTextString(m) }
func (*RequestVoteResponse) ProtoMessage()    {}
func (*RequestVoteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_rpc_03cad6222b9223c1, []int{3}
}
func (m *RequestVoteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestVoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestVoteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RequestVoteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestVoteResponse.Merge(dst, src)
}
func (m *RequestVoteResponse) XXX_Size() int {
	return m.Size()
}
func (m *RequestVoteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestVoteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RequestVoteResponse proto.InternalMessageInfo

func (m *RequestVoteResponse) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RequestVoteResponse) GetGranted() bool {
	if m != nil {
		return m.Granted
	}
	return false
}

type InstallSnapshotRequest struct {
	// Types that are valid to be assigned to Body:
	//	*InstallSnapshotRequest_Request_
	//	*InstallSnapshotRequest_Data
	Body                 isInstallSnapshotRequest_Body `protobuf_oneof:"body"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *InstallSnapshotRequest) Reset()         { *m = InstallSnapshotRequest{} }
func (m *InstallSnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*InstallSnapshotRequest) ProtoMessage()    {}
func (*InstallSnapshotRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_rpc_03cad6222b9223c1, []int{4}
}
func (m *InstallSnapshotRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallSnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallSnapshotRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstallSnapshotRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallSnapshotRequest.Merge(dst, src)
}
func (m *InstallSnapshotRequest) XXX_Size() int {
	return m.Size()
}
func (m *InstallSnapshotRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallSnapshotRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InstallSnapshotRequest proto.InternalMessageInfo

type isInstallSnapshotRequest_Body interface {
	isInstallSnapshotRequest_Body()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InstallSnapshotRequest_Request_ struct {
	Request *InstallSnapshotRequest_Request `protobuf:"bytes,1,opt,name=request,oneof"`
}
type InstallSnapshotRequest_Data struct {
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

func (*InstallSnapshotRequest_Request_) isInstallSnapshotRequest_Body() {}
func (*InstallSnapshotRequest_Data) isInstallSnapshotRequest_Body()     {}

func (m *InstallSnapshotRequest) GetBody() isInstallSnapshotRequest_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *InstallSnapshotRequest) GetRequest() *InstallSnapshotRequest_Request {
	if x, ok := m.GetBody().(*InstallSnapshotRequest_Request_); ok {
		return x.Request
	}
	return nil
}

func (m *InstallSnapshotRequest) GetData() []byte {
	if x, ok := m.GetBody().(*InstallSnapshotRequest_Data); ok {
		return x.Data
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstallSnapshotRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstallSnapshotRequest_OneofMarshaler, _InstallSnapshotRequest_OneofUnmarshaler, _InstallSnapshotRequest_OneofSizer, []interface{}{
		(*InstallSnapshotRequest_Request_)(nil),
		(*InstallSnapshotRequest_Data)(nil),
	}
}

func _InstallSnapshotRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstallSnapshotRequest)
	// body
	switch x := m.Body.(type) {
	case *InstallSnapshotRequest_Request_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Request); err != nil {
			return err
		}
	case *InstallSnapshotRequest_Data:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Data)
	case nil:
	default:
		return fmt.Errorf("InstallSnapshotRequest.Body has unexpected type %T", x)
	}
	return nil
}

func _InstallSnapshotRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstallSnapshotRequest)
	switch tag {
	case 1: // body.request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InstallSnapshotRequest_Request)
		err := b.DecodeMessage(msg)
		m.Body = &InstallSnapshotRequest_Request_{msg}
		return true, err
	case 2: // body.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Body = &InstallSnapshotRequest_Data{x}
		return true, err
	default:
		return false, nil
	}
}

func _InstallSnapshotRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstallSnapshotRequest)
	// body
	switch x := m.Body.(type) {
	case *InstallSnapshotRequest_Request_:
		s := proto.Size(x.Request)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstallSnapshotRequest_Data:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Data)))
		n += len(x.Data)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type InstallSnapshotRequest_Request struct {
	Term                 uint64   `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Leader               []byte   `protobuf:"bytes,2,opt,name=leader,proto3" json:"leader,omitempty"`
	LastLogIndex         uint64   `protobuf:"varint,3,opt,name=last_log_index,json=lastLogIndex,proto3" json:"last_log_index,omitempty"`
	LastLogTerm          uint64   `protobuf:"varint,4,opt,name=last_log_term,json=lastLogTerm,proto3" json:"last_log_term,omitempty"`
	Configuration        []byte   `protobuf:"bytes,5,opt,name=configuration,proto3" json:"configuration,omitempty"`
	ConfigurationIndex   uint64   `protobuf:"varint,6,opt,name=configuration_index,json=configurationIndex,proto3" json:"configuration_index,omitempty"`
	Size_                int64    `protobuf:"varint,7,opt,name=size,proto3" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InstallSnapshotRequest_Request) Reset()         { *m = InstallSnapshotRequest_Request{} }
func (m *InstallSnapshotRequest_Request) String() string { return proto.CompactTextString(m) }
func (*InstallSnapshotRequest_Request) ProtoMessage()    {}
func (*InstallSnapshotRequest_Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_rpc_03cad6222b9223c1, []int{4, 0}
}
func (m *InstallSnapshotRequest_Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallSnapshotRequest_Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallSnapshotRequest_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstallSnapshotRequest_Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallSnapshotRequest_Request.Merge(dst, src)
}
func (m *InstallSnapshotRequest_Request) XXX_Size() int {
	return m.Size()
}
func (m *InstallSnapshotRequest_Request) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallSnapshotRequest_Request.DiscardUnknown(m)
}

var xxx_messageInfo_InstallSnapshotRequest_Request proto.InternalMessageInfo

func (m *InstallSnapshotRequest_Request) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *InstallSnapshotRequest_Request) GetLeader() []byte {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *InstallSnapshotRequest_Request) GetLastLogIndex() uint64 {
	if m != nil {
		return m.LastLogIndex
	}
	return 0
}

func (m *InstallSnapshotRequest_Request) GetLastLogTerm() uint64 {
	if m != nil {
		return m.LastLogTerm
	}
	return 0
}

func (m *InstallSnapshotRequest_Request) GetConfiguration() []byte {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *InstallSnapshotRequest_Request) GetConfigurationIndex() uint64 {
	if m != nil {
		return m.ConfigurationIndex
	}
	return 0
}

func (m *InstallSnapshotRequest_Request) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type InstallSnapshotResponse struct {
	Term                 uint64   `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Success              bool     `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InstallSnapshotResponse) Reset()         { *m = InstallSnapshotResponse{} }
func (m *InstallSnapshotResponse) String() string { return proto.CompactTextString(m) }
func (*InstallSnapshotResponse) ProtoMessage()    {}
func (*InstallSnapshotResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_rpc_03cad6222b9223c1, []int{5}
}
func (m *InstallSnapshotResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallSnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallSnapshotResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstallSnapshotResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallSnapshotResponse.Merge(dst, src)
}
func (m *InstallSnapshotResponse) XXX_Size() int {
	return m.Size()
}
func (m *InstallSnapshotResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallSnapshotResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InstallSnapshotResponse proto.InternalMessageInfo

func (m *InstallSnapshotResponse) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *InstallSnapshotResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func init() {
	proto.RegisterType((*AppendEntriesRequest)(nil), "io.eventter.mq.AppendEntriesRequest")
	proto.RegisterType((*AppendEntriesRequest_Entry)(nil), "io.eventter.mq.AppendEntriesRequest.Entry")
	proto.RegisterType((*AppendEntriesResponse)(nil), "io.eventter.mq.AppendEntriesResponse")
	proto.RegisterType((*RequestVoteRequest)(nil), "io.eventter.mq.RequestVoteRequest")
	proto.RegisterType((*RequestVoteResponse)(nil), "io.eventter.mq.RequestVoteResponse")
	proto.RegisterType((*InstallSnapshotRequest)(nil), "io.eventter.mq.InstallSnapshotRequest")
	proto.RegisterType((*InstallSnapshotRequest_Request)(nil), "io.eventter.mq.InstallSnapshotRequest.Request")
	proto.RegisterType((*InstallSnapshotResponse)(nil), "io.eventter.mq.InstallSnapshotResponse")
	proto.RegisterEnum("io.eventter.mq.AppendEntriesRequest_Entry_Type", AppendEntriesRequest_Entry_Type_name, AppendEntriesRequest_Entry_Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RaftRPC service

type RaftRPCClient interface {
	DoAppendEntries(ctx context.Context, opts ...grpc.CallOption) (RaftRPC_DoAppendEntriesClient, error)
	DoRequestVote(ctx context.Context, in *RequestVoteRequest, opts ...grpc.CallOption) (*RequestVoteResponse, error)
	DoInstallSnapshot(ctx context.Context, opts ...grpc.CallOption) (RaftRPC_DoInstallSnapshotClient, error)
}

type raftRPCClient struct {
	cc *grpc.ClientConn
}

func NewRaftRPCClient(cc *grpc.ClientConn) RaftRPCClient {
	return &raftRPCClient{cc}
}

func (c *raftRPCClient) DoAppendEntries(ctx context.Context, opts ...grpc.CallOption) (RaftRPC_DoAppendEntriesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RaftRPC_serviceDesc.Streams[0], "/io.eventter.mq.RaftRPC/DoAppendEntries", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftRPCDoAppendEntriesClient{stream}
	return x, nil
}

type RaftRPC_DoAppendEntriesClient interface {
	Send(*AppendEntriesRequest) error
	Recv() (*AppendEntriesResponse, error)
	grpc.ClientStream
}

type raftRPCDoAppendEntriesClient struct {
	grpc.ClientStream
}

func (x *raftRPCDoAppendEntriesClient) Send(m *AppendEntriesRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftRPCDoAppendEntriesClient) Recv() (*AppendEntriesResponse, error) {
	m := new(AppendEntriesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftRPCClient) DoRequestVote(ctx context.Context, in *RequestVoteRequest, opts ...grpc.CallOption) (*RequestVoteResponse, error) {
	out := new(RequestVoteResponse)
	err := c.cc.Invoke(ctx, "/io.eventter.mq.RaftRPC/DoRequestVote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftRPCClient) DoInstallSnapshot(ctx context.Context, opts ...grpc.CallOption) (RaftRPC_DoInstallSnapshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RaftRPC_serviceDesc.Streams[1], "/io.eventter.mq.RaftRPC/DoInstallSnapshot", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftRPCDoInstallSnapshotClient{stream}
	return x, nil
}

type RaftRPC_DoInstallSnapshotClient interface {
	Send(*InstallSnapshotRequest) error
	CloseAndRecv() (*InstallSnapshotResponse, error)
	grpc.ClientStream
}

type raftRPCDoInstallSnapshotClient struct {
	grpc.ClientStream
}

func (x *raftRPCDoInstallSnapshotClient) Send(m *InstallSnapshotRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftRPCDoInstallSnapshotClient) CloseAndRecv() (*InstallSnapshotResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(InstallSnapshotResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for RaftRPC service

type RaftRPCServer interface {
	DoAppendEntries(RaftRPC_DoAppendEntriesServer) error
	DoRequestVote(context.Context, *RequestVoteRequest) (*RequestVoteResponse, error)
	DoInstallSnapshot(RaftRPC_DoInstallSnapshotServer) error
}

func RegisterRaftRPCServer(s *grpc.Server, srv RaftRPCServer) {
	s.RegisterService(&_RaftRPC_serviceDesc, srv)
}

func _RaftRPC_DoAppendEntries_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftRPCServer).DoAppendEntries(&raftRPCDoAppendEntriesServer{stream})
}

type RaftRPC_DoAppendEntriesServer interface {
	Send(*AppendEntriesResponse) error
	Recv() (*AppendEntriesRequest, error)
	grpc.ServerStream
}

type raftRPCDoAppendEntriesServer struct {
	grpc.ServerStream
}

func (x *raftRPCDoAppendEntriesServer) Send(m *AppendEntriesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftRPCDoAppendEntriesServer) Recv() (*AppendEntriesRequest, error) {
	m := new(AppendEntriesRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RaftRPC_DoRequestVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestVoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftRPCServer).DoRequestVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.eventter.mq.RaftRPC/DoRequestVote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftRPCServer).DoRequestVote(ctx, req.(*RequestVoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftRPC_DoInstallSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftRPCServer).DoInstallSnapshot(&raftRPCDoInstallSnapshotServer{stream})
}

type RaftRPC_DoInstallSnapshotServer interface {
	SendAndClose(*InstallSnapshotResponse) error
	Recv() (*InstallSnapshotRequest, error)
	grpc.ServerStream
}

type raftRPCDoInstallSnapshotServer struct {
	grpc.ServerStream
}

func (x *raftRPCDoInstallSnapshotServer) SendAndClose(m *InstallSnapshotResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftRPCDoInstallSnapshotServer) Recv() (*InstallSnapshotRequest, error) {
	m := new(InstallSnapshotRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _RaftRPC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.eventter.mq.RaftRPC",
	HandlerType: (*RaftRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DoRequestVote",
			Handler:    _RaftRPC_DoRequestVote_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DoAppendEntries",
			Handler:       _RaftRPC_DoAppendEntries_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DoInstallSnapshot",
			Handler:       _RaftRPC_DoInstallSnapshot_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "raft_rpc.proto",
}

func (m *AppendEntriesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendEntriesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Term != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.Term))
	}
	if len(m.Leader) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	if m.PrevLogEntry != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.PrevLogEntry))
	}
	if m.PrevLogTerm != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.PrevLogTerm))
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRaftRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LeaderCommitIndex != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.LeaderCommitIndex))
	}
	return i, nil
}

func (m *AppendEntriesRequest_Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendEntriesRequest_Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.Index))
	}
	if m.Term != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.Term))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.Type))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *AppendEntriesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendEntriesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Term != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.Term))
	}
	if m.LastLog != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.LastLog))
	}
	if m.Success {
		dAtA[i] = 0x18
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NoRetryBackoff {
		dAtA[i] = 0x20
		i++
		if m.NoRetryBackoff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RequestVoteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestVoteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Term != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.Term))
	}
	if len(m.Candidate) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(len(m.Candidate)))
		i += copy(dAtA[i:], m.Candidate)
	}
	if m.LastLogIndex != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.LastLogIndex))
	}
	if m.LastLogTerm != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.LastLogTerm))
	}
	return i, nil
}

func (m *RequestVoteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestVoteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Term != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.Term))
	}
	if m.Granted {
		dAtA[i] = 0x10
		i++
		if m.Granted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InstallSnapshotRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallSnapshotRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Body != nil {
		nn1, err := m.Body.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *InstallSnapshotRequest_Request_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Request != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.Request.Size()))
		n2, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *InstallSnapshotRequest_Data) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}
func (m *InstallSnapshotRequest_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallSnapshotRequest_Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Term != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.Term))
	}
	if len(m.Leader) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	if m.LastLogIndex != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.LastLogIndex))
	}
	if m.LastLogTerm != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.LastLogTerm))
	}
	if len(m.Configuration) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(len(m.Configuration)))
		i += copy(dAtA[i:], m.Configuration)
	}
	if m.ConfigurationIndex != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.ConfigurationIndex))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.Size_))
	}
	return i, nil
}

func (m *InstallSnapshotResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallSnapshotResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Term != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRaftRpc(dAtA, i, uint64(m.Term))
	}
	if m.Success {
		dAtA[i] = 0x10
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintRaftRpc(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AppendEntriesRequest) Size() (n int) {
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaftRpc(uint64(m.Term))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovRaftRpc(uint64(l))
	}
	if m.PrevLogEntry != 0 {
		n += 1 + sovRaftRpc(uint64(m.PrevLogEntry))
	}
	if m.PrevLogTerm != 0 {
		n += 1 + sovRaftRpc(uint64(m.PrevLogTerm))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaftRpc(uint64(l))
		}
	}
	if m.LeaderCommitIndex != 0 {
		n += 1 + sovRaftRpc(uint64(m.LeaderCommitIndex))
	}
	return n
}

func (m *AppendEntriesRequest_Entry) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovRaftRpc(uint64(m.Index))
	}
	if m.Term != 0 {
		n += 1 + sovRaftRpc(uint64(m.Term))
	}
	if m.Type != 0 {
		n += 1 + sovRaftRpc(uint64(m.Type))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRaftRpc(uint64(l))
	}
	return n
}

func (m *AppendEntriesResponse) Size() (n int) {
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaftRpc(uint64(m.Term))
	}
	if m.LastLog != 0 {
		n += 1 + sovRaftRpc(uint64(m.LastLog))
	}
	if m.Success {
		n += 2
	}
	if m.NoRetryBackoff {
		n += 2
	}
	return n
}

func (m *RequestVoteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaftRpc(uint64(m.Term))
	}
	l = len(m.Candidate)
	if l > 0 {
		n += 1 + l + sovRaftRpc(uint64(l))
	}
	if m.LastLogIndex != 0 {
		n += 1 + sovRaftRpc(uint64(m.LastLogIndex))
	}
	if m.LastLogTerm != 0 {
		n += 1 + sovRaftRpc(uint64(m.LastLogTerm))
	}
	return n
}

func (m *RequestVoteResponse) Size() (n int) {
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaftRpc(uint64(m.Term))
	}
	if m.Granted {
		n += 2
	}
	return n
}

func (m *InstallSnapshotRequest) Size() (n int) {
	var l int
	_ = l
	if m.Body != nil {
		n += m.Body.Size()
	}
	return n
}

func (m *InstallSnapshotRequest_Request_) Size() (n int) {
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovRaftRpc(uint64(l))
	}
	return n
}
func (m *InstallSnapshotRequest_Data) Size() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovRaftRpc(uint64(l))
	}
	return n
}
func (m *InstallSnapshotRequest_Request) Size() (n int) {
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaftRpc(uint64(m.Term))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovRaftRpc(uint64(l))
	}
	if m.LastLogIndex != 0 {
		n += 1 + sovRaftRpc(uint64(m.LastLogIndex))
	}
	if m.LastLogTerm != 0 {
		n += 1 + sovRaftRpc(uint64(m.LastLogTerm))
	}
	l = len(m.Configuration)
	if l > 0 {
		n += 1 + l + sovRaftRpc(uint64(l))
	}
	if m.ConfigurationIndex != 0 {
		n += 1 + sovRaftRpc(uint64(m.ConfigurationIndex))
	}
	if m.Size_ != 0 {
		n += 1 + sovRaftRpc(uint64(m.Size_))
	}
	return n
}

func (m *InstallSnapshotResponse) Size() (n int) {
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaftRpc(uint64(m.Term))
	}
	if m.Success {
		n += 2
	}
	return n
}

func sovRaftRpc(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRaftRpc(x uint64) (n int) {
	return sovRaftRpc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AppendEntriesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendEntriesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendEntriesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = append(m.Leader[:0], dAtA[iNdEx:postIndex]...)
			if m.Leader == nil {
				m.Leader = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLogEntry", wireType)
			}
			m.PrevLogEntry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevLogEntry |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLogTerm", wireType)
			}
			m.PrevLogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevLogTerm |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &AppendEntriesRequest_Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderCommitIndex", wireType)
			}
			m.LeaderCommitIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderCommitIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendEntriesRequest_Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (AppendEntriesRequest_Entry_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendEntriesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendEntriesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendEntriesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLog", wireType)
			}
			m.LastLog = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLog |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRetryBackoff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoRetryBackoff = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaftRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestVoteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestVoteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestVoteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Candidate", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Candidate = append(m.Candidate[:0], dAtA[iNdEx:postIndex]...)
			if m.Candidate == nil {
				m.Candidate = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogIndex", wireType)
			}
			m.LastLogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLogIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogTerm", wireType)
			}
			m.LastLogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLogTerm |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestVoteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestVoteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestVoteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Granted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Granted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaftRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallSnapshotRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallSnapshotRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallSnapshotRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InstallSnapshotRequest_Request{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &InstallSnapshotRequest_Request_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Body = &InstallSnapshotRequest_Data{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallSnapshotRequest_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = append(m.Leader[:0], dAtA[iNdEx:postIndex]...)
			if m.Leader == nil {
				m.Leader = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogIndex", wireType)
			}
			m.LastLogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLogIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogTerm", wireType)
			}
			m.LastLogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLogTerm |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Configuration = append(m.Configuration[:0], dAtA[iNdEx:postIndex]...)
			if m.Configuration == nil {
				m.Configuration = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationIndex", wireType)
			}
			m.ConfigurationIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallSnapshotResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallSnapshotResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallSnapshotResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaftRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaftRpc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaftRpc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaftRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRaftRpc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRaftRpc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRaftRpc(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRaftRpc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaftRpc   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("raft_rpc.proto", fileDescriptor_raft_rpc_03cad6222b9223c1) }

var fileDescriptor_raft_rpc_03cad6222b9223c1 = []byte{
	// 723 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0x5d, 0x6e, 0xd3, 0x4c,
	0x14, 0x8d, 0x13, 0x27, 0xce, 0x77, 0xf3, 0xd3, 0x74, 0x9a, 0xaf, 0x98, 0x08, 0x45, 0x91, 0x29,
	0x10, 0xf1, 0xe0, 0xa2, 0xb0, 0x82, 0xfc, 0xd1, 0x06, 0xb5, 0x49, 0x35, 0x94, 0x0a, 0x21, 0x24,
	0xcb, 0xb1, 0x27, 0xc1, 0x22, 0xf1, 0xb8, 0xe3, 0x69, 0x45, 0x58, 0x02, 0x4f, 0xdd, 0x09, 0xdb,
	0xe0, 0x91, 0x25, 0xa0, 0xf2, 0x82, 0x90, 0x10, 0x5b, 0x40, 0x1e, 0xdb, 0xa5, 0x4e, 0xab, 0xb4,
	0x42, 0x3c, 0x79, 0xe6, 0xce, 0xb9, 0x33, 0xe7, 0x9e, 0x7b, 0xae, 0x0c, 0x65, 0x66, 0x4e, 0xb8,
	0xc1, 0x3c, 0x4b, 0xf7, 0x18, 0xe5, 0x14, 0x95, 0x1d, 0xaa, 0x93, 0x53, 0xe2, 0x72, 0x4e, 0x98,
	0x3e, 0x3f, 0xd6, 0x7e, 0x66, 0xa0, 0xda, 0xf6, 0x3c, 0xe2, 0xda, 0x7d, 0x97, 0x33, 0x87, 0xf8,
	0x98, 0x1c, 0x9f, 0x10, 0x9f, 0x23, 0x04, 0x32, 0x27, 0x6c, 0xae, 0x4a, 0x0d, 0xa9, 0x29, 0x63,
	0xb1, 0x46, 0x9b, 0x90, 0x9b, 0x11, 0xd3, 0x26, 0x4c, 0x4d, 0x37, 0xa4, 0x66, 0x11, 0x47, 0x3b,
	0xb4, 0x05, 0x65, 0x8f, 0x91, 0x53, 0x63, 0x46, 0xa7, 0x06, 0x71, 0x39, 0x5b, 0xa8, 0x19, 0x91,
	0x55, 0x0c, 0xa2, 0x7b, 0x74, 0x1a, 0x5c, 0xbd, 0x40, 0x1a, 0x94, 0x2e, 0x50, 0xe2, 0x6a, 0x59,
	0x80, 0x0a, 0x11, 0xe8, 0x30, 0x78, 0xa1, 0x07, 0x0a, 0x09, 0x79, 0xa8, 0xd9, 0x46, 0xa6, 0x59,
	0x68, 0x3d, 0xd6, 0x93, 0x84, 0xf5, 0xeb, 0xc8, 0xea, 0xe2, 0x01, 0x1c, 0xa7, 0x22, 0x1d, 0x36,
	0x42, 0x66, 0x86, 0x45, 0xe7, 0x73, 0x87, 0x1b, 0x8e, 0x6b, 0x93, 0xf7, 0x6a, 0x4e, 0xbc, 0xb7,
	0x1e, 0x1e, 0x75, 0xc5, 0xc9, 0x20, 0x38, 0xa8, 0x7d, 0x97, 0x20, 0x1b, 0x72, 0xac, 0x42, 0x36,
	0xc4, 0x86, 0x65, 0x87, 0x9b, 0x0b, 0x2d, 0xd2, 0x97, 0xb4, 0xe8, 0x82, 0xcc, 0x17, 0x1e, 0x11,
	0x95, 0x96, 0x5b, 0xdb, 0xb7, 0xa7, 0xa9, 0x1f, 0x2e, 0x3c, 0x82, 0x45, 0x72, 0x70, 0xb1, 0x6d,
	0x72, 0x53, 0x28, 0x51, 0xc4, 0x62, 0xad, 0xbd, 0x01, 0x39, 0x40, 0xa0, 0x02, 0x28, 0xdd, 0xd1,
	0xfe, 0x7e, 0x7b, 0xd8, 0xab, 0xa4, 0x50, 0x1e, 0xe4, 0xe1, 0x68, 0x74, 0x50, 0x91, 0x50, 0x11,
	0xf2, 0xed, 0x5e, 0xcf, 0x38, 0xe8, 0xf7, 0x71, 0x25, 0x8d, 0xd6, 0xa0, 0x80, 0xfb, 0xfb, 0xa3,
	0xa3, 0x7e, 0x18, 0xc8, 0x04, 0x59, 0x9d, 0x36, 0xc6, 0x83, 0x3e, 0xae, 0xc8, 0x68, 0x1d, 0x4a,
	0xdd, 0xd1, 0xf0, 0xd9, 0x60, 0xe7, 0x25, 0x6e, 0x1f, 0x0e, 0x46, 0xc3, 0x4a, 0x56, 0xfb, 0x28,
	0xc1, 0xff, 0x4b, 0xdc, 0x7c, 0x8f, 0xba, 0x3e, 0xb9, 0xb6, 0xe1, 0x77, 0x21, 0x3f, 0x33, 0x7d,
	0x1e, 0xb4, 0x2c, 0x2a, 0x5e, 0x09, 0xf6, 0x7b, 0x74, 0x8a, 0x54, 0x50, 0xfc, 0x13, 0xcb, 0x22,
	0xbe, 0x2f, 0x24, 0xc8, 0xe3, 0x78, 0x8b, 0x9a, 0x50, 0x71, 0xa9, 0xc1, 0x08, 0x67, 0x0b, 0x63,
	0x6c, 0x5a, 0xef, 0xe8, 0x64, 0x22, 0x0a, 0xcc, 0xe3, 0xb2, 0x4b, 0x71, 0x10, 0xee, 0x84, 0x51,
	0xed, 0x4c, 0x02, 0x14, 0x69, 0x73, 0x44, 0x39, 0x59, 0x65, 0xbd, 0x7b, 0xf0, 0x9f, 0x65, 0xba,
	0xb6, 0x63, 0x9b, 0x9c, 0x44, 0xee, 0xfb, 0x13, 0x08, 0x0c, 0x18, 0xf3, 0x8c, 0x7a, 0x1d, 0x19,
	0x30, 0x62, 0x2b, 0xda, 0x1c, 0x18, 0xf0, 0x02, 0x75, 0xd9, 0x80, 0x11, 0x28, 0x30, 0xa0, 0xd6,
	0x85, 0x8d, 0x04, 0xa3, 0x15, 0xe2, 0xa8, 0xa0, 0x4c, 0x99, 0xe9, 0x72, 0x62, 0x0b, 0x42, 0x79,
	0x1c, 0x6f, 0xb5, 0x5f, 0x69, 0xd8, 0x1c, 0xb8, 0x3e, 0x37, 0x67, 0xb3, 0x17, 0xae, 0xe9, 0xf9,
	0x6f, 0x29, 0x8f, 0x6b, 0x7b, 0x0e, 0x0a, 0x0b, 0x97, 0xe2, 0xae, 0x42, 0x4b, 0x5f, 0x76, 0xce,
	0xf5, 0x89, 0x7a, 0xf4, 0xdd, 0x4d, 0xe1, 0xf8, 0x02, 0x54, 0x8d, 0xdc, 0x23, 0xe4, 0xd8, 0x4d,
	0x85, 0xfe, 0xa9, 0xfd, 0x90, 0x40, 0xf9, 0xcb, 0x21, 0xfe, 0x37, 0x1a, 0xa2, 0x2d, 0x28, 0x59,
	0xd4, 0x9d, 0x38, 0xd3, 0x13, 0x66, 0x72, 0x87, 0xba, 0x6a, 0x56, 0x3c, 0x94, 0x0c, 0xa2, 0x6d,
	0xd8, 0x48, 0x04, 0x12, 0x43, 0x8a, 0x12, 0x47, 0x83, 0x78, 0x0a, 0x7d, 0xe7, 0x03, 0x51, 0x95,
	0x86, 0xd4, 0xcc, 0x60, 0xb1, 0xee, 0xe4, 0x40, 0x1e, 0x53, 0x7b, 0xa1, 0xed, 0xc0, 0x9d, 0x2b,
	0xba, 0xad, 0x6e, 0x5d, 0x6c, 0xde, 0x74, 0xc2, 0xbc, 0xad, 0x4f, 0x69, 0x50, 0xb0, 0x39, 0xe1,
	0xf8, 0xa0, 0x8b, 0xc6, 0xb0, 0xd6, 0xa3, 0x89, 0x61, 0x41, 0x5b, 0xb7, 0x99, 0xf3, 0xda, 0x83,
	0x1b, 0x50, 0x21, 0xb3, 0xa6, 0xf4, 0x44, 0x42, 0xaf, 0xa0, 0xd4, 0xa3, 0x97, 0x1c, 0x87, 0xb4,
	0xe5, 0xdc, 0xab, 0x03, 0x52, 0xbb, 0xbf, 0x12, 0x13, 0xd5, 0x3d, 0x81, 0xf5, 0x1e, 0x5d, 0x12,
	0x05, 0x3d, 0xbc, 0x9d, 0xdb, 0x6a, 0x8f, 0x6e, 0xc4, 0xc5, 0x35, 0x74, 0xaa, 0x9f, 0xcf, 0xeb,
	0xd2, 0x97, 0xf3, 0xba, 0xf4, 0xf5, 0xbc, 0x2e, 0x9d, 0x7d, 0xab, 0xa7, 0x5e, 0xa7, 0xe7, 0xc7,
	0xe3, 0x9c, 0xf8, 0xdd, 0x3c, 0xfd, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xf3, 0xa0, 0x98, 0x96, 0x80,
	0x06, 0x00, 0x00,
}
