syntax = "proto3";

package io.eventter.mq;

import "gogoproto/gogo.proto";
import "google/api/annotations.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

option go_package = "emq";

message NamespaceCreateRequest {
    // If true and node is not a leader, request will fail.
    bool leader_only = 99;
    string namespace = 1;
}

message NamespaceCreateResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    uint64 index = 2;
}

message NamespaceDeleteRequest {
    // If true and node is not a leader, request will fail.
    bool leader_only = 99;
    string namespace = 1;
}

message NamespaceDeleteResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    uint64 index = 2;
}

message NamespaceName {
    string namespace = 1;
    string name = 2;
}

message TopicCreateRequest {
    // If true and node is not a leader, request will fail.
    bool leader_only = 99;
    Topic topic = 1 [(gogoproto.nullable) = false];
}

message TopicCreateResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    uint64 index = 2;
}

message Topic {
    NamespaceName name = 1 [(gogoproto.nullable) = false];
    // Shards limit max number of open segments at the time. Messages are ordered within the shard (segment), however,
    // ordering across shards is not guaranteed. Therefore, for strict ordering (and lower throughput) set shard to 1.
    uint32 shards = 2;
    // Number of copies of data throughout the cluster. Not specified / zero means that the server will choose sensible defaults.
    uint32 replication_factor = 3;
    // If retention is specified, segments will be deleted after they fall off retention period. Zero retention means
    // that segments WON'T be automatically deleted. For segments to be deleted ASAP, use very low retention, i.e. 1 nanosecond.
    google.protobuf.Duration retention = 4 [(gogoproto.nullable) = false, (gogoproto.stdduration) = true];
    // Default exchange type for AMQP bindings.
    string default_exchange_type = 5;
}

message TopicListRequest {
    // If true and node is not a leader, request will fail.
    bool leader_only = 99;
    NamespaceName topic = 1 [(gogoproto.nullable) = false];
}

message TopicListResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    uint64 index = 2;
    repeated Topic topics = 3;
}

message TopicDeleteRequest {
    // If true and node is not a leader, request will fail.
    bool leader_only = 99;
    NamespaceName topic = 1 [(gogoproto.nullable) = false];
    // If true, topic be deleted only if there are no consumer groups using it.
    bool if_unused = 2;
}

message TopicDeleteResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    uint64 index = 2;
}

message TopicPublishRequest {
    // If true and node cannot write message to segment, request will fail.
    bool do_not_forward = 99;
    NamespaceName topic = 1 [(gogoproto.nullable) = false];
    Message message = 2;
}

message TopicPublishResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
}

message ConsumerGroupCreateRequest {
    // If true and node is not a leader, request will fail.
    bool leader_only = 99;
    ConsumerGroup consumer_group = 1 [(gogoproto.nullable) = false];
}

message ConsumerGroupCreateResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    uint64 index = 2;
}

message ConsumerGroup {
    NamespaceName name = 1 [(gogoproto.nullable) = false];
    // Bindings in conjunction with topic's `type` determine if message will be visible to consumer group.
    repeated Binding bindings = 2;
    message Binding {
        string topic_name = 1;
        string exchange_type = 2;
        oneof by {
            string routing_key = 3;
            google.protobuf.Struct headers_all = 4;
            google.protobuf.Struct headers_any = 5;
        }
    }
    // Max count of in-flight messages across all consumers. Not specified / zero means that the server will choose sensible defaults.
    uint32 size = 3;
    // Time from which to consider messages eligible to be consumed by this consumer group.
    google.protobuf.Timestamp since = 4 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];
}

message ConsumerGroupListRequest {
    // If true and node is not a leader, request will fail.
    bool leader_only = 99;
    NamespaceName consumer_group = 1 [(gogoproto.nullable) = false];
}

message ConsumerGroupListResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    uint64 index = 2;
    repeated ConsumerGroup consumer_groups = 3;
}

message ConsumerGroupDeleteRequest {
    // If true and node is not a leader, request will fail.
    bool leader_only = 99;
    NamespaceName consumer_group = 1 [(gogoproto.nullable) = false];
}

message ConsumerGroupDeleteResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    uint64 index = 2;
}

message Message {
    string routing_key = 1;
    Properties properties = 2;
    message Properties {
        string content_type = 1;
        string content_encoding = 2;
        int32 delivery_mode = 3;
        int32 priority = 4;
        string correlation_id = 5 [(gogoproto.customname) = "CorrelationID"];
        string reply_to = 6;
        string expiration = 7;
        string message_id = 8 [(gogoproto.customname) = "MessageID"];
        google.protobuf.Timestamp timestamp = 9 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
        string type = 10;
        string user_id = 11 [(gogoproto.customname) = "UserID"];
        string app_id = 12 [(gogoproto.customname) = "AppID"];
    }
    google.protobuf.Struct headers = 3;
    bytes data = 4;
}

message ConsumerGroupSubscribeRequest {
    // If true and node does not manage consumer group, request will fail.
    bool do_not_forward = 99;
    NamespaceName consumer_group = 1 [(gogoproto.nullable) = false];
    // Max number of messages in-flight. Zero means there is no limit.
    uint32 size = 2;
    // If true, messages will be acked immediately after being sent.
    bool auto_ack = 3;
    // If true, response stream will be closed as soon as there are no waiting messages (either to be consumed, or acked).
    bool do_not_block = 4;
    // If not zero, response stream will be closed as soon as there are no
    uint64 max_messages = 5;
}

message ConsumerGroupSubscribeResponse {
    NamespaceName topic = 1 [(gogoproto.nullable) = false];
    Message message = 2;
    uint64 node_id = 3 [(gogoproto.customname) = "NodeID"];
    uint64 subscription_id = 4 [(gogoproto.customname) = "SubscriptionID"];
    uint64 seq_no = 5;
}

message MessageAckRequest {
    // If true and node does not manage consumer group, request will fail.
    bool do_not_forward = 99;
    uint64 node_id = 1 [(gogoproto.customname) = "NodeID"];
    uint64 subscription_id = 2 [(gogoproto.customname) = "SubscriptionID"];
    uint64 seq_no = 3;
}

message MessageAckResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
}

message MessageNackRequest {
    // If true and node does not manage consumer group, request will fail.
    bool do_not_forward = 99;
    uint64 node_id = 1 [(gogoproto.customname) = "NodeID"];
    uint64 subscription_id = 2 [(gogoproto.customname) = "SubscriptionID"];
    uint64 seq_no = 3;
}

message MessageNackResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
}

service EventterMQ {

    rpc CreateNamespace (NamespaceCreateRequest) returns (NamespaceCreateResponse) {
        option (google.api.http) = {
            put: "/{namespace}"
        };
    };

    rpc DeleteNamespace (NamespaceDeleteRequest) returns (NamespaceDeleteResponse) {
        option (google.api.http) = {
            put: "/{namespace}"
        };
    };

    rpc CreateTopic (TopicCreateRequest) returns (TopicCreateResponse) {
        option (google.api.http) = {
            put: "/{topic.namespace}/topics/{topic.name}"
        };
    }

    rpc ListTopics (TopicListRequest) returns (TopicListResponse) {
        option (google.api.http) = {
            get: "/{topic.namespace}/topics"
        };
    }

    rpc DeleteTopic (TopicDeleteRequest) returns (TopicDeleteResponse) {
        option (google.api.http) = {
            delete: "/{topic.namespace}/topics/{topic.name}"
        };
    }

    rpc Publish (TopicPublishRequest) returns (TopicPublishResponse) {
        option (google.api.http) = {
            post: "/{topic.namespace}/topics/{topic.name}"
            body: "message"
        };
    }

    rpc CreateConsumerGroup (ConsumerGroupCreateRequest) returns (ConsumerGroupCreateResponse) {
        option (google.api.http) = {
            put: "/{consumer_group.namespace}/cgs/{consumer_group.name}"
        };
    }

    rpc ListConsumerGroups (ConsumerGroupListRequest) returns (ConsumerGroupListResponse) {
        option (google.api.http) = {
            get: "/{consumer_group.namespace}/cgs"
        };
    }

    rpc DeleteConsumerGroup (ConsumerGroupDeleteRequest) returns (ConsumerGroupDeleteResponse) {
        option (google.api.http) = {
            delete: "/{consumer_group.namespace}/cgs/{consumer_group.name}"
        };
    }

    rpc Subscribe (ConsumerGroupSubscribeRequest) returns (stream ConsumerGroupSubscribeResponse) {
        option (google.api.http) = {
            post: "/{consumer_group.namespace}/cgs/{consumer_group.name}"
        };
    }

    rpc Ack (MessageAckRequest) returns (MessageAckResponse) {
        option (google.api.http) = {
            post: "/_ack"
        };
    }

    rpc Nack (MessageNackRequest) returns (MessageNackResponse) {
        option (google.api.http) = {
            post: "/_nack"
        };
    }

}
