syntax = "proto3";

package io.eventter.mq;

import "gogoproto/gogo.proto";
import "google/api/annotations.proto";
import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

option go_package = "client";

message NamespaceName {
    string namespace = 1;
    string name = 2;
}

message ConfigureTopicRequest {
    // If true and node is not a leader, request will fail.
    bool leader_only = 99;

    NamespaceName topic = 1 [(gogoproto.nullable) = false];
    // AMQP exchange type.
    string type = 2;
    uint32 shards = 3;
    google.protobuf.Duration retention = 4 [(gogoproto.nullable) = false, (gogoproto.stdduration) = true];
}

message ConfigureTopicResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    uint64 index = 2;
}

message Topic {
    NamespaceName topic = 1 [(gogoproto.nullable) = false];
    string type = 2;
    uint32 shards = 3;
    google.protobuf.Duration retention = 4 [(gogoproto.nullable) = false, (gogoproto.stdduration) = true];
}

message ListTopicsRequest {
    // If true and node is not a leader, request will fail.
    bool leader_only = 99;
    NamespaceName topic = 1 [(gogoproto.nullable) = false];
}

message ListTopicsResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    uint64 index = 2;
    repeated Topic topics = 3;
}

message DeleteTopicRequest {
    // If true and node is not a leader, request will fail.
    bool leader_only = 99;
    NamespaceName topic = 1 [(gogoproto.nullable) = false];
    // If true, topic be deleted only if there are no consumer groups using it.
    bool if_unused = 2;
}

message DeleteTopicResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    uint64 index = 2;
}

message ConfigureConsumerGroupRequest {
    // If true and node is not a leader, request will fail.
    bool leader_only = 99;
    NamespaceName consumer_group = 1 [(gogoproto.nullable) = false];
    repeated Binding bindings = 2;
    uint32 shards = 3;

    message Binding {
        string topic_name = 1;
        string routing_key = 2;
    }
}

message ConfigureConsumerGroupResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    uint64 index = 2;
}

message ConsumerGroup {
    NamespaceName consumer_group = 1 [(gogoproto.nullable) = false];
    repeated Binding bindings = 2;
    uint32 shards = 3;

    message Binding {
        string topic_name = 1;
        string routing_key = 2;
    }
}

message ListConsumerGroupsRequest {
    // If true and node is not a leader, request will fail.
    bool leader_only = 99;
    NamespaceName consumer_group = 1 [(gogoproto.nullable) = false];
}

message ListConsumerGroupsResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    uint64 index = 2;
    repeated ConsumerGroup consumer_groups = 3;
}

message DeleteConsumerGroupRequest {
    // If true and node is not a leader, request will fail.
    bool leader_only = 99;
    NamespaceName consumer_group = 1 [(gogoproto.nullable) = false];
    // Only if there are no consumers.
    bool if_unused = 2;
    // Only if there are no pending messages.
    bool if_empty = 3;
}

message DeleteConsumerGroupResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    uint64 index = 2;
}

message Message {
    string routing_key = 1;
    Properties properties = 2;
    map<string, google.protobuf.Any> headers = 3;
    bytes data = 4;

    message Properties {
        string content_type = 1;
        string content_encoding = 2;
        int32 delivery_mode = 3;
        int32 priority = 4;
        string correlation_id = 5 [(gogoproto.customname) = "CorrelationID"];
        string reply_to = 6;
        string expiration = 7;
        string message_id = 8 [(gogoproto.customname) = "MessageID"];
        google.protobuf.Timestamp timestamp = 9 [(gogoproto.nullable) = true, (gogoproto.stdtime) = true];
        string type = 10;
        string user_id = 11 [(gogoproto.customname) = "UserID"];
        string app_id = 12 [(gogoproto.customname) = "AppID"];
    }
}

message PublishRequest {
    NamespaceName topic = 1 [(gogoproto.nullable) = false];
    Message message = 2 [(gogoproto.nullable) = false];
}

message PublishResponse {
    bool ok = 1 [(gogoproto.customname) = "OK"];
    bytes message_id = 2 [(gogoproto.customname) = "MessageID"];
}

message ConsumeRequest {
    message Request {
        NamespaceName consumer_group = 1 [(gogoproto.nullable) = false];
        string consumer_tag = 2;
        bool no_ack = 3;
        bool exclusive = 4;
    }

    message Ack {
        uint64 delivery_tag = 1;
        bool multiple = 2;
    }

    message Nack {
        uint64 delivery_tag = 1;
        bool multiple = 2;
        bool requeue = 3;
    }

    oneof body {
        Request request = 1;
        Ack ack = 2;
        Nack nack = 3;
    }
}

message ConsumeResponse {
    message Delivery {
        uint64 delivery_tag = 1;
        string consumer_tag = 2;
        NamespaceName topic = 3 [(gogoproto.nullable) = false];
        Message message = 4 [(gogoproto.nullable) = false];
    }

    oneof body {
        Delivery delivery = 1;
    }
}

service EventterMQ {

    rpc ConfigureTopic (ConfigureTopicRequest) returns (ConfigureTopicResponse) {
        option (google.api.http) = {
            put: "/{topic.namespace}/topics/{topic.name}"
        };
    }

    rpc ListTopics (ListTopicsRequest) returns (ListTopicsResponse) {
        option (google.api.http) = {
            get: "/{topic.namespace}/topics"
        };
    }

    rpc DeleteTopic (DeleteTopicRequest) returns (DeleteTopicResponse) {
        option (google.api.http) = {
            delete: "/{topic.namespace}/topics/{topic.name}"
        };
    }

    rpc ConfigureConsumerGroup (ConfigureConsumerGroupRequest) returns (ConfigureConsumerGroupResponse) {
        option (google.api.http) = {
            put: "/{consumer_group.namespace}/cgs/{consumer_group.name}"
        };
    }

    rpc ListConsumerGroups (ListConsumerGroupsRequest) returns (ListConsumerGroupsResponse) {
        option (google.api.http) = {
            get: "/{consumer_group.namespace}/cgs"
        };
    }

    rpc DeleteConsumerGroup (DeleteConsumerGroupRequest) returns (DeleteConsumerGroupResponse) {
        option (google.api.http) = {
            delete: "/{consumer_group.namespace}/cgs/{consumer_group.name}"
        };
    }

    rpc Publish (PublishRequest) returns (PublishResponse) {
        option (google.api.http) = {
            post: "/{topic.namespace}/topics/{topic.name}"
            body: "message"
        };
    }

    rpc Consume (stream ConsumeRequest) returns (stream ConsumeResponse);

}
